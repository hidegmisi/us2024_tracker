
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$4() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function append$2(target, node) {
        target.appendChild(node);
    }
    function insert$1(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        if (value == null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */ Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        // Do not reenter flush while dirty components are updated, as this can
        // result in an infinite loop. Instead, let the inner flush handle it.
        // Reentrancy is ok afterwards for bindings etc.
        if (flushidx !== 0) {
            return;
        }
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            try {
                while (flushidx < dirty_components.length) {
                    const component = dirty_components[flushidx];
                    flushidx++;
                    set_current_component(component);
                    update(component.$$);
                }
            }
            catch (e) {
                // reset dirty state to not end up in a deadlocked state and then rethrow
                dirty_components.length = 0;
                flushidx = 0;
                throw e;
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    /**
     * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
     */
    function flush_render_callbacks(fns) {
        const filtered = [];
        const targets = [];
        render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
        targets.forEach((c) => c());
        render_callbacks = filtered;
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            flush_render_callbacks($$.after_update);
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop$4,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$4;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop$4;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append$2(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert$1(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function ascending$3(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function descending$2(a, b) {
      return a == null || b == null ? NaN
        : b < a ? -1
        : b > a ? 1
        : b >= a ? 0
        : NaN;
    }

    function bisector(f) {
      let compare1, compare2, delta;

      // If an accessor is specified, promote it to a comparator. In this case we
      // can test whether the search value is (self-) comparable. We can’t do this
      // for a comparator (except for specific, known comparators) because we can’t
      // tell if the comparator is symmetric, and an asymmetric comparator can’t be
      // used to test whether a single value is comparable.
      if (f.length !== 2) {
        compare1 = ascending$3;
        compare2 = (d, x) => ascending$3(f(d), x);
        delta = (d, x) => f(d) - x;
      } else {
        compare1 = f === ascending$3 || f === descending$2 ? f : zero$1;
        compare2 = f;
        delta = f;
      }

      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function zero$1() {
      return 0;
    }

    function number$3(x) {
      return x === null ? NaN : +x;
    }

    function* numbers(values, valueof) {
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }

    const ascendingBisect = bisector(ascending$3);
    const bisectRight = ascendingBisect.right;
    const bisectLeft = ascendingBisect.left;
    const bisectCenter = bisector(number$3).center;
    var bisect = bisectRight;

    function blur$1(values, r) {
      if (!((r = +r) >= 0)) throw new RangeError("invalid r");
      let length = values.length;
      if (!((length = Math.floor(length)) >= 0)) throw new RangeError("invalid length");
      if (!length || !r) return values;
      const blur = blurf(r);
      const temp = values.slice();
      blur(values, temp, 0, length, 1);
      blur(temp, values, 0, length, 1);
      blur(values, temp, 0, length, 1);
      return values;
    }

    const blur2 = Blur2(blurf);

    const blurImage = Blur2(blurfImage);

    function Blur2(blur) {
      return function(data, rx, ry = rx) {
        if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
        if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
        let {data: values, width, height} = data;
        if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
        if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
        if (!width || !height || (!rx && !ry)) return data;
        const blurx = rx && blur(rx);
        const blury = ry && blur(ry);
        const temp = values.slice();
        if (blurx && blury) {
          blurh(blurx, temp, values, width, height);
          blurh(blurx, values, temp, width, height);
          blurh(blurx, temp, values, width, height);
          blurv(blury, values, temp, width, height);
          blurv(blury, temp, values, width, height);
          blurv(blury, values, temp, width, height);
        } else if (blurx) {
          blurh(blurx, values, temp, width, height);
          blurh(blurx, temp, values, width, height);
          blurh(blurx, values, temp, width, height);
        } else if (blury) {
          blurv(blury, values, temp, width, height);
          blurv(blury, temp, values, width, height);
          blurv(blury, values, temp, width, height);
        }
        return data;
      };
    }

    function blurh(blur, T, S, w, h) {
      for (let y = 0, n = w * h; y < n;) {
        blur(T, S, y, y += w, 1);
      }
    }

    function blurv(blur, T, S, w, h) {
      for (let x = 0, n = w * h; x < w; ++x) {
        blur(T, S, x, x + n, w);
      }
    }

    function blurfImage(radius) {
      const blur = blurf(radius);
      return (T, S, start, stop, step) => {
        start <<= 2, stop <<= 2, step <<= 2;
        blur(T, S, start + 0, stop + 0, step);
        blur(T, S, start + 1, stop + 1, step);
        blur(T, S, start + 2, stop + 2, step);
        blur(T, S, start + 3, stop + 3, step);
      };
    }

    // Given a target array T, a source array S, sets each value T[i] to the average
    // of {S[i - r], …, S[i], …, S[i + r]}, where r = ⌊radius⌋, start <= i < stop,
    // for each i, i + step, i + 2 * step, etc., and where S[j] is clamped between
    // S[start] (inclusive) and S[stop] (exclusive). If the given radius is not an
    // integer, S[i - r - 1] and S[i + r + 1] are added to the sum, each weighted
    // according to r - ⌊radius⌋.
    function blurf(radius) {
      const radius0 = Math.floor(radius);
      if (radius0 === radius) return bluri(radius);
      const t = radius - radius0;
      const w = 2 * radius + 1;
      return (T, S, start, stop, step) => { // stop must be aligned!
        if (!((stop -= step) >= start)) return; // inclusive stop
        let sum = radius0 * S[start];
        const s0 = step * radius0;
        const s1 = s0 + step;
        for (let i = start, j = start + s0; i < j; i += step) {
          sum += S[Math.min(stop, i)];
        }
        for (let i = start, j = stop; i <= j; i += step) {
          sum += S[Math.min(stop, i + s0)];
          T[i] = (sum + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
          sum -= S[Math.max(start, i - s0)];
        }
      };
    }

    // Like blurf, but optimized for integer radius.
    function bluri(radius) {
      const w = 2 * radius + 1;
      return (T, S, start, stop, step) => { // stop must be aligned!
        if (!((stop -= step) >= start)) return; // inclusive stop
        let sum = radius * S[start];
        const s = step * radius;
        for (let i = start, j = start + s; i < j; i += step) {
          sum += S[Math.min(stop, i)];
        }
        for (let i = start, j = stop; i <= j; i += step) {
          sum += S[Math.min(stop, i + s)];
          T[i] = sum / w;
          sum -= S[Math.max(start, i - s)];
        }
      };
    }

    function count$1(values, valueof) {
      let count = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count;
          }
        }
      }
      return count;
    }

    function length$3(array) {
      return array.length | 0;
    }

    function empty$2(length) {
      return !(length > 0);
    }

    function arrayify(values) {
      return typeof values !== "object" || "length" in values ? values : Array.from(values);
    }

    function reducer(reduce) {
      return values => reduce(...values);
    }

    function cross$2(...values) {
      const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
      values = values.map(arrayify);
      const lengths = values.map(length$3);
      const j = values.length - 1;
      const index = new Array(j + 1).fill(0);
      const product = [];
      if (j < 0 || lengths.some(empty$2)) return product;
      while (true) {
        product.push(index.map((j, i) => values[i][j]));
        let i = j;
        while (++index[i] === lengths[i]) {
          if (i === 0) return reduce ? product.map(reduce) : product;
          index[i--] = 0;
        }
      }
    }

    function cumsum(values, valueof) {
      var sum = 0, index = 0;
      return Float64Array.from(values, valueof === undefined
        ? v => (sum += +v || 0)
        : v => (sum += +valueof(v, index++, values) || 0));
    }

    function variance(values, valueof) {
      let count = 0;
      let delta;
      let mean = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      }
      if (count > 1) return sum / (count - 1);
    }

    function deviation(values, valueof) {
      const v = variance(values, valueof);
      return v ? Math.sqrt(v) : v;
    }

    function extent$1(values, valueof) {
      let min;
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
      return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo) p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo) break;
          }
          if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi) hi = x;
          }
        }
        return hi;
      }
    }

    function fsum(values, valueof) {
      const adder = new Adder();
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            adder.add(value);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            adder.add(value);
          }
        }
      }
      return +adder;
    }

    function fcumsum(values, valueof) {
      const adder = new Adder();
      let index = -1;
      return Float64Array.from(values, valueof === undefined
          ? v => adder.add(+v || 0)
          : v => adder.add(+valueof(v, ++index, values) || 0)
      );
    }

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    class InternSet extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (values != null) for (const value of values) this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(key);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function identity$9(x) {
      return x;
    }

    function group(values, ...keys) {
      return nest(values, identity$9, identity$9, keys);
    }

    function groups(values, ...keys) {
      return nest(values, Array.from, identity$9, keys);
    }

    function flatten$1(groups, keys) {
      for (let i = 1, n = keys.length; i < n; ++i) {
        groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
      }
      return groups;
    }

    function flatGroup(values, ...keys) {
      return flatten$1(groups(values, ...keys), keys);
    }

    function flatRollup(values, reduce, ...keys) {
      return flatten$1(rollups(values, reduce, ...keys), keys);
    }

    function rollup(values, reduce, ...keys) {
      return nest(values, identity$9, reduce, keys);
    }

    function rollups(values, reduce, ...keys) {
      return nest(values, Array.from, reduce, keys);
    }

    function index$4(values, ...keys) {
      return nest(values, identity$9, unique, keys);
    }

    function indexes(values, ...keys) {
      return nest(values, Array.from, unique, keys);
    }

    function unique(values) {
      if (values.length !== 1) throw new Error("duplicate key");
      return values[0];
    }

    function nest(values, map, reduce, keys) {
      return (function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const groups = new InternMap();
        const keyof = keys[i++];
        let index = -1;
        for (const value of values) {
          const key = keyof(value, ++index, values);
          const group = groups.get(key);
          if (group) group.push(value);
          else groups.set(key, [value]);
        }
        for (const [key, values] of groups) {
          groups.set(key, regroup(values, i));
        }
        return map(groups);
      })(values, 0);
    }

    function permute(source, keys) {
      return Array.from(keys, key => source[key]);
    }

    function sort(values, ...F) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      values = Array.from(values);
      let [f] = F;
      if ((f && f.length !== 2) || F.length > 1) {
        const index = Uint32Array.from(values, (d, i) => i);
        if (F.length > 1) {
          F = F.map(f => values.map(f));
          index.sort((i, j) => {
            for (const f of F) {
              const c = ascendingDefined(f[i], f[j]);
              if (c) return c;
            }
          });
        } else {
          f = values.map(f);
          index.sort((i, j) => ascendingDefined(f[i], f[j]));
        }
        return permute(values, index);
      }
      return values.sort(compareDefined(f));
    }

    function compareDefined(compare = ascending$3) {
      if (compare === ascending$3) return ascendingDefined;
      if (typeof compare !== "function") throw new TypeError("compare is not a function");
      return (a, b) => {
        const x = compare(a, b);
        if (x || x === 0) return x;
        return (compare(b, b) === 0) - (compare(a, a) === 0);
      };
    }

    function ascendingDefined(a, b) {
      return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
    }

    function groupSort(values, reduce, key) {
      return (reduce.length !== 2
        ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending$3(av, bv) || ascending$3(ak, bk)))
        : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending$3(ak, bk))))
        .map(([key]) => key);
    }

    var array$5 = Array.prototype;

    var slice$4 = array$5.slice;

    function constant$b(x) {
      return () => x;
    }

    const e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function tickSpec(start, stop, count) {
      const step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log10(step)),
          error = step / Math.pow(10, power),
          factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
      let i1, i2, inc;
      if (power < 0) {
        inc = Math.pow(10, -power) / factor;
        i1 = Math.round(start * inc);
        i2 = Math.round(stop * inc);
        if (i1 / inc < start) ++i1;
        if (i2 / inc > stop) --i2;
        inc = -inc;
      } else {
        inc = Math.pow(10, power) * factor;
        i1 = Math.round(start / inc);
        i2 = Math.round(stop / inc);
        if (i1 * inc < start) ++i1;
        if (i2 * inc > stop) --i2;
      }
      if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
      return [i1, i2, inc];
    }

    function ticks(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      if (!(count > 0)) return [];
      if (start === stop) return [start];
      const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
      if (!(i2 >= i1)) return [];
      const n = i2 - i1 + 1, ticks = new Array(n);
      if (reverse) {
        if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
        else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
      } else {
        if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
        else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
      }
      return ticks;
    }

    function tickIncrement(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      return tickSpec(start, stop, count)[2];
    }

    function tickStep(start, stop, count) {
      stop = +stop, start = +start, count = +count;
      const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
      return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
    }

    function nice$1(start, stop, count) {
      let prestep;
      while (true) {
        const step = tickIncrement(start, stop, count);
        if (step === prestep || step === 0 || !isFinite(step)) {
          return [start, stop];
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }

    function thresholdSturges(values) {
      return Math.max(1, Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1);
    }

    function bin() {
      var value = identity$9,
          domain = extent$1,
          threshold = thresholdSturges;

      function histogram(data) {
        if (!Array.isArray(data)) data = Array.from(data);

        var i,
            n = data.length,
            x,
            step,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds, and nice the
        // default domain accordingly.
        if (!Array.isArray(tz)) {
          const max = x1, tn = +tz;
          if (domain === extent$1) [x0, x1] = nice$1(x0, x1, tn);
          tz = ticks(x0, x1, tn);

          // If the domain is aligned with the first tick (which it will by
          // default), then we can use quantization rather than bisection to bin
          // values, which is substantially faster.
          if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);

          // If the last threshold is coincident with the domain’s upper bound, the
          // last bin will be zero-width. If the default domain is used, and this
          // last threshold is coincident with the maximum input value, we can
          // extend the niced upper bound by one tick to ensure uniform bin widths;
          // otherwise, we simply remove the last threshold. Note that we don’t
          // coerce values or the domain to numbers, and thus must be careful to
          // compare order (>=) rather than strict equality (===)!
          if (tz[tz.length - 1] >= x1) {
            if (max >= x1 && domain === extent$1) {
              const step = tickIncrement(x0, x1, tn);
              if (isFinite(step)) {
                if (step > 0) {
                  x1 = (Math.floor(x1 / step) + 1) * step;
                } else if (step < 0) {
                  x1 = (Math.ceil(x1 * -step) + 1) / -step;
                }
              }
            } else {
              tz.pop();
            }
          }
        }

        // Remove any thresholds outside the domain.
        // Be careful not to mutate an array owned by the user!
        var m = tz.length, a = 0, b = m;
        while (tz[a] <= x0) ++a;
        while (tz[b - 1] > x1) --b;
        if (a || b < m) tz = tz.slice(a, b), m = b - a;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        if (isFinite(step)) {
          if (step > 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);
              }
            }
          } else if (step < 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                const j = Math.floor((x0 - x) * step);
                bins[Math.min(m, j + (tz[j] <= x))].push(data[i]); // handle off-by-one due to rounding
              }
            }
          }
        } else {
          for (i = 0; i < n; ++i) {
            if ((x = values[i]) != null && x0 <= x && x <= x1) {
              bins[bisect(tz, x, 0, m)].push(data[i]);
            }
          }
        }

        return bins;
      }

      histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(_), histogram) : value;
      };

      histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant$b([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : constant$b(Array.isArray(_) ? slice$4.call(_) : _), histogram) : threshold;
      };

      return histogram;
    }

    function max$4(values, valueof) {
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      }
      return max;
    }

    function maxIndex(values, valueof) {
      let max;
      let maxIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      }
      return maxIndex;
    }

    function min$3(values, valueof) {
      let min;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      }
      return min;
    }

    function minIndex(values, valueof) {
      let min;
      let minIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      }
      return minIndex;
    }

    // Based on https://github.com/mourner/quickselect
    // ISC license, Copyright 2018 Vladimir Agafonkin.
    function quickselect(array, k, left = 0, right = Infinity, compare) {
      k = Math.floor(k);
      left = Math.floor(Math.max(0, left));
      right = Math.floor(Math.min(array.length - 1, right));

      if (!(left <= k && k <= right)) return array;

      compare = compare === undefined ? ascendingDefined : compareDefined(compare);

      while (right > left) {
        if (right - left > 600) {
          const n = right - left + 1;
          const m = k - left + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
          const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
          quickselect(array, k, newLeft, newRight, compare);
        }

        const t = array[k];
        let i = left;
        let j = right;

        swap$1(array, left, k);
        if (compare(array[right], t) > 0) swap$1(array, left, right);

        while (i < j) {
          swap$1(array, i, j), ++i, --j;
          while (compare(array[i], t) < 0) ++i;
          while (compare(array[j], t) > 0) --j;
        }

        if (compare(array[left], t) === 0) swap$1(array, left, j);
        else ++j, swap$1(array, j, right);

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
      }

      return array;
    }

    function swap$1(array, i, j) {
      const t = array[i];
      array[i] = array[j];
      array[j] = t;
    }

    function greatest(values, compare = ascending$3) {
      let max;
      let defined = false;
      if (compare.length === 1) {
        let maxValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, maxValue) > 0
              : ascending$3(value, value) === 0) {
            max = element;
            maxValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, max) > 0
              : compare(value, value) === 0) {
            max = value;
            defined = true;
          }
        }
      }
      return max;
    }

    function quantile$1(values, p, valueof) {
      values = Float64Array.from(numbers(values, valueof));
      if (!(n = values.length) || isNaN(p = +p)) return;
      if (p <= 0 || n < 2) return min$3(values);
      if (p >= 1) return max$4(values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = max$4(quickselect(values, i0).subarray(0, i0 + 1)),
          value1 = min$3(values.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileSorted(values, p, valueof = number$3) {
      if (!(n = values.length) || isNaN(p = +p)) return;
      if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileIndex(values, p, valueof = number$3) {
      if (isNaN(p = +p)) return;
      numbers = Float64Array.from(values, (_, i) => number$3(valueof(values[i], i, values)));
      if (p <= 0) return minIndex(numbers);
      if (p >= 1) return maxIndex(numbers);
      var numbers,
          index = Uint32Array.from(values, (_, i) => i),
          j = numbers.length - 1,
          i = Math.floor(j * p);
      quickselect(index, i, 0, j, (i, j) => ascendingDefined(numbers[i], numbers[j]));
      i = greatest(index.subarray(0, i + 1), (i) => numbers[i]);
      return i >= 0 ? i : -1;
    }

    function thresholdFreedmanDiaconis(values, min, max) {
      const c = count$1(values), d = quantile$1(values, 0.75) - quantile$1(values, 0.25);
      return c && d ? Math.ceil((max - min) / (2 * d * Math.pow(c, -1 / 3))) : 1;
    }

    function thresholdScott(values, min, max) {
      const c = count$1(values), d = deviation(values);
      return c && d ? Math.ceil((max - min) * Math.cbrt(c) / (3.49 * d)) : 1;
    }

    function mean(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    function median(values, valueof) {
      return quantile$1(values, 0.5, valueof);
    }

    function medianIndex(values, valueof) {
      return quantileIndex(values, 0.5, valueof);
    }

    function* flatten(arrays) {
      for (const array of arrays) {
        yield* array;
      }
    }

    function merge(arrays) {
      return Array.from(flatten(arrays));
    }

    function mode(values, valueof) {
      const counts = new InternMap();
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      }
      let modeValue;
      let modeCount = 0;
      for (const [value, count] of counts) {
        if (count > modeCount) {
          modeCount = count;
          modeValue = value;
        }
      }
      return modeValue;
    }

    function pairs(values, pairof = pair) {
      const pairs = [];
      let previous;
      let first = false;
      for (const value of values) {
        if (first) pairs.push(pairof(previous, value));
        previous = value;
        first = true;
      }
      return pairs;
    }

    function pair(a, b) {
      return [a, b];
    }

    function range$3(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    function rank(values, valueof = ascending$3) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      let V = Array.from(values);
      const R = new Float64Array(V.length);
      if (valueof.length !== 2) V = V.map(valueof), valueof = ascending$3;
      const compareIndex = (i, j) => valueof(V[i], V[j]);
      let k, r;
      values = Uint32Array.from(V, (_, i) => i);
      // Risky chaining due to Safari 14 https://github.com/d3/d3-array/issues/123
      values.sort(valueof === ascending$3 ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));
      values.forEach((j, i) => {
          const c = compareIndex(j, k === undefined ? j : k);
          if (c >= 0) {
            if (k === undefined || c > 0) k = j, r = i;
            R[j] = r;
          } else {
            R[j] = NaN;
          }
        });
      return R;
    }

    function least(values, compare = ascending$3) {
      let min;
      let defined = false;
      if (compare.length === 1) {
        let minValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, minValue) < 0
              : ascending$3(value, value) === 0) {
            min = element;
            minValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, min) < 0
              : compare(value, value) === 0) {
            min = value;
            defined = true;
          }
        }
      }
      return min;
    }

    function leastIndex(values, compare = ascending$3) {
      if (compare.length === 1) return minIndex(values, compare);
      let minValue;
      let min = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (min < 0
            ? compare(value, value) === 0
            : compare(value, minValue) < 0) {
          minValue = value;
          min = index;
        }
      }
      return min;
    }

    function greatestIndex(values, compare = ascending$3) {
      if (compare.length === 1) return maxIndex(values, compare);
      let maxValue;
      let max = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (max < 0
            ? compare(value, value) === 0
            : compare(value, maxValue) > 0) {
          maxValue = value;
          max = index;
        }
      }
      return max;
    }

    function scan(values, compare) {
      const index = leastIndex(values, compare);
      return index < 0 ? undefined : index;
    }

    var shuffle$2 = shuffler(Math.random);

    function shuffler(random) {
      return function shuffle(array, i0 = 0, i1 = array.length) {
        let m = i1 - (i0 = +i0);
        while (m) {
          const i = random() * m-- | 0, t = array[m + i0];
          array[m + i0] = array[i + i0];
          array[i + i0] = t;
        }
        return array;
      };
    }

    function sum$2(values, valueof) {
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            sum += value;
          }
        }
      }
      return sum;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min$3(matrix, length$2), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length$2(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    function every(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (!test(value, ++index, values)) {
          return false;
        }
      }
      return true;
    }

    function some(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          return true;
        }
      }
      return false;
    }

    function filter$1(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      const array = [];
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          array.push(value);
        }
      }
      return array;
    }

    function map$2(values, mapper) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
      return Array.from(values, (value, index) => mapper(value, index, values));
    }

    function reduce(values, reducer, value) {
      if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
      const iterator = values[Symbol.iterator]();
      let done, next, index = -1;
      if (arguments.length < 3) {
        ({done, value} = iterator.next());
        if (done) return;
        ++index;
      }
      while (({done, value: next} = iterator.next()), !done) {
        value = reducer(value, next, ++index, values);
      }
      return value;
    }

    function reverse$1(values) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      return Array.from(values).reverse();
    }

    function difference(values, ...others) {
      values = new InternSet(values);
      for (const other of others) {
        for (const value of other) {
          values.delete(value);
        }
      }
      return values;
    }

    function disjoint(values, other) {
      const iterator = other[Symbol.iterator](), set = new InternSet();
      for (const v of values) {
        if (set.has(v)) return false;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) break;
          if (Object.is(v, value)) return false;
          set.add(value);
        }
      }
      return true;
    }

    function intersection(values, ...others) {
      values = new InternSet(values);
      others = others.map(set$2);
      out: for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      }
      return values;
    }

    function set$2(values) {
      return values instanceof InternSet ? values : new InternSet(values);
    }

    function superset(values, other) {
      const iterator = values[Symbol.iterator](), set = new Set();
      for (const o of other) {
        const io = intern(o);
        if (set.has(io)) continue;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) return false;
          const ivalue = intern(value);
          set.add(ivalue);
          if (Object.is(io, ivalue)) break;
        }
      }
      return true;
    }

    function intern(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function subset(values, other) {
      return superset(other, values);
    }

    function union(...others) {
      const set = new InternSet();
      for (const other of others) {
        for (const o of other) {
          set.add(o);
        }
      }
      return set;
    }

    function identity$8(x) {
      return x;
    }

    var top = 1,
        right = 2,
        bottom = 3,
        left = 4,
        epsilon$6 = 1e-6;

    function translateX(x) {
      return "translate(" + x + ",0)";
    }

    function translateY(y) {
      return "translate(0," + y + ")";
    }

    function number$2(scale) {
      return d => +scale(d);
    }

    function center$1(scale, offset) {
      offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
      if (scale.round()) offset = Math.round(offset);
      return d => +scale(d) + offset;
    }

    function entering() {
      return !this.__axis;
    }

    function axis(orient, scale) {
      var tickArguments = [],
          tickValues = null,
          tickFormat = null,
          tickSizeInner = 6,
          tickSizeOuter = 6,
          tickPadding = 3,
          offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
          k = orient === top || orient === left ? -1 : 1,
          x = orient === left || orient === right ? "x" : "y",
          transform = orient === top || orient === bottom ? translateX : translateY;

      function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
            format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8) : tickFormat,
            spacing = Math.max(tickSizeInner, 0) + tickPadding,
            range = scale.range(),
            range0 = +range[0] + offset,
            range1 = +range[range.length - 1] + offset,
            position = (scale.bandwidth ? center$1 : number$2)(scale.copy(), offset),
            selection = context.selection ? context.selection() : context,
            path = selection.selectAll(".domain").data([null]),
            tick = selection.selectAll(".tick").data(values, scale).order(),
            tickExit = tick.exit(),
            tickEnter = tick.enter().append("g").attr("class", "tick"),
            line = tick.select("line"),
            text = tick.select("text");

        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));

        tick = tick.merge(tickEnter);

        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));

        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

        if (context !== selection) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text = text.transition(context);

          tickExit = tickExit.transition(context)
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

          tickEnter
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
        }

        tickExit.remove();

        path
            .attr("d", orient === left || orient === right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

        tick
            .attr("opacity", 1)
            .attr("transform", function(d) { return transform(position(d) + offset); });

        line
            .attr(x + "2", k * tickSizeInner);

        text
            .attr(x, k * spacing)
            .text(format);

        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

        selection
            .each(function() { this.__axis = position; });
      }

      axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
      };

      axis.ticks = function() {
        return tickArguments = Array.from(arguments), axis;
      };

      axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
      };

      axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
      };

      axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
      };

      axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
      };

      axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
      };

      axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
      };

      axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
      };

      axis.offset = function(_) {
        return arguments.length ? (offset = +_, axis) : offset;
      };

      return axis;
    }

    function axisTop(scale) {
      return axis(top, scale);
    }

    function axisRight(scale) {
      return axis(right, scale);
    }

    function axisBottom(scale) {
      return axis(bottom, scale);
    }

    function axisLeft(scale) {
      return axis(left, scale);
    }

    var noop$3 = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$3, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none$2() {}

    function selector(selector) {
      return selector == null ? none$2 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we don’t ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array$4(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty$1() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function() {
        return array$4(select.apply(this, arguments));
      };
    }

    function selection_selectAll(select) {
      if (typeof select === "function") select = arrayAll(select);
      else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function childMatcher(selector) {
      return function(node) {
        return node.matches(selector);
      };
    }

    var find$2 = Array.prototype.find;

    function childFind(match) {
      return function() {
        return find$2.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild(match) {
      return this.select(match == null ? childFirst
          : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }

    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children
          : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$a(x) {
      return function() {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map,
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
          exit[i] = node;
        }
      }
    }

    function datum(node) {
      return node.__data__;
    }

    function selection_data(value, key) {
      if (!arguments.length) return Array.from(this, datum);

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$a(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isn’t worried about “live” collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // don’t; we’d rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data
        ? data // Array, TypedArray, NodeList, array-like
        : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$2;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending$2(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      return Array.from(this);
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove$1() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove$1);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root$1 = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root$1);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root$1);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    var nextId = 0;

    function local$1() {
      return new Local;
    }

    function Local() {
      this._ = "@" + (++nextId).toString(36);
    }

    Local.prototype = local$1.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };

    function sourceEvent(event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    function pointers(events, node) {
      if (events.target) { // i.e., instanceof Event, not TouchList or iterable
        events = sourceEvent(events);
        if (node === undefined) node = events.currentTarget;
        events = events.touches || [events];
      }
      return Array.from(events, event => pointer(event, node));
    }

    function selectAll(selector) {
      return typeof selector === "string"
          ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection$1([array$4(selector)], root$1);
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassive = {passive: false};
    const nonpassivecapture = {capture: true, passive: false};

    function nopropagation$2(event) {
      event.stopImmediatePropagation();
    }

    function noevent$2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$2, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$2, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$2, nonpassivecapture);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var constant$9 = x => () => x;

    function DragEvent(type, {
      sourceEvent,
      subject,
      target,
      identifier,
      active,
      x, y, dx, dy,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        subject: {value: subject, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        identifier: {value: identifier, enumerable: true, configurable: true},
        active: {value: active, enumerable: true, configurable: true},
        x: {value: x, enumerable: true, configurable: true},
        y: {value: y, enumerable: true, configurable: true},
        dx: {value: dx, enumerable: true, configurable: true},
        dy: {value: dy, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(event, d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable$2() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter$2,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable$2,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved, nonpassive)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned(event, d) {
        if (touchending || !filter.call(this, event, d)) return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture) return;
        select(event.view)
          .on("mousemove.drag", mousemoved, nonpassivecapture)
          .on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation$2(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }

      function mousemoved(event) {
        noevent$2(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }

      function mouseupped(event) {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$2(event);
        gestures.mouse("end", event);
      }

      function touchstarted(event, d) {
        if (!filter.call(this, event, d)) return;
        var touches = event.changedTouches,
            c = container.call(this, event, d),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
            nopropagation$2(event);
            gesture("start", event, touches[i]);
          }
        }
      }

      function touchmoved(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent$2(event);
            gesture("drag", event, touches[i]);
          }
        }
      }

      function touchended(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation$2(event);
            gesture("end", event, touches[i]);
          }
        }
      }

      function beforestart(that, container, event, d, identifier, touch) {
        var dispatch = listeners.copy(),
            p = pointer(touch || event, container), dx, dy,
            s;

        if ((s = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag,
            identifier,
            active,
            x: p[0],
            y: p[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d)) == null) return;

        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;

        return function gesture(type, event, touch) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[identifier] = gesture, n = active++; break;
            case "end": delete gestures[identifier], --active; // falls through
            case "drag": p = pointer(touch || event, container), n = active; break;
          }
          dispatch.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event,
              subject: s,
              target: drag,
              identifier,
              active: n,
              x: p[0] + dx,
              y: p[1] + dy,
              dx: p[0] - p0[0],
              dy: p[1] - p0[1],
              dispatch
            }),
            d
          );
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$9(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$9(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$9(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$9(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color$1() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
        reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
        reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
        reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
        reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
        reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color$1, color$1, {
      copy(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHex8() {
      return this.rgb().formatHex8();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color$1(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color$1)) o = color$1(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color$1, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }

    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }

    function rgb_formatRgb() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
    }

    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }

    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }

    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color$1)) o = color$1(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl$2(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl$2, extend(Color$1, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
      }
    }));

    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }

    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    const radians$1 = Math.PI / 180;
    const degrees$2 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    const K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0$1 = 4 / 29,
        t1$1 = 6 / 29,
        t2 = 3 * t1$1 * t1$1,
        t3 = t1$1 * t1$1 * t1$1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function gray(l, opacity) {
      return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
    }

    function lab$1(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab$1, extend(Color$1, {
      brighter(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
    }

    function lab2xyz(t) {
      return t > t1$1 ? t * t * t : t2 * (t - t0$1);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees$2;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function lch(l, c, h, opacity) {
      return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function hcl$2(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians$1;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl$2, extend(Color$1, {
      brighter(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B$1 = +1.78277,
        C = -0.29227,
        D$1 = -0.90649,
        E = +1.97294,
        ED = E * D$1,
        EB = E * B$1,
        BC_DA = B$1 * C - D$1 * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D$1,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * degrees$2 - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix$3(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix$3, extend(Color$1, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$1,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B$1 * sinh)),
          255 * (l + a * (C * cosh + D$1 * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function basis$1(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$2(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function basisClosed$1(values) {
      var n = values.length;
      return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
            v0 = values[(i + n - 1) % n],
            v1 = values[i % n],
            v2 = values[(i + 1) % n],
            v3 = values[(i + 2) % n];
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    var constant$8 = x => () => x;

    function linear$3(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential$1(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue$1(a, b) {
      var d = b - a;
      return d ? linear$3(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$8(isNaN(a) ? b : a);
    }

    function gamma$1(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential$1(a, b, y) : constant$8(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$3(a, d) : constant$8(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma$1(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color;
        for (i = 0; i < n; ++i) {
          color = rgb(colors[i]);
          r[i] = color.r || 0;
          g[i] = color.g || 0;
          b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
          color.r = r(t);
          color.g = g(t);
          color.b = b(t);
          return color + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$2);
    var rgbBasisClosed = rgbSpline(basisClosed$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function array$3(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate$2(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object$1(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate$2(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate$2(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$8(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color$1(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color$1 ? interpolateRgb
          : b instanceof Date ? date$1
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1
          : interpolateNumber)(a, b);
    }

    function discrete(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    function hue(a, b) {
      var i = hue$1(+a, +b);
      return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
      };
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees$1 = 180 / Math.PI;

    var identity$7 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$7 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }

    function parseSvg(value) {
      if (value == null) return identity$7;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$7;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2$1 = 1e-12;

    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {

      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
            ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;

        // Special case for u0 ≅ u1.
        if (d2 < epsilon2$1) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        }

        // General case.
        else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s = t * S,
                coshr0 = cosh(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }

        i.duration = S * 1000 * rho / Math.SQRT2;

        return i;
      }

      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };

      return zoom;
    })(Math.SQRT2, 2, 4);

    function hsl(hue) {
      return function(start, end) {
        var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);

    function lab(start, end) {
      var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l),
          a = nogamma(start.a, end.a),
          b = nogamma(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    function hcl(hue) {
      return function(start, end) {
        var h = hue((start = hcl$2(start)).h, (end = hcl$2(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hcl$1 = hcl(hue$1);
    var hclLong = hcl(nogamma);

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix(start, end) {
          var h = hue((start = cubehelix$3(start)).h, (end = cubehelix$3(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix.gamma = cubehelixGamma;

        return cubehelix;
      })(1);
    }

    var cubehelix$2 = cubehelix$1(hue$1);
    var cubehelixLong = cubehelix$1(nogamma);

    function piecewise(interpolate, values) {
      if (values === undefined) values = interpolate, interpolate = interpolate$2;
      var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
      while (i < n) I[i] = interpolate(v, v = values[++i]);
      return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
      };
    }

    function quantize$1(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
      return samples;
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval$1 = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now$1() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now$1() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep$1();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep$1();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now$1(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep$1(time);
    }

    function sleep$1(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval$1) interval$1 = clearInterval(interval$1);
      } else {
        if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval(callback, delay, time) {
      var t = new Timer, total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      t._restart = t.restart;
      t.restart = function(callback, delay, time) {
        delay = +delay, time = time == null ? now$1() : +time;
        t._restart(function tick(elapsed) {
          elapsed += total;
          t._restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
      };
      t.restart(callback, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get(node, id).value[name];
      };
    }

    function interpolate$1(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color$1 ? interpolateRgb
          : (c = color$1(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error;
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying(value) {
      if (typeof value !== "function") throw new Error;
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    const linear$2 = t => +t;

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent$1);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent$1);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent$1);

    var pi$4 = Math.PI,
        halfPi$3 = pi$4 / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi$3);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi$3);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi$4 * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1$1 = 4 / 11,
        b2$1 = 6 / 11,
        b3$1 = 8 / 11,
        b4$1 = 3 / 4,
        b5$1 = 9 / 11,
        b6$1 = 10 / 11,
        b7$1 = 15 / 16,
        b8$1 = 21 / 22,
        b9$1 = 63 / 64,
        b0$1 = 1 / b1$1 / b1$1;

    function bounceIn(t) {
      return 1 - bounceOut$1(1 - t);
    }

    function bounceOut$1(t) {
      return (t = +t) < b1$1 ? b0$1 * t * t : t < b3$1 ? b0$1 * (t -= b2$1) * t + b4$1 : t < b6$1 ? b0$1 * (t -= b5$1) * t + b7$1 : b0$1 * (t -= b8$1) * t + b9$1;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut$1(1 - t) : bounceOut$1(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau$6 = 2 * Math.PI,
        amplitude$1 = 1,
        period$1 = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$6);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau$6); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude$1, period$1);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$6);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau$6); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude$1, period$1);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$6);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau$6); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude$1, period$1);

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now$1(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var root = [null];

    function active(node, name) {
      var schedules = node.__transition,
          schedule,
          i;

      if (schedules) {
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
            return new Transition([[node]], root, name, +i);
          }
        }
      }

      return null;
    }

    var constant$7 = x => () => x;

    function BrushEvent(type, {
      sourceEvent,
      target,
      selection,
      mode,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        selection: {value: selection, enumerable: true, configurable: true},
        mode: {value: mode, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function nopropagation$1(event) {
      event.stopImmediatePropagation();
    }

    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    var MODE_DRAG = {name: "drag"},
        MODE_SPACE = {name: "space"},
        MODE_HANDLE = {name: "handle"},
        MODE_CENTER = {name: "center"};

    const {abs: abs$3, max: max$3, min: min$2} = Math;

    function number1(e) {
      return [+e[0], +e[1]];
    }

    function number2(e) {
      return [number1(e[0]), number1(e[1])];
    }

    var X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
      output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
      output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
      input: function(xy) { return xy == null ? null : number2(xy); },
      output: function(xy) { return xy; }
    };

    var cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };

    var flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };

    var flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };

    var signsX = {
      overlay: +1,
      selection: +1,
      n: null,
      e: +1,
      s: null,
      w: -1,
      nw: -1,
      ne: +1,
      se: +1,
      sw: -1
    };

    var signsY = {
      overlay: +1,
      selection: +1,
      n: -1,
      e: null,
      s: +1,
      w: null,
      nw: -1,
      ne: -1,
      se: +1,
      sw: +1
    };

    function type(t) {
      return {type: t};
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent$1() {
      var svg = this.ownerSVGElement || this;
      if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
      }
      return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    function defaultTouchable$1() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    // Like d3.local, but with the name “__brush” rather than auto-generated.
    function local(node) {
      while (!node.__brush) if (!(node = node.parentNode)) return;
      return node.__brush;
    }

    function empty(extent) {
      return extent[0][0] === extent[1][0]
          || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
      var state = node.__brush;
      return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
      return brush$1(X);
    }

    function brushY() {
      return brush$1(Y);
    }

    function brush() {
      return brush$1(XY);
    }

    function brush$1(dim) {
      var extent = defaultExtent$1,
          filter = defaultFilter$1,
          touchable = defaultTouchable$1,
          keys = true,
          listeners = dispatch("start", "brush", "end"),
          handleSize = 6,
          touchending;

      function brush(group) {
        var overlay = group
            .property("__brush", initialize)
          .selectAll(".overlay")
          .data([type("overlay")]);

        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
          .merge(overlay)
            .each(function() {
              var extent = local(this).extent;
              select(this)
                  .attr("x", extent[0][0])
                  .attr("y", extent[0][1])
                  .attr("width", extent[1][0] - extent[0][0])
                  .attr("height", extent[1][1] - extent[0][1]);
            });

        group.selectAll(".selection")
          .data([type("selection")])
          .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");

        var handle = group.selectAll(".handle")
          .data(dim.handles, function(d) { return d.type; });

        handle.exit().remove();

        handle.enter().append("rect")
            .attr("class", function(d) { return "handle handle--" + d.type; })
            .attr("cursor", function(d) { return cursors[d.type]; });

        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
          .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      brush.move = function(group, selection, event) {
        if (group.tween) {
          group
              .on("start.brush", function(event) { emitter(this, arguments).beforestart().start(event); })
              .on("interrupt.brush end.brush", function(event) { emitter(this, arguments).end(event); })
              .tween("brush", function() {
                var that = this,
                    state = that.__brush,
                    emit = emitter(that, arguments),
                    selection0 = state.selection,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                    i = interpolate$2(selection0, selection1);

                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }

                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
        } else {
          group
              .each(function() {
                var that = this,
                    args = arguments,
                    state = that.__brush,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                    emit = emitter(that, args).beforestart();

                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start(event).brush(event).end(event);
              });
        }
      };

      brush.clear = function(group, event) {
        brush.move(group, null, event);
      };

      function redraw() {
        var group = select(this),
            selection = local(this).selection;

        if (selection) {
          group.selectAll(".selection")
              .style("display", null)
              .attr("x", selection[0][0])
              .attr("y", selection[0][1])
              .attr("width", selection[1][0] - selection[0][0])
              .attr("height", selection[1][1] - selection[0][1]);

          group.selectAll(".handle")
              .style("display", null)
              .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
              .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
              .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
              .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }

        else {
          group.selectAll(".selection,.handle")
              .style("display", "none")
              .attr("x", null)
              .attr("y", null)
              .attr("width", null)
              .attr("height", null);
        }
      }

      function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
      }

      function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
      }

      Emitter.prototype = {
        beforestart: function() {
          if (++this.active === 1) this.state.emitter = this, this.starting = true;
          return this;
        },
        start: function(event, mode) {
          if (this.starting) this.starting = false, this.emit("start", event, mode);
          else this.emit("brush", event);
          return this;
        },
        brush: function(event, mode) {
          this.emit("brush", event, mode);
          return this;
        },
        end: function(event, mode) {
          if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
          return this;
        },
        emit: function(type, event, mode) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new BrushEvent(type, {
              sourceEvent: event,
              target: brush,
              selection: dim.output(this.state.selection),
              mode,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function started(event) {
        if (touchending && !event.touches) return;
        if (!filter.apply(this, arguments)) return;

        var that = this,
            type = event.target.__data__.type,
            mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
            signX = dim === Y ? null : signsX[type],
            signY = dim === X ? null : signsY[type],
            state = local(that),
            extent = state.extent,
            selection = state.selection,
            W = extent[0][0], w0, w1,
            N = extent[0][1], n0, n1,
            E = extent[1][0], e0, e1,
            S = extent[1][1], s0, s1,
            dx = 0,
            dy = 0,
            moving,
            shifting = signX && signY && keys && event.shiftKey,
            lockX,
            lockY,
            points = Array.from(event.touches || [event], t => {
              const i = t.identifier;
              t = pointer(t, that);
              t.point0 = t.slice();
              t.identifier = i;
              return t;
            });

        interrupt(that);
        var emit = emitter(that, arguments, true).beforestart();

        if (type === "overlay") {
          if (selection) moving = true;
          const pts = [points[0], points[1] || points[0]];
          state.selection = selection = [[
              w0 = dim === Y ? W : min$2(pts[0][0], pts[1][0]),
              n0 = dim === X ? N : min$2(pts[0][1], pts[1][1])
            ], [
              e0 = dim === Y ? E : max$3(pts[0][0], pts[1][0]),
              s0 = dim === X ? S : max$3(pts[0][1], pts[1][1])
            ]];
          if (points.length > 1) move(event);
        } else {
          w0 = selection[0][0];
          n0 = selection[0][1];
          e0 = selection[1][0];
          s0 = selection[1][1];
        }

        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;

        var group = select(that)
            .attr("pointer-events", "none");

        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);

        if (event.touches) {
          emit.moved = moved;
          emit.ended = ended;
        } else {
          var view = select(event.view)
              .on("mousemove.brush", moved, true)
              .on("mouseup.brush", ended, true);
          if (keys) view
              .on("keydown.brush", keydowned, true)
              .on("keyup.brush", keyupped, true);

          dragDisable(event.view);
        }

        redraw.call(that);
        emit.start(event, mode.name);

        function moved(event) {
          for (const p of event.changedTouches || [event]) {
            for (const d of points)
              if (d.identifier === p.identifier) d.cur = pointer(p, that);
          }
          if (shifting && !lockX && !lockY && points.length === 1) {
            const point = points[0];
            if (abs$3(point.cur[0] - point[0]) > abs$3(point.cur[1] - point[1]))
              lockY = true;
            else
              lockX = true;
          }
          for (const point of points)
            if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];
          moving = true;
          noevent$1(event);
          move(event);
        }

        function move(event) {
          const point = points[0], point0 = point.point0;
          var t;

          dx = point[0] - point0[0];
          dy = point[1] - point0[1];

          switch (mode) {
            case MODE_SPACE:
            case MODE_DRAG: {
              if (signX) dx = max$3(W - w0, min$2(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = max$3(N - n0, min$2(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
            case MODE_HANDLE: {
              if (points[1]) {
                if (signX) w1 = max$3(W, min$2(E, points[0][0])), e1 = max$3(W, min$2(E, points[1][0])), signX = 1;
                if (signY) n1 = max$3(N, min$2(S, points[0][1])), s1 = max$3(N, min$2(S, points[1][1])), signY = 1;
              } else {
                if (signX < 0) dx = max$3(W - w0, min$2(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                else if (signX > 0) dx = max$3(W - e0, min$2(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                if (signY < 0) dy = max$3(N - n0, min$2(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                else if (signY > 0) dy = max$3(N - s0, min$2(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              }
              break;
            }
            case MODE_CENTER: {
              if (signX) w1 = max$3(W, min$2(E, w0 - dx * signX)), e1 = max$3(W, min$2(E, e0 + dx * signX));
              if (signY) n1 = max$3(N, min$2(S, n0 - dy * signY)), s1 = max$3(N, min$2(S, s0 + dy * signY));
              break;
            }
          }

          if (e1 < w1) {
            signX *= -1;
            t = w0, w0 = e0, e0 = t;
            t = w1, w1 = e1, e1 = t;
            if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
          }

          if (s1 < n1) {
            signY *= -1;
            t = n0, n0 = s0, s0 = t;
            t = n1, n1 = s1, s1 = t;
            if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
          }

          if (state.selection) selection = state.selection; // May be set by brush.move!
          if (lockX) w1 = selection[0][0], e1 = selection[1][0];
          if (lockY) n1 = selection[0][1], s1 = selection[1][1];

          if (selection[0][0] !== w1
              || selection[0][1] !== n1
              || selection[1][0] !== e1
              || selection[1][1] !== s1) {
            state.selection = [[w1, n1], [e1, s1]];
            redraw.call(that);
            emit.brush(event, mode.name);
          }
        }

        function ended(event) {
          nopropagation$1(event);
          if (event.touches) {
            if (event.touches.length) return;
            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
          } else {
            yesdrag(event.view, moving);
            view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
          }
          group.attr("pointer-events", "all");
          overlay.attr("cursor", cursors.overlay);
          if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
          if (empty(selection)) state.selection = null, redraw.call(that);
          emit.end(event, mode.name);
        }

        function keydowned(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              shifting = signX && signY;
              break;
            }
            case 18: { // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move(event);
              }
              break;
            }
            case 32: { // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }

        function keyupped(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move(event);
              }
              break;
            }
            case 18: { // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move(event);
              }
              break;
            }
            case 32: { // SPACE
              if (mode === MODE_SPACE) {
                if (event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }
      }

      function touchmoved(event) {
        emitter(this, arguments).moved(event);
      }

      function touchended(event) {
        emitter(this, arguments).ended(event);
      }

      function initialize() {
        var state = this.__brush || {selection: null};
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
      }

      brush.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$7(number2(_)), brush) : extent;
      };

      brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$7(!!_), brush) : filter;
      };

      brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$7(!!_), brush) : touchable;
      };

      brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
      };

      brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
      };

      brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      return brush;
    }

    var abs$2 = Math.abs;
    var cos$3 = Math.cos;
    var sin$3 = Math.sin;
    var pi$3 = Math.PI;
    var halfPi$2 = pi$3 / 2;
    var tau$5 = pi$3 * 2;
    var max$2 = Math.max;
    var epsilon$5 = 1e-12;

    function range$2(i, j) {
      return Array.from({length: j - i}, (_, k) => i + k);
    }

    function compareValue(compare) {
      return function(a, b) {
        return compare(
          a.source.value + a.target.value,
          b.source.value + b.target.value
        );
      };
    }

    function chord() {
      return chord$1(false, false);
    }

    function chordTranspose() {
      return chord$1(false, true);
    }

    function chordDirected() {
      return chord$1(true, false);
    }

    function chord$1(directed, transpose) {
      var padAngle = 0,
          sortGroups = null,
          sortSubgroups = null,
          sortChords = null;

      function chord(matrix) {
        var n = matrix.length,
            groupSums = new Array(n),
            groupIndex = range$2(0, n),
            chords = new Array(n * n),
            groups = new Array(n),
            k = 0, dx;

        matrix = Float64Array.from({length: n * n}, transpose
            ? (_, i) => matrix[i % n][i / n | 0]
            : (_, i) => matrix[i / n | 0][i % n]);

        // Compute the scaling factor from value to angle in [0, 2pi].
        for (let i = 0; i < n; ++i) {
          let x = 0;
          for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
          k += groupSums[i] = x;
        }
        k = max$2(0, tau$5 - padAngle * n) / k;
        dx = k ? padAngle : tau$5 / n;

        // Compute the angles for each group and constituent chord.
        {
          let x = 0;
          if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
          for (const i of groupIndex) {
            const x0 = x;
            if (directed) {
              const subgroupIndex = range$2(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
              for (const j of subgroupIndex) {
                if (j < 0) {
                  const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
                } else {
                  const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            } else {
              const subgroupIndex = range$2(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
              for (const j of subgroupIndex) {
                let chord;
                if (i < j) {
                  chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                } else {
                  chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                  if (i === j) chord.source = chord.target;
                }
                if (chord.source && chord.target && chord.source.value < chord.target.value) {
                  const source = chord.source;
                  chord.source = chord.target;
                  chord.target = source;
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            }
            x += dx;
          }
        }

        // Remove empty chords.
        chords = Object.values(chords);
        chords.groups = groups;
        return sortChords ? chords.sort(sortChords) : chords;
      }

      chord.padAngle = function(_) {
        return arguments.length ? (padAngle = max$2(0, _), chord) : padAngle;
      };

      chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
      };

      chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
      };

      chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
      };

      return chord;
    }

    const pi$2 = Math.PI,
        tau$4 = 2 * pi$2,
        epsilon$4 = 1e-6,
        tauEpsilon = tau$4 - epsilon$4;

    function append$1(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }

    function appendRound$1(digits) {
      let d = Math.floor(digits);
      if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
      if (d > 15) return append$1;
      const k = 10 ** d;
      return function(strings) {
        this._ += strings[0];
        for (let i = 1, n = strings.length; i < n; ++i) {
          this._ += Math.round(arguments[i] * k) / k + strings[i];
        }
      };
    }

    let Path$1 = class Path {
      constructor(digits) {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
        this._append = digits == null ? append$1 : appendRound$1(digits);
      }
      moveTo(x, y) {
        this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x, y) {
        this._append`L${this._x1 = +x},${this._y1 = +y}`;
      }
      quadraticCurveTo(x1, y1, x, y) {
        this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
      }
      bezierCurveTo(x1, y1, x2, y2, x, y) {
        this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
      }
      arcTo(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

        // Is the radius negative? Error.
        if (r < 0) throw new Error(`negative radius: ${r}`);

        let x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._append`M${this._x1 = x1},${this._y1 = y1}`;
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$4));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$4) || !r) {
          this._append`L${this._x1 = x1},${this._y1 = y1}`;
        }

        // Otherwise, draw an arc!
        else {
          let x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$4) {
            this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
          }

          this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
        }
      }
      arc(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;

        // Is the radius negative? Error.
        if (r < 0) throw new Error(`negative radius: ${r}`);

        let dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._append`M${x0},${y0}`;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$4 || Math.abs(this._y1 - y0) > epsilon$4) {
          this._append`L${x0},${y0}`;
        }

        // Is this arc empty? We’re done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$4 + tau$4;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$4) {
          this._append`A${r},${r},0,${+(da >= pi$2)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
        }
      }
      rect(x, y, w, h) {
        this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
      }
      toString() {
        return this._;
      }
    };

    function path() {
      return new Path$1;
    }

    // Allow instanceof d3.path
    path.prototype = Path$1.prototype;

    function pathRound(digits = 3) {
      return new Path$1(+digits);
    }

    var slice$3 = Array.prototype.slice;

    function constant$6(x) {
      return function() {
        return x;
      };
    }

    function defaultSource$1(d) {
      return d.source;
    }

    function defaultTarget(d) {
      return d.target;
    }

    function defaultRadius$1(d) {
      return d.radius;
    }

    function defaultStartAngle(d) {
      return d.startAngle;
    }

    function defaultEndAngle(d) {
      return d.endAngle;
    }

    function defaultPadAngle() {
      return 0;
    }

    function defaultArrowheadRadius() {
      return 10;
    }

    function ribbon(headRadius) {
      var source = defaultSource$1,
          target = defaultTarget,
          sourceRadius = defaultRadius$1,
          targetRadius = defaultRadius$1,
          startAngle = defaultStartAngle,
          endAngle = defaultEndAngle,
          padAngle = defaultPadAngle,
          context = null;

      function ribbon() {
        var buffer,
            s = source.apply(this, arguments),
            t = target.apply(this, arguments),
            ap = padAngle.apply(this, arguments) / 2,
            argv = slice$3.call(arguments),
            sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
            sa0 = startAngle.apply(this, argv) - halfPi$2,
            sa1 = endAngle.apply(this, argv) - halfPi$2,
            tr = +targetRadius.apply(this, (argv[0] = t, argv)),
            ta0 = startAngle.apply(this, argv) - halfPi$2,
            ta1 = endAngle.apply(this, argv) - halfPi$2;

        if (!context) context = buffer = path();

        if (ap > epsilon$5) {
          if (abs$2(sa1 - sa0) > ap * 2 + epsilon$5) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
          else sa0 = sa1 = (sa0 + sa1) / 2;
          if (abs$2(ta1 - ta0) > ap * 2 + epsilon$5) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
          else ta0 = ta1 = (ta0 + ta1) / 2;
        }

        context.moveTo(sr * cos$3(sa0), sr * sin$3(sa0));
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) {
          if (headRadius) {
            var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
            context.quadraticCurveTo(0, 0, tr2 * cos$3(ta0), tr2 * sin$3(ta0));
            context.lineTo(tr * cos$3(ta2), tr * sin$3(ta2));
            context.lineTo(tr2 * cos$3(ta1), tr2 * sin$3(ta1));
          } else {
            context.quadraticCurveTo(0, 0, tr * cos$3(ta0), tr * sin$3(ta0));
            context.arc(0, 0, tr, ta0, ta1);
          }
        }
        context.quadraticCurveTo(0, 0, sr * cos$3(sa0), sr * sin$3(sa0));
        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      if (headRadius) ribbon.headRadius = function(_) {
        return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : headRadius;
      };

      ribbon.radius = function(_) {
        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.sourceRadius = function(_) {
        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.targetRadius = function(_) {
        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : targetRadius;
      };

      ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : startAngle;
      };

      ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : endAngle;
      };

      ribbon.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : padAngle;
      };

      ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
      };

      ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
      };

      ribbon.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
      };

      return ribbon;
    }

    function ribbon$1() {
      return ribbon();
    }

    function ribbonArrow() {
      return ribbon(defaultArrowheadRadius);
    }

    var array$2 = Array.prototype;

    var slice$2 = array$2.slice;

    function ascending$1(a, b) {
      return a - b;
    }

    function area$3(ring) {
      var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area;
    }

    var constant$5 = x => () => x;

    function contains$3(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) if (c = ringContains(ring, hole[i])) return c;
      return 0;
    }

    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
      }
      return contains;
    }

    function segmentContains(a, b, c) {
      var i; return collinear$1(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
    }

    function collinear$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
    }

    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }

    function noop$2() {}

    var cases = [
      [],
      [[[1.0, 1.5], [0.5, 1.0]]],
      [[[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [0.5, 1.0]]],
      [[[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 0.5], [1.0, 1.5]]],
      [[[1.0, 0.5], [0.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 0.5]]],
      [[[1.0, 1.5], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.5, 1.0]]],
      [[[1.0, 1.5], [1.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 1.5]]],
      []
    ];

    function Contours() {
      var dx = 1,
          dy = 1,
          threshold = thresholdSturges,
          smooth = smoothLinear;

      function contours(values) {
        var tz = threshold(values);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          const e = extent$1(values, finite);
          tz = ticks(...nice$1(e[0], e[1], tz), tz);
          while (tz[tz.length - 1] >= e[1]) tz.pop();
          while (tz[1] < e[0]) tz.shift();
        } else {
          tz = tz.slice().sort(ascending$1);
        }

        return tz.map(value => contour(values, value));
      }

      // Accumulate, smooth contour rings, assign holes to exterior rings.
      // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
      function contour(values, value) {
        const v = value == null ? NaN : +value;
        if (isNaN(v)) throw new Error(`invalid value: ${value}`);

        var polygons = [],
            holes = [];

        isorings(values, v, function(ring) {
          smooth(ring, values, v);
          if (area$3(ring) > 0) polygons.push([ring]);
          else holes.push(ring);
        });

        holes.forEach(function(hole) {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$3((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });

        return {
          type: "MultiPolygon",
          value: value,
          coordinates: polygons
        };
      }

      // Marching squares with isolines stitched into rings.
      // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
      function isorings(values, value, callback) {
        var fragmentByStart = new Array,
            fragmentByEnd = new Array,
            x, y, t0, t1, t2, t3;

        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = above(values[0], value);
        cases[t1 << 1].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = above(values[x + 1], value);
          cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);

        // General case for the intermediate rows.
        while (++y < dy - 1) {
          x = -1;
          t1 = above(values[y * dx + dx], value);
          t2 = above(values[y * dx], value);
          cases[t1 << 1 | t2 << 2].forEach(stitch);
          while (++x < dx - 1) {
            t0 = t1, t1 = above(values[y * dx + dx + x + 1], value);
            t3 = t2, t2 = above(values[y * dx + x + 1], value);
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }

        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t3 = t2, t2 = above(values[y * dx + x + 1], value);
          cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);

        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y],
              end = [line[1][0] + x, line[1][1] + y],
              startIndex = index(start),
              endIndex = index(end),
              f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
          }
        }
      }

      function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
      }

      function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
          var x = point[0],
              y = point[1],
              xt = x | 0,
              yt = y | 0,
              v1 = valid(values[yt * dx + xt]);
          if (x > 0 && x < dx && xt === x) {
            point[0] = smooth1(x, valid(values[yt * dx + xt - 1]), v1, value);
          }
          if (y > 0 && y < dy && yt === y) {
            point[1] = smooth1(y, valid(values[(yt - 1) * dx + xt]), v1, value);
          }
        });
      }

      contours.contour = contour;

      contours.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
      };

      contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$2.call(_)) : constant$5(_), contours) : threshold;
      };

      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop$2, contours) : smooth === smoothLinear;
      };

      return contours;
    }

    // When computing the extent, ignore infinite values (as well as invalid ones).
    function finite(x) {
      return isFinite(x) ? x : NaN;
    }

    // Is the (possibly invalid) x greater than or equal to the (known valid) value?
    // Treat any invalid value as below negative infinity.
    function above(x, value) {
      return x == null ? false : +x >= value;
    }

    // During smoothing, treat any invalid value as negative infinity.
    function valid(v) {
      return v == null || isNaN(v = +v) ? -Infinity : v;
    }

    function smooth1(x, v0, v1, value) {
      const a = value - v0;
      const b = v1 - v0;
      const d = isFinite(a) || isFinite(b) ? a / b : Math.sign(a) / Math.sign(b);
      return isNaN(d) ? x : x + d - 0.5;
    }

    function defaultX$1(d) {
      return d[0];
    }

    function defaultY$1(d) {
      return d[1];
    }

    function defaultWeight() {
      return 1;
    }

    function density() {
      var x = defaultX$1,
          y = defaultY$1,
          weight = defaultWeight,
          dx = 960,
          dy = 500,
          r = 20, // blur radius
          k = 2, // log2(grid cell size)
          o = r * 3, // grid offset, to pad for blur
          n = (dx + o * 2) >> k, // grid width
          m = (dy + o * 2) >> k, // grid height
          threshold = constant$5(20);

      function grid(data) {
        var values = new Float32Array(n * m),
            pow2k = Math.pow(2, -k),
            i = -1;

        for (const d of data) {
          var xi = (x(d, ++i, data) + o) * pow2k,
              yi = (y(d, i, data) + o) * pow2k,
              wi = +weight(d, i, data);
          if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m) {
            var x0 = Math.floor(xi),
                y0 = Math.floor(yi),
                xt = xi - x0 - 0.5,
                yt = yi - y0 - 0.5;
            values[x0 + y0 * n] += (1 - xt) * (1 - yt) * wi;
            values[x0 + 1 + y0 * n] += xt * (1 - yt) * wi;
            values[x0 + 1 + (y0 + 1) * n] += xt * yt * wi;
            values[x0 + (y0 + 1) * n] += (1 - xt) * yt * wi;
          }
        }

        blur2({data: values, width: n, height: m}, r * pow2k);
        return values;
      }

      function density(data) {
        var values = grid(data),
            tz = threshold(values),
            pow4k = Math.pow(2, 2 * k);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          tz = ticks(Number.MIN_VALUE, max$4(values) / pow4k, tz);
        }

        return Contours()
            .size([n, m])
            .thresholds(tz.map(d => d * pow4k))
          (values)
            .map((c, i) => (c.value = +tz[i], transform(c)));
      }

      density.contours = function(data) {
        var values = grid(data),
            contours = Contours().size([n, m]),
            pow4k = Math.pow(2, 2 * k),
            contour = value => {
              value = +value;
              var c = transform(contours.contour(values, value * pow4k));
              c.value = value; // preserve exact threshold value
              return c;
            };
        Object.defineProperty(contour, "max", {get: () => max$4(values) / pow4k});
        return contour;
      };

      function transform(geometry) {
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      }

      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }

      function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
      }

      // TODO Optimize.
      function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
      }

      function resize() {
        o = r * 3;
        n = (dx + o * 2) >> k;
        m = (dy + o * 2) >> k;
        return density;
      }

      density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), density) : x;
      };

      density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), density) : y;
      };

      density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : constant$5(+_), density) : weight;
      };

      density.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = +_[0], _1 = +_[1];
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
      };

      density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
      };

      density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$2.call(_)) : constant$5(_), density) : threshold;
      };

      density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();
      };

      return density;
    }

    const epsilon$3 = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$3) * epsilon$3;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum$1(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        let Q = e[0];
        for (let i = 1; i < elen; i++) Q += e[i];
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon$3) * epsilon$3;
    const ccwerrboundB = (2 + 12 * epsilon$3) * epsilon$3;
    const ccwerrboundC = (9 + 64 * epsilon$3) * epsilon$3 * epsilon$3;

    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;

        let det = estimate(4, B);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum$1(4, B, 4, u, C1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum$1(C1len, C1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum$1(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;

        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {

        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);

            for (let i = 0; i < n; i++) {
                const p = points[i];
                coords[2 * i] = getX(p);
                coords[2 * i + 1] = getY(p);
            }

            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;

            // arrays that will store the triangulation graph
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);

            // temporary arrays for tracking the edges of the advancing convex hull
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n); // edge to prev edge
            this._hullNext = new Uint32Array(n); // edge to next edge
            this._hullTri = new Uint32Array(n); // edge to adjacent triangle
            this._hullHash = new Int32Array(this._hashSize); // angular edge hash

            // temporary arrays for sorting points
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
            const n = coords.length >> 1;

            // populate an array of point indices; calculate input data bbox
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i];
                const y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            let i0, i1, i2;

            // pick a seed point close to the center
            for (let i = 0, minDist = Infinity; i < n; i++) {
                const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) {
                    i0 = i;
                    minDist = d;
                }
            }
            const i0x = coords[2 * i0];
            const i0y = coords[2 * i0 + 1];

            // find the point closest to the seed
            for (let i = 0, minDist = Infinity; i < n; i++) {
                if (i === i0) continue;
                const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) {
                    i1 = i;
                    minDist = d;
                }
            }
            let i1x = coords[2 * i1];
            let i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;

            // find the third point which forms the smallest circumcircle with the first two
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) {
                    i2 = i;
                    minRadius = r;
                }
            }
            let i2x = coords[2 * i2];
            let i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                // order collinear points by dx (or dy if all x are identical)
                // and return the list as a hull
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    const d = this._dists[id];
                    if (d > d0) {
                        hull[j++] = id;
                        d0 = d;
                    }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            // swap the order of the seed points for counter-clockwise orientation
            if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1;
                const x = i1x;
                const y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x;
            this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }

            // sort the points by distance from the seed triangle circumcenter
            quicksort(this._ids, this._dists, 0, n - 1);

            // set up the seed triangle as the starting hull
            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i];
                const y = coords[2 * i + 1];

                // skip near-duplicate points
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x;
                yp = y;

                // skip seed triangle points
                if (i === i0 || i === i1 || i === i2) continue;

                // find a visible edge on the convex hull using edge hash
                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) {
                        e = -1;
                        break;
                    }
                }
                if (e === -1) continue; // likely a near-duplicate point; skip it

                // add the first triangle from the point
                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

                // recursively flip triangles from the point until they satisfy the Delaunay condition
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t; // keep track of boundary triangles on the hull
                hullSize++;

                // walk forward through the hull, adding more triangles and flipping recursively
                let n = hullNext[e];
                while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n; // mark as removed
                    hullSize--;
                    n = q;
                }

                // walk backward from the other side, adding more triangles and flipping
                if (e === start) {
                    while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e; // mark as removed
                        hullSize--;
                        e = q;
                    }
                }

                // update the hull indices
                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                // save the two new edges in the hash table
                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            // trim typed triangle mesh arrays
            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;

            let i = 0;
            let ar = 0;

            // recursion eliminated with a fixed-size stack
            while (true) {
                const b = halfedges[a];

                /* if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 */
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) { // convex hull edge
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];

                    // edge swapped on the other side of the hull (rare); fix the halfedge reference
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;

                    // don't worry about hitting the cap: it can only happen on extremely degenerate input
                    if (i < EDGE_STACK.length) {
                        EDGE_STACK[i++] = br;
                    }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }

            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        // add a new triangle given vertex indices and adjacent half-edge ids
        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;

            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;

            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);

            this.trianglesLen += 3;

            return t;
        }
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px;
        const dy = ay - py;
        const ex = bx - px;
        const ey = by - py;
        const fx = cx - px;
        const fy = cy - py;

        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = ax + (ey * bl - dy * cl) * d;
        const y = ay + (dx * cl - ex * bl) * d;

        return {x, y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i];
                const tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1;
            let j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

            const temp = ids[i];
            const tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;

            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    const epsilon$2 = 1e-6;

    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
      }
      moveTo(x, y) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x, y) {
        this._ += `L${this._x1 = +x},${this._y1 = +y}`;
      }
      arc(x, y, r) {
        x = +x, y = +y, r = +r;
        const x0 = x + r;
        const y0 = y;
        if (r < 0) throw new Error("negative radius");
        if (this._x1 === null) this._ += `M${x0},${y0}`;
        else if (Math.abs(this._x1 - x0) > epsilon$2 || Math.abs(this._y1 - y0) > epsilon$2) this._ += "L" + x0 + "," + y0;
        if (!r) return;
        this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
      }
      rect(x, y, w, h) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    }

    let Polygon$1 = class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x, y) {
        this._.push([x, y]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x, y) {
        this._.push([x, y]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    };

    class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const {delaunay: {points, hull, triangles}, vectors} = this;
        let bx, by; // lazily computed barycenter of the hull

        // Compute circumcenters.
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
          const t1 = triangles[i] * 2;
          const t2 = triangles[i + 1] * 2;
          const t3 = triangles[i + 2] * 2;
          const x1 = points[t1];
          const y1 = points[t1 + 1];
          const x2 = points[t2];
          const y2 = points[t2 + 1];
          const x3 = points[t3];
          const y3 = points[t3 + 1];

          const dx = x2 - x1;
          const dy = y2 - y1;
          const ex = x3 - x1;
          const ey = y3 - y1;
          const ab = (dx * ey - dy * ex) * 2;

          if (Math.abs(ab) < 1e-9) {
            // For a degenerate triangle, the circumcenter is at the infinity, in a
            // direction orthogonal to the halfedge and away from the “center” of
            // the diagram <bx, by>, defined as the hull’s barycenter.
            if (bx === undefined) {
              bx = by = 0;
              for (const i of hull) bx += points[i * 2], by += points[i * 2 + 1];
              bx /= hull.length, by /= hull.length;
            }
            const a = 1e9 * Math.sign((bx - x1) * ey - (by - y1) * ex);
            x = (x1 + x3) / 2 - a * ey;
            y = (y1 + y3) / 2 + a * ex;
          } else {
            const d = 1 / ab;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x = x1 + (ey * bl - dy * cl) * d;
            y = y1 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x;
          circumcenters[j + 1] = y;
        }

        // Compute exterior cell rays.
        let h = hull[hull.length - 1];
        let p0, p1 = h * 4;
        let x0, x1 = points[2 * h];
        let y0, y1 = points[2 * h + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h = hull[i];
          p0 = p1, x0 = x1, y0 = y1;
          p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
          vectors[p0 + 2] = vectors[p1] = y0 - y1;
          vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
        if (hull.length <= 1) return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x = circumcenters[t];
          const y = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
          if (p) this._renderSegment(x, y, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path : undefined;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const points = this._clip(i);
        if (points === null || !points.length) return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
        for (let i = 2; i < n; i += 2) {
          if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
            context.lineTo(points[i], points[i + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const {delaunay: {points}} = this;
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const cell = this.cellPolygon(i);
          if (cell) cell.index = i, yield cell;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon$1;
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x0, y0, x1, y1, context) {
        let S;
        const c0 = this._regioncode(x0, y0);
        const c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
        } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
          context.moveTo(S[0], S[1]);
          context.lineTo(S[2], S[3]);
        }
      }
      contains(i, x, y) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
        return this.delaunay._step(i, x, y) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci) for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          // find the common edge
          if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
              if (ci[ai] === cj[aj]
                  && ci[ai + 1] === cj[aj + 1]
                  && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj]
                  && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
                yield j;
                break loop;
              }
            }
          }
        }
      }
      _cell(i) {
        const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
        const e0 = inedges[i];
        if (e0 === -1) return null; // coincident point
        const points = [];
        let e = e0;
        do {
          const t = Math.floor(e / 3);
          points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
        } while (e !== e0 && e !== -1);
        return points;
      }
      _clip(i) {
        // degenerate case (1 valid point: return the box)
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i);
        if (points === null) return null;
        const {vectors: V} = this;
        const v = i * 4;
        return this._simplify(V[v] || V[v + 1]
            ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
            : this._clipFinite(i, points));
      }
      _clipFinite(i, points) {
        const n = points.length;
        let P = null;
        let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
        let c0, c1 = this._regioncode(x1, y1);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x1, y1);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P) P.push(x1, y1);
            else P = [x1, y1];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1) this._edge(i, e0, e1, P, P.length);
              if (P) P.push(sx0, sy0);
              else P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx1, sy1);
            else P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x0, y0, x1, y1, c0, c1) {
        // for more robustness, always consider the segment in the same order
        const flip = c0 < c1;
        if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];
        while (true) {
          if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];
          if (c0 & c1) return null;
          let x, y, c = c0 || c1;
          if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
          else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
          else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
          else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
          if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
          else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
        }
      }
      _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x, y;
          switch (e0) {
            case 0b0101: e0 = 0b0100; continue; // top-left
            case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
            case 0b0110: e0 = 0b0010; continue; // top-right
            case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
            case 0b1010: e0 = 0b1000; continue; // bottom-right
            case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
            case 0b1001: e0 = 0b0001; continue; // bottom-left
            case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
          }
          // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
          // undefined, the conditional statement will be executed.
          if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
            P.splice(j, 0, x, y), j += 2;
          }
        }
        return j;
      }
      _project(x0, y0, vx, vy) {
        let t = Infinity, c, x, y;
        if (vy < 0) { // top
          if (y0 <= this.ymin) return null;
          if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
        } else if (vy > 0) { // bottom
          if (y0 >= this.ymax) return null;
          if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
        }
        if (vx > 0) { // right
          if (x0 >= this.xmax) return null;
          if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
        } else if (vx < 0) { // left
          if (x0 <= this.xmin) return null;
          if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
        }
        return [x, y];
      }
      _edgecode(x, y) {
        return (x === this.xmin ? 0b0001
            : x === this.xmax ? 0b0010 : 0b0000)
            | (y === this.ymin ? 0b0100
            : y === this.ymax ? 0b1000 : 0b0000);
      }
      _regioncode(x, y) {
        return (x < this.xmin ? 0b0001
            : x > this.xmax ? 0b0010 : 0b0000)
            | (y < this.ymin ? 0b0100
            : y > this.ymax ? 0b1000 : 0b0000);
      }
      _simplify(P) {
        if (P && P.length > 4) {
          for (let i = 0; i < P.length; i+= 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {
              P.splice(j, 2), i -= 2;
            }
          }
          if (!P.length) P = null;
        }
        return P;
      }
    }

    const tau$3 = 2 * Math.PI, pow$3 = Math.pow;

    function pointX(p) {
      return p[0];
    }

    function pointY(p) {
      return p[1];
    }

    // A triangulation is collinear if all its triangles have a non-null area
    function collinear(d) {
      const {triangles, coords} = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a = 2 * triangles[i],
              b = 2 * triangles[i + 1],
              c = 2 * triangles[i + 2],
              cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                    - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
        if (cross > 1e-10) return false;
      }
      return true;
    }

    function jitter(x, y, r) {
      return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
    }

    class Delaunay {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points
            ? flatArray(points, fx, fy, that)
            : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;

        // check for collinear
        if (d.hull && d.hull.length > 2 && collinear(d)) {
          this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
            .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
          const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
            bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i = 0, n = points.length / 2; i < n; ++i) {
            const p = jitter(points[2 * i], points[2 * i + 1], r);
            points[2 * i] = p[0];
            points[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }

        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);

        // Compute an index from each point to an (arbitrary) incoming halfedge
        // Used to give the first neighbor of each point; for this reason,
        // on the hull we give priority to exterior halfedges
        for (let e = 0, n = halfedges.length; e < n; ++e) {
          const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
          if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }

        // degenerate case: 1 or 2 (distinct) points
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i) {
        const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

        // degenerate case with several collinear points
        if (collinear) {
          const l = collinear.indexOf(i);
          if (l > 0) yield collinear[l - 1];
          if (l < collinear.length - 1) yield collinear[l + 1];
          return;
        }

        const e0 = inedges[i];
        if (e0 === -1) return; // coincident point
        let e = e0, p0 = -1;
        do {
          yield p0 = triangles[e];
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) return; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p0) yield p;
            return;
          }
        } while (e !== e0);
      }
      find(x, y, i = 0) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
        const i0 = i;
        let c;
        while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
        return c;
      }
      _step(i, x, y) {
        const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
        if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
        let c = i;
        let dc = pow$3(x - points[i * 2], 2) + pow$3(y - points[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e = e0;
        do {
          let t = triangles[e];
          const dt = pow$3(x - points[t * 2], 2) + pow$3(y - points[t * 2 + 1], 2);
          if (dt < dc) dc = dt, c = t;
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            e = hull[(_hullIndex[i] + 1) % hull.length];
            if (e !== t) {
              if (pow$3(x - points[e * 2], 2) + pow$3(y - points[e * 2 + 1], 2) < dc) return e;
            }
            break;
          }
        } while (e !== e0);
        return c;
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, halfedges, triangles} = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r) {
        if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
        r = r == undefined ? 2 : +r;
        const buffer = context == null ? context = new Path : undefined;
        const {points} = this;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x = points[i], y = points[i + 1];
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, tau$3);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {hull, points} = this;
        const h = hull[0] * 2, n = hull.length;
        context.moveTo(points[h], points[h + 1]);
        for (let i = 1; i < n; ++i) {
          const h = 2 * hull[i];
          context.lineTo(points[h], points[h + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon$1;
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, triangles} = this;
        const t0 = triangles[i *= 3] * 2;
        const t1 = triangles[i + 1] * 2;
        const t2 = triangles[i + 2] * 2;
        context.moveTo(points[t0], points[t0 + 1]);
        context.lineTo(points[t1], points[t1 + 1]);
        context.lineTo(points[t2], points[t2 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const {triangles} = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon$1;
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }

    function flatArray(points, fx, fy, that) {
      const n = points.length;
      const array = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points[i];
        array[i * 2] = fx.call(that, p, i, points);
        array[i * 2 + 1] = fy.call(that, p, i, points);
      }
      return array;
    }

    function* flatIterable(points, fx, fy, that) {
      let i = 0;
      for (const p of points) {
        yield fx.call(that, p, i, points);
        yield fy.call(that, p, i, points);
        ++i;
      }
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv$1 = dsvFormat(",");

    var csvParse = csv$1.parse;
    var csvParseRows = csv$1.parseRows;
    var csvFormat = csv$1.format;
    var csvFormatBody = csv$1.formatBody;
    var csvFormatRows = csv$1.formatRows;
    var csvFormatRow = csv$1.formatRow;
    var csvFormatValue = csv$1.formatValue;

    var tsv$1 = dsvFormat("\t");

    var tsvParse = tsv$1.parse;
    var tsvParseRows = tsv$1.parseRows;
    var tsvFormat = tsv$1.format;
    var tsvFormatBody = tsv$1.formatBody;
    var tsvFormatRows = tsv$1.formatRows;
    var tsvFormatRow = tsv$1.formatRow;
    var tsvFormatValue = tsv$1.formatValue;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseBlob(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.blob();
    }

    function blob(input, init) {
      return fetch(input, init).then(responseBlob);
    }

    function responseArrayBuffer(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.arrayBuffer();
    }

    function buffer(input, init) {
      return fetch(input, init).then(responseArrayBuffer);
    }

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    function dsv(delimiter, input, init, row) {
      if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
      var format = dsvFormat(delimiter);
      return text(input, init).then(function(response) {
        return format.parse(response, row);
      });
    }

    var csv = dsvParse(csvParse);
    var tsv = dsvParse(tsvParse);

    function image(input, init) {
      return new Promise(function(resolve, reject) {
        var image = new Image;
        for (var key in init) image[key] = init[key];
        image.onerror = reject;
        image.onload = function() { resolve(image); };
        image.src = input;
      });
    }

    function responseJson(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205) return;
      return response.json();
    }

    function json(input, init) {
      return fetch(input, init).then(responseJson);
    }

    function parser(type) {
      return (input, init) => text(input, init)
        .then(text => (new DOMParser).parseFromString(text, type));
    }

    var xml = parser("application/xml");

    var html = parser("text/html");

    var svg = parser("image/svg+xml");

    function center(x, y) {
      var nodes, strength = 1;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      return force;
    }

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add$2(this.cover(x, y), x, y, d);
    }

    function add$2(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add$2(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries don’t change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant can’t contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isn’t necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$3(d) {
      return d.x + d.vx;
    }

    function y$3(d) {
      return d.y + d.vy;
    }

    function collide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$4(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$3, y$3).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$3(d) {
      return d.index;
    }

    function find$1(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function link$2(links) {
      var id = index$3,
          strength = defaultStrength,
          strengths,
          distance = constant$4(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find$1(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find$1(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$4(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$2 = 1664525;
    const c$4 = 1013904223;
    const m$1 = 4294967296; // 2^32

    function lcg$2() {
      let s = 1;
      return () => (s = (a$2 * s + c$4) % m$1) / m$1;
    }

    function x$2(d) {
      return d.x;
    }

    function y$2(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function simulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg$2();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function manyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant$4(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function radial$1(radius, x, y) {
      var nodes,
          strength = constant$4(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$4(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function x$1(x) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$4(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : x;
      };

      return force;
    }

    function y$1(y) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$4(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : y;
      };

      return force;
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity$6(x) {
      return x;
    }

    var map$1 = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale$1(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$6 : formatGroup(map$1.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$6 : formatNumerals(map$1.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "−" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;

    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    var epsilon$1 = 1e-6;
    var epsilon2 = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var quarterPi = pi$1 / 4;
    var tau$2 = pi$1 * 2;

    var degrees = 180 / pi$1;
    var radians = pi$1 / 180;

    var abs$1 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$2 = Math.cos;
    var ceil$1 = Math.ceil;
    var exp$1 = Math.exp;
    var hypot = Math.hypot;
    var log$1 = Math.log;
    var pow$2 = Math.pow;
    var sin$2 = Math.sin;
    var sign$3 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$2 = Math.sqrt;
    var tan$1 = Math.tan;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$2(x / 2)) * x;
    }

    function noop$1() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    var areaRingSum$1 = new Adder();

    // hello?

    var areaSum$1 = new Adder(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream$1 = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaRingSum$1 = new Adder();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$2 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$1;
      },
      sphere: function() {
        areaSum$1.add(tau$2);
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }

    function areaPointFirst$1(lambda, phi) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians, phi *= radians;
      lambda0$2 = lambda, cosPhi0$1 = cos$2(phi = phi / 2 + quarterPi), sinPhi0$1 = sin$2(phi);
    }

    function areaPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnoli’s
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$2(phi),
          sinPhi = sin$2(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$2(adLambda),
          v = k * sdLambda * sin$2(adLambda);
      areaRingSum$1.add(atan2$1(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function area$2(object) {
      areaSum$1 = new Adder();
      geoStream(object, areaStream$1);
      return areaSum$1 * 2;
    }

    function spherical(cartesian) {
      return [atan2$1(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$2(phi);
      return [cosPhi * cos$2(lambda), cosPhi * sin$2(lambda), sin$2(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0$1, // previous 3D point
        deltaSum,
        ranges,
        range$1;

    var boundsStream$2 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$2.point = boundsRingPoint;
        boundsStream$2.lineStart = boundsRingStart;
        boundsStream$2.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$2.point = boundsPoint$1;
        boundsStream$2.lineStart = boundsLineStart;
        boundsStream$2.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$1) phi1 = 90;
        else if (deltaSum < -epsilon$1) phi0 = -90;
        range$1[0] = lambda0$1, range$1[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$1(lambda, phi) {
      ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian([lambda * radians, phi * radians]);
      if (p0$1) {
        var normal = cartesianCross(p0$1, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees * sign,
            phii,
            antimeridian = abs$1(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0$1 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$2.point = linePoint;
    }

    function boundsLineEnd() {
      range$1[0] = lambda0$1, range$1[1] = lambda1;
      boundsStream$2.point = boundsPoint$1;
      p0$1 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0$1) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream$1.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream$1.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$1(deltaSum) > epsilon$1) lambda0$1 = -(lambda1 = 180);
      range$1[0] = lambda0$1, range$1[1] = lambda1;
      p0$1 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
    // the distance between ±180° to be 360°.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream$2);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range$1 = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0$1, Y0$1, Z0$1,
        X1$1, Y1$1, Z1$1,
        X2$1, Y2$1, Z2$1,
        lambda00, phi00, // first point
        x0$4, y0$4, z0; // previous point

    var centroidStream$1 = {
      sphere: noop$1,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$2(phi);
      centroidPointCartesian(cosPhi * cos$2(lambda), cosPhi * sin$2(lambda), sin$2(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0$1 += (x - X0$1) / W0;
      Y0$1 += (y - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$2(phi);
      x0$4 = cosPhi * cos$2(lambda);
      y0$4 = cosPhi * sin$2(lambda);
      z0 = sin$2(phi);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$2(phi),
          x = cosPhi * cos$2(lambda),
          y = cosPhi * sin$2(lambda),
          z = sin$2(phi),
          w = atan2$1(sqrt$2((w = y0$4 * z - z0 * y) * w + (w = z0 * x - x0$4 * z) * w + (w = x0$4 * y - y0$4 * x) * w), x0$4 * x + y0$4 * y + z0 * z);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }

    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians, phi *= radians;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$2(phi);
      x0$4 = cosPhi * cos$2(lambda);
      y0$4 = cosPhi * sin$2(lambda);
      z0 = sin$2(phi);
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$2(phi),
          x = cosPhi * cos$2(lambda),
          y = cosPhi * sin$2(lambda),
          z = sin$2(phi),
          cx = y0$4 * z - z0 * y,
          cy = z0 * x - x0$4 * z,
          cz = x0$4 * y - y0$4 * x,
          m = hypot(cx, cy, cz),
          w = asin$1(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2$1.add(v * cx);
      Y2$1.add(v * cy);
      Z2$1.add(v * cz);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroid$1(object) {
      W0 = W1 =
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 = 0;
      X2$1 = new Adder();
      Y2$1 = new Adder();
      Z2$1 = new Adder();
      geoStream(object, centroidStream$1);

      var x = +X2$1,
          y = +Y2$1,
          z = +Z2$1,
          m = hypot(x, y, z);

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2) {
        x = X1$1, y = Y1$1, z = Z1$1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$1) x = X0$1, y = Y0$1, z = Z0$1;
        m = hypot(x, y, z);
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2) return [NaN, NaN];
      }

      return [atan2$1(y, x) * degrees, asin$1(z / m) * degrees];
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      if (abs$1(lambda) > pi$1) lambda -= Math.round(lambda / tau$2) * tau$2;
      return [lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$2) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        lambda += deltaLambda;
        if (abs$1(lambda) > pi$1) lambda -= Math.round(lambda / tau$2) * tau$2;
        return [lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$2(deltaPhi),
          sinDeltaPhi = sin$2(deltaPhi),
          cosDeltaGamma = cos$2(deltaGamma),
          sinDeltaGamma = sin$2(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$2(phi),
            x = cos$2(lambda) * cosPhi,
            y = sin$2(lambda) * cosPhi,
            z = sin$2(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$1(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$1(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$2(phi),
            x = cos$2(lambda) * cosPhi,
            y = sin$2(lambda) * cosPhi,
            z = sin$2(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$1(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$1(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function rotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0°, 0°], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$2(radius),
          sinRadius = sin$2(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$2;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$2;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos$2(t), -sinRadius * sin$2(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos$1(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$2 - epsilon$1) % tau$2;
    }

    function circle$2() {
      var center = constant$3([0, 0]),
          radius = constant$3(90),
          precision = constant$3(2),
          ring,
          rotate,
          stream = {point: point};

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees, x[1] *= degrees;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians,
            p = precision.apply(this, arguments) * radians;
        ring = [];
        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = {type: "Polygon", coordinates: [ring]};
        ring = rotate = null;
        return c;
      }

      circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant$3([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$3(+_), circle) : radius;
      };

      circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant$3(+_), circle) : precision;
      };

      return circle;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$1,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual(a, b) {
      return abs$1(a[0] - b[0]) < epsilon$1 && abs$1(a[1] - b[1]) < epsilon$1;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$1;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link$1(subject);
      link$1(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link$1(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function longitude(point) {
      return abs$1(point[0]) <= pi$1 ? point[0] : sign$3(point[0]) * ((abs$1(point[0]) + pi$1) % tau$2 - pi$1);
    }

    function polygonContains(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$2(phi),
          normal = [sin$2(lambda), -cos$2(lambda), 0],
          angle = 0,
          winding = 0;

      var sum = new Adder();

      if (sinPhi === 1) phi = halfPi$1 + epsilon$1;
      else if (sinPhi === -1) phi = -halfPi$1 - epsilon$1;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin$2(phi0),
            cosPhi0 = cos$2(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin$2(phi1),
              cosPhi1 = cos$2(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$1,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2$1(k * sign * sin$2(absDelta), cosPhi0 * cosPhi1 + k * cos$2(absDelta)));
          angle += antimeridian ? delta + sign * tau$2 : delta;

          // Are the longitudes either side of the point’s meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$1 || angle < epsilon$1 && sum < -epsilon2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge(segments);
            var startInside = polygonContains(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$1 - epsilon$1 : halfPi$1 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$1 : halfPi$1 - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$1, -halfPi$1]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
              delta = abs$1(lambda1 - lambda0);
          if (abs$1(delta - pi$1) < epsilon$1) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$1 : -halfPi$1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
            if (abs$1(lambda0 - sign0) < epsilon$1) lambda0 -= sign0 * epsilon$1; // handle degeneracies
            if (abs$1(lambda1 - sign1) < epsilon$1) lambda1 -= sign1 * epsilon$1;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$2(lambda0 - lambda1);
      return abs$1(sinLambda0Lambda1) > epsilon$1
          ? atan((sin$2(phi0) * (cosPhi1 = cos$2(phi1)) * sin$2(lambda1)
              - sin$2(phi1) * (cosPhi0 = cos$2(phi0)) * sin$2(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$1;
        stream.point(-pi$1, phi);
        stream.point(0, phi);
        stream.point(pi$1, phi);
        stream.point(pi$1, 0);
        stream.point(pi$1, -phi);
        stream.point(0, -phi);
        stream.point(-pi$1, -phi);
        stream.point(-pi$1, 0);
        stream.point(-pi$1, phi);
      } else if (abs$1(from[0] - to[0]) > epsilon$1) {
        var lambda = from[0] < to[0] ? pi$1 : -pi$1;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius) {
      var cr = cos$2(radius),
          delta = 2 * radians,
          smallRadius = cr > 0,
          notHemisphere = abs$1(cr) > epsilon$1; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$2(lambda) * cos$2(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$2(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$1(delta - pi$1) < epsilon$1,
            meridian = polar || delta < epsilon$1;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$1 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$1 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygon’s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$1(p[0] - x0) < epsilon$1 ? direction > 0 ? 0 : 3
            : abs$1(p[0] - x1) < epsilon$1 ? direction > 0 ? 2 : 1
            : abs$1(p[1] - y0) < epsilon$1 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    function extent() {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function(stream) {
          return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    }

    var lengthSum$1,
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream$1 = {
      sphere: noop$1,
      point: noop$1,
      lineStart: lengthLineStart,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1
    };

    function lengthLineStart() {
      lengthStream$1.point = lengthPointFirst$1;
      lengthStream$1.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream$1.point = lengthStream$1.lineEnd = noop$1;
    }

    function lengthPointFirst$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      lambda0 = lambda, sinPhi0 = sin$2(phi), cosPhi0 = cos$2(phi);
      lengthStream$1.point = lengthPoint$1;
    }

    function lengthPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var sinPhi = sin$2(phi),
          cosPhi = cos$2(phi),
          delta = abs$1(lambda - lambda0),
          cosDelta = cos$2(delta),
          sinDelta = sin$2(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum$1.add(atan2$1(sqrt$2(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length$1(object) {
      lengthSum$1 = new Adder();
      geoStream(object, lengthStream$1);
      return +lengthSum$1;
    }

    var coordinates = [null, null],
        object = {type: "LineString", coordinates: coordinates};

    function distance(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length$1(object);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = distance(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = distance(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }

    function contains$2(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = range$3(y0, y1 - epsilon$1, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = range$3(x0, x1 - epsilon$1, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return range$3(ceil$1(X0 / DX) * DX, X1, DX).map(X)
            .concat(range$3(ceil$1(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(range$3(ceil$1(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$1(x % DX) > epsilon$1; }).map(x))
            .concat(range$3(ceil$1(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$1(y % DY) > epsilon$1; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$1], [180, 90 - epsilon$1]])
          .extentMinor([[-180, -80 - epsilon$1], [180, 80 + epsilon$1]]);
    }

    function graticule10() {
      return graticule()();
    }

    function interpolate(a, b) {
      var x0 = a[0] * radians,
          y0 = a[1] * radians,
          x1 = b[0] * radians,
          y1 = b[1] * radians,
          cy0 = cos$2(y0),
          sy0 = sin$2(y0),
          cy1 = cos$2(y1),
          sy1 = sin$2(y1),
          kx0 = cy0 * cos$2(x0),
          ky0 = cy0 * sin$2(x0),
          kx1 = cy1 * cos$2(x1),
          ky1 = cy1 * sin$2(x1),
          d = 2 * asin$1(sqrt$2(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$2(d);

      var interpolate = d ? function(t) {
        var B = sin$2(t *= d) / k,
            A = sin$2(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$1(y, x) * degrees,
          atan2$1(z, sqrt$2(x * x + y * y)) * degrees
        ];
      } : function() {
        return [x0 * degrees, y0 * degrees];
      };

      interpolate.distance = d;

      return interpolate;
    }

    var identity$5 = x => x;

    var areaSum = new Adder(),
        areaRingSum = new Adder(),
        x00$2,
        y00$2,
        x0$3,
        y0$3;

    var areaStream = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
        areaSum.add(abs$1(areaRingSum));
        areaRingSum = new Adder();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum = new Adder();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0$3 * x - x0$3 * y);
      x0$3 = x, y0$3 = y;
    }

    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }

    var pathArea = areaStream;

    var x0$2 = Infinity,
        y0$2 = x0$2,
        x1 = -x0$2,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1,
      result: function() {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0$2) x0$2 = x;
      if (x > x1) x1 = x;
      if (y < y0$2) y0$2 = y;
      if (y > y1) y1 = y;
    }

    var boundsStream$1 = boundsStream;

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$1,
        y0$1;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$2(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x, y00$1 = y0$1 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$1,
          dy = y - y0$1,
          z = sqrt$2(dx * dx + dy * dy);

      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;

      z = y0$1 * x - x0$1 * y;
      X2 += z * (x0$1 + x);
      Y2 += z * (y0$1 + y);
      Z2 += z * 3;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    var pathCentroid = centroidStream;

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$2);
            break;
          }
        }
      },
      result: noop$1
    };

    var lengthSum = new Adder(),
        lengthRing,
        x00,
        y00,
        x0,
        y0;

    var lengthStream = {
      point: noop$1,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = noop$1;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum = new Adder();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x, y00 = y0 = y;
    }

    function lengthPoint(x, y) {
      x0 -= x, y0 -= y;
      lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
      x0 = x, y0 = y;
    }

    var pathMeasure = lengthStream;

    // Simple caching for constant-radius points.
    let cacheDigits, cacheAppend, cacheRadius, cacheCircle;

    class PathString {
      constructor(digits) {
        this._append = digits == null ? append : appendRound(digits);
        this._radius = 4.5;
        this._ = "";
      }
      pointRadius(_) {
        this._radius = +_;
        return this;
      }
      polygonStart() {
        this._line = 0;
      }
      polygonEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line === 0) this._ += "Z";
        this._point = NaN;
      }
      point(x, y) {
        switch (this._point) {
          case 0: {
            this._append`M${x},${y}`;
            this._point = 1;
            break;
          }
          case 1: {
            this._append`L${x},${y}`;
            break;
          }
          default: {
            this._append`M${x},${y}`;
            if (this._radius !== cacheRadius || this._append !== cacheAppend) {
              const r = this._radius;
              const s = this._;
              this._ = ""; // stash the old string so we can cache the circle path fragment
              this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
              cacheRadius = r;
              cacheAppend = this._append;
              cacheCircle = this._;
              this._ = s;
            }
            this._ += cacheCircle;
            break;
          }
        }
      }
      result() {
        const result = this._;
        this._ = "";
        return result.length ? result : null;
      }
    }

    function append(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }

    function appendRound(digits) {
      const d = Math.floor(digits);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${digits}`);
      if (d > 15) return append;
      if (d !== cacheDigits) {
        const k = 10 ** d;
        cacheDigits = d;
        cacheAppend = function append(strings) {
          let i = 1;
          this._ += strings[0];
          for (const j = strings.length; i < j; ++i) {
            this._ += Math.round(arguments[i] * k) / k + strings[i];
          }
        };
      }
      return cacheAppend;
    }

    function index$2(projection, context) {
      let digits = 3,
          pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream(object, projectionStream(pathArea));
        return pathArea.result();
      };

      path.measure = function(object) {
        geoStream(object, projectionStream(pathMeasure));
        return pathMeasure.result();
      };

      path.bounds = function(object) {
        geoStream(object, projectionStream(boundsStream$1));
        return boundsStream$1.result();
      };

      path.centroid = function(object) {
        geoStream(object, projectionStream(pathCentroid));
        return pathCentroid.result();
      };

      path.projection = function(_) {
        if (!arguments.length) return projection;
        projectionStream = _ == null ? (projection = null, identity$5) : (projection = _).stream;
        return path;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      path.digits = function(_) {
        if (!arguments.length) return digits;
        if (_ == null) digits = null;
        else {
          const d = Math.floor(_);
          if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        if (context === null) contextStream = new PathString(digits);
        return path;
      };

      return path.projection(projection).digits(digits).context(context);
    }

    function transform$1(methods) {
      return {
        stream: transformer$3(methods)
      };
    }

    function transformer$3(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream(object, projection.stream(boundsStream$1));
      fitBounds(boundsStream$1.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos$2(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer$3({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$2(a * a + b * b + c * c),
              phi2 = asin$1(c /= m),
              lambda2 = abs$1(abs$1(c) - 1) < epsilon$1 || abs$1(lambda0 - lambda1) < epsilon$1 ? (lambda0 + lambda1) / 2 : atan2$1(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer$3({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function transformRotate(rotate) {
      return transformer$3({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$2(alpha),
          sinAlpha = sin$2(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$5, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians, point[1] * radians);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$2(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi$1 / 3,
          m = projectionMutator(projectAt),
          p = m(phi0, phi1);

      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$2(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$2(phi) / cosPhi0];
      }

      forward.invert = function(x, y) {
        return [x / cosPhi0, asin$1(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin$2(y0), n = (sy0 + sin$2(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs$1(n) < epsilon$1) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c) / n;

      function project(x, y) {
        var r = sqrt$2(c - 2 * n * sin$2(y)) / n;
        return [r * sin$2(x *= n), r0 - r * cos$2(x)];
      }

      project.invert = function(x, y) {
        var r0y = r0 - y,
            l = atan2$1(x, abs$1(r0y)) * sign$3(r0y);
        if (r0y * n < 0)
          l -= pi$1 * sign$3(x) * sign$3(r0y);
        return [l / n, asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    function conicEqualArea() {
      return conicProjection(conicEqualAreaRaw)
          .scale(155.424)
          .center([0, 33.6442]);
    }

    function albers() {
      return conicEqualArea()
          .parallels([29.5, 45.5])
          .scale(1070)
          .translate([480, 250])
          .rotate([96, 0])
          .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
        sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
        lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
        lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
        polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
        polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960×500. The projection also works quite well at 960×600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
      var cache,
          cacheStream,
          lower48 = albers(), lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
          hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
          point, pointStream = {point: function(x, y) { point = [x, y]; }};

      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null,
            (lower48Point.point(x, y), point)
            || (alaskaPoint.point(x, y), point)
            || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
            : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
            : lower48).invert(coordinates);
      };

      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
            .translate(_)
            .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
            .stream(pointStream);

        alaskaPoint = alaska
            .translate([x - 0.307 * k, y + 0.201 * k])
            .clipExtent([[x - 0.425 * k + epsilon$1, y + 0.120 * k + epsilon$1], [x - 0.214 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        hawaiiPoint = hawaii
            .translate([x - 0.205 * k, y + 0.212 * k])
            .clipExtent([[x - 0.214 * k + epsilon$1, y + 0.166 * k + epsilon$1], [x - 0.115 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function(extent, object) {
        return fitExtent(albersUsa, extent, object);
      };

      albersUsa.fitSize = function(size, object) {
        return fitSize(albersUsa, size, object);
      };

      albersUsa.fitWidth = function(width, object) {
        return fitWidth(albersUsa, width, object);
      };

      albersUsa.fitHeight = function(height, object) {
        return fitHeight(albersUsa, height, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
      return function(x, y) {
        var cx = cos$2(x),
            cy = cos$2(y),
            k = scale(cx * cy);
            if (k === Infinity) return [2, 0];
        return [
          k * cy * sin$2(x),
          k * sin$2(y)
        ];
      }
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$2(x * x + y * y),
            c = angle(z),
            sc = sin$2(c),
            cc = cos$2(c);
        return [
          atan2$1(x * sc, z * cc),
          asin$1(z && y * sc / z)
        ];
      }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$2(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin$1(z / 2);
    });

    function azimuthalEqualArea() {
      return projection(azimuthalEqualAreaRaw)
          .scale(124.75)
          .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
      return (c = acos$1(c)) && c / sin$2(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });

    function azimuthalEquidistant() {
      return projection(azimuthalEquidistantRaw)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan$1((halfPi$1 + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan(exp$1(y)) - halfPi$1];
    };

    function mercator() {
      return mercatorProjection(mercatorRaw)
          .scale(961 / tau$2);
    }

    function mercatorProjection(project) {
      var m = projection(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null, y0, x1, y1; // clip extent

      m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function(_) {
        return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi$1 * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null
            ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
            ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
            : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan$1((halfPi$1 + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos$2(y0),
          n = y0 === y1 ? sin$2(y0) : log$1(cy0 / cos$2(y1)) / log$1(tany(y1) / tany(y0)),
          f = cy0 * pow$2(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) { if (y < -halfPi$1 + epsilon$1) y = -halfPi$1 + epsilon$1; }
        else { if (y > halfPi$1 - epsilon$1) y = halfPi$1 - epsilon$1; }
        var r = f / pow$2(tany(y), n);
        return [r * sin$2(n * x), f - r * cos$2(n * x)];
      }

      project.invert = function(x, y) {
        var fy = f - y, r = sign$3(n) * sqrt$2(x * x + fy * fy),
          l = atan2$1(x, abs$1(fy)) * sign$3(fy);
        if (fy * n < 0)
          l -= pi$1 * sign$3(x) * sign$3(fy);
        return [l / n, 2 * atan(pow$2(f / r, 1 / n)) - halfPi$1];
      };

      return project;
    }

    function conicConformal() {
      return conicProjection(conicConformalRaw)
          .scale(109.5)
          .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
      return projection(equirectangularRaw)
          .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos$2(y0),
          n = y0 === y1 ? sin$2(y0) : (cy0 - cos$2(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs$1(n) < epsilon$1) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$2(nx), g - gy * cos$2(nx)];
      }

      project.invert = function(x, y) {
        var gy = g - y,
            l = atan2$1(x, abs$1(gy)) * sign$3(gy);
        if (gy * n < 0)
          l -= pi$1 * sign$3(x) * sign$3(gy);
        return [l / n, g - sign$3(n) * sqrt$2(x * x + gy * gy)];
      };

      return project;
    }

    function conicEquidistant() {
      return conicProjection(conicEquidistantRaw)
          .scale(131.154)
          .center([0, 13.9389]);
    }

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = sqrt$2(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
      var l = asin$1(M * sin$2(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }

    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$1(delta) < epsilon2) break;
      }
      return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$2(l),
        asin$1(sin$2(l) / M)
      ];
    };

    function equalEarth() {
      return projection(equalEarthRaw)
          .scale(177.158);
    }

    function gnomonicRaw(x, y) {
      var cy = cos$2(y), k = cos$2(x) * cy;
      return [cy * sin$2(x) / k, sin$2(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    function gnomonic() {
      return projection(gnomonicRaw)
          .scale(144.049)
          .clipAngle(60);
    }

    function identity$4() {
      var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
          alpha = 0, ca, sa, // angle
          x0 = null, y0, x1, y1, // clip extent
          kx = 1, ky = 1,
          transform = transformer$3({
            point: function(x, y) {
              var p = projection([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }),
          postclip = identity$5,
          cache,
          cacheStream;

      function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
      }

      function projection (p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
          var t = y * ca - x * sa;
          x = x * ca + y * sa;
          y = t;
        }    
        return [x + tx, y + ty];
      }
      projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
          var t = y * ca + x * sa;
          x = x * ca - y * sa;
          y = t;
        }
        return [x / kx, y / ky];
      };
      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
      };
      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };
      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };
      projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
      };
      projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
      };
      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, sa = sin$2(alpha), ca = cos$2(alpha), reset()) : alpha * degrees;
      };
      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
      };
      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
      };
      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };
      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };
      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };
      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
      ];
    }

    naturalEarth1Raw.invert = function(x, y) {
      var phi = y, i = 25, delta;
      do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
            (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
      } while (abs$1(delta) > epsilon$1 && --i > 0);
      return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
      ];
    };

    function naturalEarth1() {
      return projection(naturalEarth1Raw)
          .scale(175.295);
    }

    function orthographicRaw(x, y) {
      return [cos$2(y) * sin$2(x), sin$2(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin$1);

    function orthographic() {
      return projection(orthographicRaw)
          .scale(249.5)
          .clipAngle(90 + epsilon$1);
    }

    function stereographicRaw(x, y) {
      var cy = cos$2(y), k = 1 + cos$2(x) * cy;
      return [cy * sin$2(x) / k, sin$2(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });

    function stereographic() {
      return projection(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan$1((halfPi$1 + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan(exp$1(x)) - halfPi$1];
    };

    function transverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function(_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90])
          .scale(159.155);
    }

    function defaultSeparation$1(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    function meanX(children) {
      return children.reduce(meanXReduce, 0) / children.length;
    }

    function meanXReduce(x, c) {
      return x + c.x;
    }

    function maxY(children) {
      return 1 + children.reduce(maxYReduce, 0);
    }

    function maxYReduce(y, c) {
      return Math.max(y, c.y);
    }

    function leafLeft(node) {
      var children;
      while (children = node.children) node = children[0];
      return node;
    }

    function leafRight(node) {
      var children;
      while (children = node.children) node = children[children.length - 1];
      return node;
    }

    function cluster() {
      var separation = defaultSeparation$1,
          dx = 1,
          dy = 1,
          nodeSize = false;

      function cluster(root) {
        var previousNode,
            x = 0;

        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
          var children = node.children;
          if (children) {
            node.x = meanX(children);
            node.y = maxY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });

        var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2;

        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root.x) * dx;
          node.y = (root.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * dx;
          node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
      }

      cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
      };

      cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
      };

      cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
      };

      return cluster;
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;
      else while (--i >= 0) sum += children[i].value;
      node.value = sum;
    }

    function node_count() {
      return this.eachAfter(count);
    }

    function node_each(callback, that) {
      let index = -1;
      for (const node of this) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_eachBefore(callback, that) {
      var node = this, nodes = [node], children, i, index = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index, this);
        if (children = node.children) {
          for (i = children.length - 1; i >= 0; --i) {
            nodes.push(children[i]);
          }
        }
      }
      return this;
    }

    function node_eachAfter(callback, that) {
      var node = this, nodes = [node], next = [], children, i, n, index = -1;
      while (node = nodes.pop()) {
        next.push(node);
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            nodes.push(children[i]);
          }
        }
      }
      while (node = next.pop()) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_find(callback, that) {
      let index = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    }

    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;
        while (--i >= 0) sum += children[i].value;
        node.value = sum;
      });
    }

    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path(end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];
      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }

    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }

    function node_descendants() {
      return Array.from(this);
    }

    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links() {
      var root = this, links = [];
      root.each(function(node) {
        if (node !== root) { // Don’t include the root’s parent, if any.
          links.push({source: node.parent, target: node});
        }
      });
      return links;
    }

    function* node_iterator() {
      var node = this, current, next = [node], children, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          yield node;
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function hierarchy(data, children) {
      if (data instanceof Map) {
        data = [undefined, data];
        if (children === undefined) children = mapChildren;
      } else if (children === undefined) {
        children = objectChildren;
      }

      var root = new Node$1(data),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;

      while (node = nodes.pop()) {
        if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$1(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function objectChildren(d) {
      return d.children;
    }

    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }

    function copyData(node) {
      if (node.data.value !== undefined) node.value = node.data.value;
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;
      do node.height = height;
      while ((node = node.parent) && (node.height < ++height));
    }

    function Node$1(data) {
      this.data = data;
      this.depth =
      this.height = 0;
      this.parent = null;
    }

    Node$1.prototype = hierarchy.prototype = {
      constructor: Node$1,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };

    function optional(f) {
      return f == null ? null : required(f);
    }

    function required(f) {
      if (typeof f !== "function") throw new Error;
      return f;
    }

    function constantZero() {
      return 0;
    }

    function constant$2(x) {
      return function() {
        return x;
      };
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$1 = 1664525;
    const c$3 = 1013904223;
    const m = 4294967296; // 2^32

    function lcg$1() {
      let s = 1;
      return () => (s = (a$1 * s + c$3) % m) / m;
    }

    function array$1(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function shuffle$1(array, random) {
      let m = array.length,
          t,
          i;

      while (m) {
        i = random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    function enclose(circles) {
      return packEncloseRandom(circles, lcg$1());
    }

    function packEncloseRandom(circles, random) {
      var i = 0, n = (circles = shuffle$1(Array.from(circles), random)).length, B = [], p, e;

      while (i < n) {
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
      }

      return e;
    }

    function extendBasis(B, p) {
      var i, j;

      if (enclosesWeakAll(p, B)) return [p];

      // If we get here then B must have at least one element.
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i])
            && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }

      // If we get here then B must have at least two elements.
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p)
              && enclosesNot(encloseBasis2(B[i], p), B[j])
              && enclosesNot(encloseBasis2(B[j], p), B[i])
              && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }

      // If we get here then something is very wrong.
      throw new Error;
    }

    function enclosesNot(a, b) {
      var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }

    function enclosesWeak(a, b) {
      var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }

    function encloseBasis(B) {
      switch (B.length) {
        case 1: return encloseBasis1(B[0]);
        case 2: return encloseBasis2(B[0], B[1]);
        case 3: return encloseBasis3(B[0], B[1], B[2]);
      }
    }

    function encloseBasis1(a) {
      return {
        x: a.x,
        y: a.y,
        r: a.r
      };
    }

    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }

    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x3 = c.x, y3 = c.y, r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(Math.abs(A) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
      };
    }

    function place(b, a, c) {
      var dx = b.x - a.x, x, a2,
          dy = b.y - a.y, y, b2,
          d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }

    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function score(node) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }

    function Node(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function packSiblingsRandom(circles, random) {
      if (!(n = (circles = array$1(circles)).length)) return 0;

      var a, b, c, n, aa, ca, i, j, k, sj, sk;

      // Place the first circle.
      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r;

      // Place the second circle.
      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r;

      // Place the third circle.
      place(b, a, c = circles[2]);

      // Initialize the front-chain using the first three circles a, b and c.
      a = new Node(a), b = new Node(b), c = new Node(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;

      // Attempt to place each remaining circle…
      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node(c);

        // Find the closest intersecting circle on the front-chain, if any.
        // “Closeness” is determined by linear distance along the front-chain.
        // “Ahead” or “behind” is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do {
          if (sj <= sk) {
            if (intersects(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next);

        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;

        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c, aa = ca;
          }
        }
        b = a.next;
      }

      // Compute the enclosing circle of the front chain.
      a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = packEncloseRandom(a, random);

      // Translate the circles to put the enclosing circle around the origin.
      for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

      return c.r;
    }

    function siblings(circles) {
      packSiblingsRandom(circles, lcg$1());
      return circles;
    }

    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }

    function index$1() {
      var radius = null,
          dx = 1,
          dy = 1,
          padding = constantZero;

      function pack(root) {
        const random = lcg$1();
        root.x = dx / 2, root.y = dy / 2;
        if (radius) {
          root.eachBefore(radiusLeaf(radius))
              .eachAfter(packChildrenRandom(padding, 0.5, random))
              .eachBefore(translateChild(1));
        } else {
          root.eachBefore(radiusLeaf(defaultRadius))
              .eachAfter(packChildrenRandom(constantZero, 1, random))
              .eachAfter(packChildrenRandom(padding, root.r / Math.min(dx, dy), random))
              .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        }
        return root;
      }

      pack.radius = function(x) {
        return arguments.length ? (radius = optional(x), pack) : radius;
      };

      pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
      };

      pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : constant$2(+x), pack) : padding;
      };

      return pack;
    }

    function radiusLeaf(radius) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius(node) || 0);
        }
      };
    }

    function packChildrenRandom(padding, k, random) {
      return function(node) {
        if (children = node.children) {
          var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e;

          if (r) for (i = 0; i < n; ++i) children[i].r += r;
          e = packSiblingsRandom(children, random);
          if (r) for (i = 0; i < n; ++i) children[i].r -= r;
          node.r = e + r;
        }
      };
    }

    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }

    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function partition() {
      var dx = 1,
          dy = 1,
          padding = 0,
          round = false;

      function partition(root) {
        var n = root.height + 1;
        root.x0 =
        root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy / n;
        root.eachBefore(positionNode(dy, n));
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(dy, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
          }
          var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
        };
      }

      partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
      };

      partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
      };

      partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
      };

      return partition;
    }

    var preroot = {depth: -1},
        ambiguous = {},
        imputed = {};

    function defaultId(d) {
      return d.id;
    }

    function defaultParentId(d) {
      return d.parentId;
    }

    function stratify() {
      var id = defaultId,
          parentId = defaultParentId,
          path;

      function stratify(data) {
        var nodes = Array.from(data),
            currentId = id,
            currentParentId = parentId,
            n,
            d,
            i,
            root,
            parent,
            node,
            nodeId,
            nodeKey,
            nodeByKey = new Map;

        if (path != null) {
          const I = nodes.map((d, i) => normalize$1(path(d, i, data)));
          const P = I.map(parentof);
          const S = new Set(I).add("");
          for (const i of P) {
            if (!S.has(i)) {
              S.add(i);
              I.push(i);
              P.push(parentof(i));
              nodes.push(imputed);
            }
          }
          currentId = (_, i) => I[i];
          currentParentId = (_, i) => P[i];
        }

        for (i = 0, n = nodes.length; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$1(d);
          if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
            nodeKey = node.id = nodeId;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
            node.parent = nodeId;
          }
        }

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId = node.parent) {
            parent = nodeByKey.get(nodeId);
            if (!parent) throw new Error("missing: " + nodeId);
            if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
            if (parent.children) parent.children.push(node);
            else parent.children = [node];
            node.parent = parent;
          } else {
            if (root) throw new Error("multiple roots");
            root = node;
          }
        }

        if (!root) throw new Error("no root");

        // When imputing internal nodes, only introduce roots if needed.
        // Then replace the imputed marker data with null.
        if (path != null) {
          while (root.data === imputed && root.children.length === 1) {
            root = root.children[0], --n;
          }
          for (let i = nodes.length - 1; i >= 0; --i) {
            node = nodes[i];
            if (node.data !== imputed) break;
            node.data = null;
          }
        }

        root.parent = preroot;
        root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");

        return root;
      }

      stratify.id = function(x) {
        return arguments.length ? (id = optional(x), stratify) : id;
      };

      stratify.parentId = function(x) {
        return arguments.length ? (parentId = optional(x), stratify) : parentId;
      };

      stratify.path = function(x) {
        return arguments.length ? (path = optional(x), stratify) : path;
      };

      return stratify;
    }

    // To normalize a path, we coerce to a string, strip the trailing slash if any
    // (as long as the trailing slash is not immediately preceded by another slash),
    // and add leading slash if missing.
    function normalize$1(path) {
      path = `${path}`;
      let i = path.length;
      if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);
      return path[0] === "/" ? path : `/${path}`;
    }

    // Walk backwards to find the first slash that is not the leading slash, e.g.:
    // "/foo/bar" ⇥ "/foo", "/foo" ⇥ "/", "/" ↦ "". (The root is special-cased
    // because the id of the root must be a truthy value.)
    function parentof(path) {
      let i = path.length;
      if (i < 2) return "";
      while (--i > 1) if (slash(path, i)) break;
      return path.slice(0, i);
    }

    // Slashes can be escaped; to determine whether a slash is a path delimiter, we
    // count the number of preceding backslashes escaping the forward slash: an odd
    // number indicates an escaped forward slash.
    function slash(path, i) {
      if (path[i] === "/") {
        let k = 0;
        while (i > 0 && path[--i] === "\\") ++k;
        if ((k & 1) === 0) return true;
      }
      return false;
    }

    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }

    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
      var children = v.children;
      return children ? children[0] : v.t;
    }

    // This function works analogously to nextLeft.
    function nextRight(v) {
      var children = v.children;
      return children ? children[children.length - 1] : v.t;
    }

    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }

    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
      var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }

    // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null; // default ancestor
      this.a = this; // ancestor
      this.z = 0; // prelim
      this.m = 0; // mod
      this.c = 0; // change
      this.s = 0; // shift
      this.t = null; // thread
      this.i = i; // number
    }

    TreeNode.prototype = Object.create(Node$1.prototype);

    function treeRoot(root) {
      var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n;

      while (node = nodes.pop()) {
        if (children = node._.children) {
          node.children = new Array(n = children.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
          }
        }
      }

      (tree.parent = new TreeNode(null, 0)).children = [tree];
      return tree;
    }

    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree() {
      var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null;

      function tree(root) {
        var t = treeRoot(root);

        // Compute the layout using Buchheim et al.’s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);

        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);

        // If a fixed tree size is specified, scale x and y based on the extent.
        // Compute the left-most, right-most, and depth-most nodes for extents.
        else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

        return root;
      }

      // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
      // applied recursively to the children of v, as well as the function
      // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
      // node v is placed to the midpoint of its outermost children.
      function firstWalk(v) {
        var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null;
        if (children) {
          executeShifts(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }

      // Computes all real x-coordinates by summing up the modifiers recursively.
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }

      // The core of the algorithm. Here, a new subtree is combined with the
      // previous subtrees. Threads are used to traverse the inside and outside
      // contours of the left and right subtree up to the highest common level. The
      // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
      // superscript o means outside and i means inside, the subscript - means left
      // subtree and + means right subtree. For summing up the modifiers along the
      // contour, we use respective variables si+, si-, so-, and so+. Whenever two
      // nodes of the inside contours conflict, we compute the left one of the
      // greatest uncommon ancestors using the function ANCESTOR and call MOVE
      // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
      // Finally, we add a new thread (if necessary).
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }

      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }

      tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
      };

      tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
      };

      tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
      };

      return tree;
    }

    function treemapSlice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi = (1 + Math.sqrt(5)) / 2;

    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx, dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0;

        // Find the next non-empty node.
        do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);

        // Keep adding nodes while the aspect ratio maintains or improves.
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) { sumValue -= nodeValue; break; }
          minRatio = newRatio;
        }

        // Position and record the row orientation.
        rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }

    var squarify = (function custom(ratio) {

      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi);

    function index() {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 =
        root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function(x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$2(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$2(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$2(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$2(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$2(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    function binary(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          i, n = nodes.length,
          sum, sums = new Array(n + 1);

      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes[i].value;
      }

      partition(0, n, parent.value, x0, y0, x1, y1);

      function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
          var node = nodes[i];
          node.x0 = x0, node.y0 = y0;
          node.x1 = x1, node.y1 = y1;
          return;
        }

        var valueOffset = sums[i],
            valueTarget = (value / 2) + valueOffset,
            k = i + 1,
            hi = j - 1;

        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) k = mid + 1;
          else hi = mid;
        }

        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

        var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft;

        if ((x1 - x0) > (y1 - y0)) {
          var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
          partition(i, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
          partition(i, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    }

    function sliceDice(parent, x0, y0, x1, y1) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {

      function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && (rows.ratio === ratio)) {
          var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value;

          while (++j < m) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
            if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
            else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
          rows.ratio = ratio;
        }
      }

      resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return resquarify;
    })(phi);

    function area$1(polygon) {
      var i = -1,
          n = polygon.length,
          a,
          b = polygon[n - 1],
          area = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
      }

      return area / 2;
    }

    function centroid(polygon) {
      var i = -1,
          n = polygon.length,
          x = 0,
          y = 0,
          a,
          b = polygon[n - 1],
          c,
          k = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }

      return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }

    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
      const n = points.length,
          indexes = [0, 1];
      let size = 2, i;

      for (i = 2; i < n; ++i) {
        while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
        indexes[size++] = i;
      }

      return indexes.slice(0, size); // remove popped points
    }

    function hull(points) {
      if ((n = points.length) < 3) return null;

      var i,
          n,
          sortedPoints = new Array(n),
          flippedPoints = new Array(n);

      for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
      sortedPoints.sort(lexicographicOrder);
      for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

      var upperIndexes = computeUpperHullIndexes(sortedPoints),
          lowerIndexes = computeUpperHullIndexes(flippedPoints);

      // Construct the hull polygon, removing possible duplicate endpoints.
      var skipLeft = lowerIndexes[0] === upperIndexes[0],
          skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
          hull = [];

      // Add upper hull in right-to-l order.
      // Then add lower hull in left-to-right order.
      for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
      for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

      return hull;
    }

    function contains$1(polygon, point) {
      var n = polygon.length,
          p = polygon[n - 1],
          x = point[0], y = point[1],
          x0 = p[0], y0 = p[1],
          x1, y1,
          inside = false;

      for (var i = 0; i < n; ++i) {
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
        x0 = x1, y0 = y1;
      }

      return inside;
    }

    function length(polygon) {
      var i = -1,
          n = polygon.length,
          b = polygon[n - 1],
          xa,
          ya,
          xb = b[0],
          yb = b[1],
          perimeter = 0;

      while (++i < n) {
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.hypot(xa, ya);
      }

      return perimeter;
    }

    var defaultSource = Math.random;

    var uniform = (function sourceRandomUniform(source) {
      function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
          return source() * max + min;
        };
      }

      randomUniform.source = sourceRandomUniform;

      return randomUniform;
    })(defaultSource);

    var int = (function sourceRandomInt(source) {
      function randomInt(min, max) {
        if (arguments.length < 2) max = min, min = 0;
        min = Math.floor(min);
        max = Math.floor(max) - min;
        return function() {
          return Math.floor(source() * max + min);
        };
      }

      randomInt.source = sourceRandomInt;

      return randomInt;
    })(defaultSource);

    var normal = (function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y;

          // If available, use the second previously-generated uniform random.
          if (x != null) y = x, x = null;

          // Otherwise, generate a new x and y.
          else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      }

      randomNormal.source = sourceRandomNormal;

      return randomNormal;
    })(defaultSource);

    var logNormal = (function sourceRandomLogNormal(source) {
      var N = normal.source(source);

      function randomLogNormal() {
        var randomNormal = N.apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }

      randomLogNormal.source = sourceRandomLogNormal;

      return randomLogNormal;
    })(defaultSource);

    var irwinHall = (function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        if ((n = +n) <= 0) return () => 0;
        return function() {
          for (var sum = 0, i = n; i > 1; --i) sum += source();
          return sum + i * source();
        };
      }

      randomIrwinHall.source = sourceRandomIrwinHall;

      return randomIrwinHall;
    })(defaultSource);

    var bates = (function sourceRandomBates(source) {
      var I = irwinHall.source(source);

      function randomBates(n) {
        // use limiting distribution at n === 0
        if ((n = +n) === 0) return source;
        var randomIrwinHall = I(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }

      randomBates.source = sourceRandomBates;

      return randomBates;
    })(defaultSource);

    var exponential = (function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log1p(-source()) / lambda;
        };
      }

      randomExponential.source = sourceRandomExponential;

      return randomExponential;
    })(defaultSource);

    var pareto = (function sourceRandomPareto(source) {
      function randomPareto(alpha) {
        if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
        alpha = 1 / -alpha;
        return function() {
          return Math.pow(1 - source(), alpha);
        };
      }

      randomPareto.source = sourceRandomPareto;

      return randomPareto;
    })(defaultSource);

    var bernoulli = (function sourceRandomBernoulli(source) {
      function randomBernoulli(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        return function() {
          return Math.floor(source() + p);
        };
      }

      randomBernoulli.source = sourceRandomBernoulli;

      return randomBernoulli;
    })(defaultSource);

    var geometric = (function sourceRandomGeometric(source) {
      function randomGeometric(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        if (p === 0) return () => Infinity;
        if (p === 1) return () => 1;
        p = Math.log1p(-p);
        return function() {
          return 1 + Math.floor(Math.log1p(-source()) / p);
        };
      }

      randomGeometric.source = sourceRandomGeometric;

      return randomGeometric;
    })(defaultSource);

    var gamma = (function sourceRandomGamma(source) {
      var randomNormal = normal.source(source)();

      function randomGamma(k, theta) {
        if ((k = +k) < 0) throw new RangeError("invalid k");
        // degenerate distribution if k === 0
        if (k === 0) return () => 0;
        theta = theta == null ? 1 : +theta;
        // exponential distribution if k === 1
        if (k === 1) return () => -Math.log1p(-source()) * theta;

        var d = (k < 1 ? k + 1 : k) - 1 / 3,
            c = 1 / (3 * Math.sqrt(d)),
            multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
        return function() {
          do {
            do {
              var x = randomNormal(),
                  v = 1 + c * x;
            } while (v <= 0);
            v *= v * v;
            var u = 1 - source();
          } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));
          return d * v * multiplier() * theta;
        };
      }

      randomGamma.source = sourceRandomGamma;

      return randomGamma;
    })(defaultSource);

    var beta = (function sourceRandomBeta(source) {
      var G = gamma.source(source);

      function randomBeta(alpha, beta) {
        var X = G(alpha),
            Y = G(beta);
        return function() {
          var x = X();
          return x === 0 ? 0 : x / (x + Y());
        };
      }

      randomBeta.source = sourceRandomBeta;

      return randomBeta;
    })(defaultSource);

    var binomial = (function sourceRandomBinomial(source) {
      var G = geometric.source(source),
          B = beta.source(source);

      function randomBinomial(n, p) {
        n = +n;
        if ((p = +p) >= 1) return () => n;
        if (p <= 0) return () => 0;
        return function() {
          var acc = 0, nn = n, pp = p;
          while (nn * pp > 16 && nn * (1 - pp) > 16) {
            var i = Math.floor((nn + 1) * pp),
                y = B(i, nn - i + 1)();
            if (y <= pp) {
              acc += i;
              nn -= i;
              pp = (pp - y) / (1 - y);
            } else {
              nn = i - 1;
              pp /= y;
            }
          }
          var sign = pp < 0.5,
              pFinal = sign ? pp : 1 - pp,
              g = G(pFinal);
          for (var s = g(), k = 0; s <= nn; ++k) s += g();
          return acc + (sign ? k : nn - k);
        };
      }

      randomBinomial.source = sourceRandomBinomial;

      return randomBinomial;
    })(defaultSource);

    var weibull = (function sourceRandomWeibull(source) {
      function randomWeibull(k, a, b) {
        var outerFunc;
        if ((k = +k) === 0) {
          outerFunc = x => -Math.log(x);
        } else {
          k = 1 / k;
          outerFunc = x => Math.pow(x, k);
        }
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * outerFunc(-Math.log1p(-source()));
        };
      }

      randomWeibull.source = sourceRandomWeibull;

      return randomWeibull;
    })(defaultSource);

    var cauchy = (function sourceRandomCauchy(source) {
      function randomCauchy(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * Math.tan(Math.PI * source());
        };
      }

      randomCauchy.source = sourceRandomCauchy;

      return randomCauchy;
    })(defaultSource);

    var logistic = (function sourceRandomLogistic(source) {
      function randomLogistic(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          var u = source();
          return a + b * Math.log(u / (1 - u));
        };
      }

      randomLogistic.source = sourceRandomLogistic;

      return randomLogistic;
    })(defaultSource);

    var poisson = (function sourceRandomPoisson(source) {
      var G = gamma.source(source),
          B = binomial.source(source);

      function randomPoisson(lambda) {
        return function() {
          var acc = 0, l = lambda;
          while (l > 16) {
            var n = Math.floor(0.875 * l),
                t = G(n)();
            if (t > l) return acc + B(n - 1, l / t)();
            acc += n;
            l -= t;
          }
          for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());
          return acc + k;
        };
      }

      randomPoisson.source = sourceRandomPoisson;

      return randomPoisson;
    })(defaultSource);

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const mul = 0x19660D;
    const inc = 0x3C6EF35F;
    const eps = 1 / 0x100000000;

    function lcg(seed = Math.random()) {
      let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
      return () => (state = mul * state + inc | 0, eps * (state >>> 0));
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = range$3(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };

      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), [r0, r1])
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point$6() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$3(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$4(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer$2() {
      var domain = unit,
          range = unit,
          interpolate = interpolate$2,
          transform,
          untransform,
          unknown,
          clamp = identity$3,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$3) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer$2()(identity$3, identity$3);
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear$1() {
      var scale = continuous();

      scale.copy = function() {
        return copy$4(scale, linear$1());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function identity$2(domain) {
      var unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : x;
      }

      scale.invert = scale;

      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return identity$2(domain).unknown(unknown);
      };

      domain = arguments.length ? Array.from(domain, number$1) : [0, 1];

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function transformLog(x) {
      return Math.log(x);
    }

    function transformExp(x) {
      return Math.exp(x);
    }

    function transformLogn(x) {
      return -Math.log(-x);
    }

    function transformExpn(x) {
      return -Math.exp(-x);
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10
          : base === Math.E ? Math.exp
          : x => Math.pow(base, x);
    }

    function logp(base) {
      return base === Math.E ? Math.log
          : base === 10 && Math.log10
          || base === 2 && Math.log2
          || (base = Math.log(base), x => Math.log(x) / base);
    }

    function reflect(f) {
      return (x, k) => -f(-x, k);
    }

    function loggish(transform) {
      const scale = transform(transformLog, transformExp);
      const domain = scale.domain;
      let base = 10;
      let logs;
      let pows;

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }

      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = count => {
        const d = domain();
        let u = d[0];
        let v = d[d.length - 1];
        const r = v < u;

        if (r) ([u, v] = [v, u]);

        let i = logs(u);
        let j = logs(v);
        let k;
        let t;
        const n = count == null ? 10 : +count;
        let z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u > 0) for (; i <= j; ++i) {
            for (k = 1; k < base; ++k) {
              t = i < 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i <= j; ++i) {
            for (k = base - 1; k >= 1; --k) {
              t = i > 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
          if (z.length * 2 < n) z = ticks(u, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }
        return r ? z.reverse() : z;
      };

      scale.tickFormat = (count, specifier) => {
        if (count == null) count = 10;
        if (specifier == null) specifier = base === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
          if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
          specifier = format(specifier);
        }
        if (count === Infinity) return specifier;
        const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return d => {
          let i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = () => {
        return domain(nice(domain(), {
          floor: x => pows(Math.floor(logs(x))),
          ceil: x => pows(Math.ceil(logs(x)))
        }));
      };

      return scale;
    }

    function log() {
      const scale = loggish(transformer$2()).domain([1, 10]);
      scale.copy = () => copy$4(scale, log()).base(scale.base());
      initRange.apply(scale, arguments);
      return scale;
    }

    function transformSymlog(c) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
    }

    function transformSymexp(c) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
    }

    function symlogish(transform) {
      var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
      };

      return linearish(scale);
    }

    function symlog() {
      var scale = symlogish(transformer$2());

      scale.copy = function() {
        return copy$4(scale, symlog()).constant(scale.constant());
      };

      return initRange.apply(scale, arguments);
    }

    function transformPow(exponent) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
    }

    function transformSqrt(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }

    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }

    function powish(transform) {
      var scale = transform(identity$3, identity$3),
          exponent = 1;

      function rescale() {
        return exponent === 1 ? transform(identity$3, identity$3)
            : exponent === 0.5 ? transform(transformSqrt, transformSquare)
            : transform(transformPow(exponent), transformPow(1 / exponent));
      }

      scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
      };

      return linearish(scale);
    }

    function pow$1() {
      var scale = powish(transformer$2());

      scale.copy = function() {
        return copy$4(scale, pow$1()).exponent(scale.exponent());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function sqrt$1() {
      return pow$1.apply(null, arguments).exponent(0.5);
    }

    function square$1(x) {
      return Math.sign(x) * x * x;
    }

    function unsquare(x) {
      return Math.sign(x) * Math.sqrt(Math.abs(x));
    }

    function radial() {
      var squared = continuous(),
          range = [0, 1],
          round = false,
          unknown;

      function scale(x) {
        var y = unsquare(squared(x));
        return isNaN(y) ? unknown : round ? Math.round(y) : y;
      }

      scale.invert = function(y) {
        return squared.invert(square$1(y));
      };

      scale.domain = function(_) {
        return arguments.length ? (squared.domain(_), scale) : squared.domain();
      };

      scale.range = function(_) {
        return arguments.length ? (squared.range((range = Array.from(_, number$1)).map(square$1)), scale) : range.slice();
      };

      scale.rangeRound = function(_) {
        return scale.range(_).round(true);
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, scale) : round;
      };

      scale.clamp = function(_) {
        return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return radial(squared.domain(), range)
            .round(round)
            .clamp(squared.clamp())
            .unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function quantile() {
      var domain = [],
          range = [],
          thresholds = [],
          unknown;

      function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];
      }

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return rescale();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.quantiles = function() {
        return thresholds.slice();
      };

      scale.copy = function() {
        return quantile()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    function quantize() {
      var x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1],
          unknown;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      function rescale() {
        var i = -1;
        domain = new Array(n);
        while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
      };

      scale.range = function(_) {
        return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN]
            : i < 1 ? [x0, domain[0]]
            : i >= n ? [domain[n - 1], x1]
            : [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };

      scale.thresholds = function() {
        return domain.slice();
      };

      scale.copy = function() {
        return quantize()
            .domain([x0, x1])
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(linearish(scale), arguments);
    }

    function threshold() {
      var domain = [0.5],
          range = [0, 1],
          unknown,
          n = 1;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return threshold()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    const t0 = new Date, t1 = new Date;

    function timeInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = (date) => {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = (date) => {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = (date) => {
        const d0 = interval(date), d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = (date, step) => {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = (start, stop, step) => {
        const range = [];
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        let previous;
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = (test) => {
        return timeInterval((date) => {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, (date, step) => {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = (start, end) => {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = (step) => {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? (d) => field(d) % step === 0
                  : (d) => interval.count(0, d) % step === 0);
        };
      }

      return interval;
    }

    const millisecond = timeInterval(() => {
      // noop
    }, (date, step) => {
      date.setTime(+date + step);
    }, (start, end) => {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = (k) => {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return timeInterval((date) => {
        date.setTime(Math.floor(date / k) * k);
      }, (date, step) => {
        date.setTime(+date + step * k);
      }, (start, end) => {
        return (end - start) / k;
      });
    };

    const milliseconds = millisecond.range;

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    const second = timeInterval((date) => {
      date.setTime(date - date.getMilliseconds());
    }, (date, step) => {
      date.setTime(+date + step * durationSecond);
    }, (start, end) => {
      return (end - start) / durationSecond;
    }, (date) => {
      return date.getUTCSeconds();
    });

    const seconds = second.range;

    const timeMinute = timeInterval((date) => {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, (date, step) => {
      date.setTime(+date + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, (date) => {
      return date.getMinutes();
    });

    const timeMinutes = timeMinute.range;

    const utcMinute = timeInterval((date) => {
      date.setUTCSeconds(0, 0);
    }, (date, step) => {
      date.setTime(+date + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, (date) => {
      return date.getUTCMinutes();
    });

    const utcMinutes = utcMinute.range;

    const timeHour = timeInterval((date) => {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, (date, step) => {
      date.setTime(+date + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, (date) => {
      return date.getHours();
    });

    const timeHours = timeHour.range;

    const utcHour = timeInterval((date) => {
      date.setUTCMinutes(0, 0, 0);
    }, (date, step) => {
      date.setTime(+date + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, (date) => {
      return date.getUTCHours();
    });

    const utcHours = utcHour.range;

    const timeDay = timeInterval(
      date => date.setHours(0, 0, 0, 0),
      (date, step) => date.setDate(date.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      date => date.getDate() - 1
    );

    const timeDays = timeDay.range;

    const utcDay = timeInterval((date) => {
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCDate(date.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, (date) => {
      return date.getUTCDate() - 1;
    });

    const utcDays = utcDay.range;

    const unixDay = timeInterval((date) => {
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCDate(date.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, (date) => {
      return Math.floor(date / durationDay);
    });

    const unixDays = unixDay.range;

    function timeWeekday(i) {
      return timeInterval((date) => {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setDate(date.getDate() + step * 7);
      }, (start, end) => {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    const timeSunday = timeWeekday(0);
    const timeMonday = timeWeekday(1);
    const timeTuesday = timeWeekday(2);
    const timeWednesday = timeWeekday(3);
    const timeThursday = timeWeekday(4);
    const timeFriday = timeWeekday(5);
    const timeSaturday = timeWeekday(6);

    const timeSundays = timeSunday.range;
    const timeMondays = timeMonday.range;
    const timeTuesdays = timeTuesday.range;
    const timeWednesdays = timeWednesday.range;
    const timeThursdays = timeThursday.range;
    const timeFridays = timeFriday.range;
    const timeSaturdays = timeSaturday.range;

    function utcWeekday(i) {
      return timeInterval((date) => {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, (start, end) => {
        return (end - start) / durationWeek;
      });
    }

    const utcSunday = utcWeekday(0);
    const utcMonday = utcWeekday(1);
    const utcTuesday = utcWeekday(2);
    const utcWednesday = utcWeekday(3);
    const utcThursday = utcWeekday(4);
    const utcFriday = utcWeekday(5);
    const utcSaturday = utcWeekday(6);

    const utcSundays = utcSunday.range;
    const utcMondays = utcMonday.range;
    const utcTuesdays = utcTuesday.range;
    const utcWednesdays = utcWednesday.range;
    const utcThursdays = utcThursday.range;
    const utcFridays = utcFriday.range;
    const utcSaturdays = utcSaturday.range;

    const timeMonth = timeInterval((date) => {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setMonth(date.getMonth() + step);
    }, (start, end) => {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, (date) => {
      return date.getMonth();
    });

    const timeMonths = timeMonth.range;

    const utcMonth = timeInterval((date) => {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, (start, end) => {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, (date) => {
      return date.getUTCMonth();
    });

    const utcMonths = utcMonth.range;

    const timeYear = timeInterval((date) => {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setFullYear(date.getFullYear() + step);
    }, (start, end) => {
      return end.getFullYear() - start.getFullYear();
    }, (date) => {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    timeYear.every = (k) => {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    const timeYears = timeYear.range;

    const utcYear = timeInterval((date) => {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, (date, step) => {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, (start, end) => {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, (date) => {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = (k) => {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, (date, step) => {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    const utcYears = utcYear.range;

    function ticker(year, month, week, day, hour, minute) {

      const tickIntervals = [
        [second,  1,      durationSecond],
        [second,  5,  5 * durationSecond],
        [second, 15, 15 * durationSecond],
        [second, 30, 30 * durationSecond],
        [minute,  1,      durationMinute],
        [minute,  5,  5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [  hour,  1,      durationHour  ],
        [  hour,  3,  3 * durationHour  ],
        [  hour,  6,  6 * durationHour  ],
        [  hour, 12, 12 * durationHour  ],
        [   day,  1,      durationDay   ],
        [   day,  2,  2 * durationDay   ],
        [  week,  1,      durationWeek  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }

      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }

      return [ticks, tickInterval];
    }

    const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
    const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
              week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
              week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
              week = timeDay.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + timeDay.count(timeYear(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    var formatIso$1 = formatIso;

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    var parseIso$1 = parseIso;

    function date(t) {
      return new Date(t);
    }

    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };

      scale.ticks = function(interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };

      scale.copy = function() {
        return copy$4(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };

      return scale;
    }

    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$1() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$3,
          clamp = false,
          unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy$3(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$1()(identity$3));

      scale.copy = function() {
        return copy$3(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialLog() {
      var scale = loggish(transformer$1()).domain([1, 10]);

      scale.copy = function() {
        return copy$3(scale, sequentialLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSymlog() {
      var scale = symlogish(transformer$1());

      scale.copy = function() {
        return copy$3(scale, sequentialSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialPow() {
      var scale = powish(transformer$1());

      scale.copy = function() {
        return copy$3(scale, sequentialPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }

    function sequentialQuantile() {
      var domain = [],
          interpolator = identity$3;

      function scale(x) {
        if (x != null && !isNaN(x = +x)) return interpolator((bisect(domain, x, 1) - 1) / (domain.length - 1));
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return scale;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.range = function() {
        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
      };

      scale.quantiles = function(n) {
        return Array.from({length: n + 1}, (_, i) => quantile$1(domain, i / n));
      };

      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };

      return initInterpolator.apply(scale, arguments);
    }

    function transformer() {
      var x0 = 0,
          x1 = 0.5,
          x2 = 1,
          s = 1,
          t0,
          t1,
          t2,
          k10,
          k21,
          interpolator = identity$3,
          transform,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
        return scale;
      };
    }

    function diverging$1() {
      var scale = linearish(transformer()(identity$3));

      scale.copy = function() {
        return copy$3(scale, diverging$1());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingLog() {
      var scale = loggish(transformer()).domain([0.1, 1, 10]);

      scale.copy = function() {
        return copy$3(scale, divergingLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSymlog() {
      var scale = symlogish(transformer());

      scale.copy = function() {
        return copy$3(scale, divergingSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingPow() {
      var scale = powish(transformer());

      scale.copy = function() {
        return copy$3(scale, divergingPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var observable10 = colors("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

    var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    var ramp$1 = scheme => rgbBasis(scheme[scheme.length - 1]);

    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    var BrBG = ramp$1(scheme$q);

    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    var PRGn = ramp$1(scheme$p);

    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    var PiYG = ramp$1(scheme$o);

    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    var PuOr = ramp$1(scheme$n);

    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    var RdBu = ramp$1(scheme$m);

    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    var RdGy = ramp$1(scheme$l);

    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    var RdYlBu = ramp$1(scheme$k);

    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    var RdYlGn = ramp$1(scheme$j);

    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    var Spectral = ramp$1(scheme$i);

    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    var BuGn = ramp$1(scheme$h);

    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    var BuPu = ramp$1(scheme$g);

    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    var GnBu = ramp$1(scheme$f);

    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    var OrRd = ramp$1(scheme$e);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    var PuBuGn = ramp$1(scheme$d);

    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    var PuBu = ramp$1(scheme$c);

    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    var PuRd = ramp$1(scheme$b);

    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    var RdPu = ramp$1(scheme$a);

    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    var YlGnBu = ramp$1(scheme$9);

    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    var YlGn = ramp$1(scheme$8);

    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    var YlOrBr = ramp$1(scheme$7);

    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    var YlOrRd = ramp$1(scheme$6);

    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    var Blues = ramp$1(scheme$5);

    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    var Greens = ramp$1(scheme$4);

    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    var Greys = ramp$1(scheme$3);

    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    var Purples = ramp$1(scheme$2);

    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    var Reds = ramp$1(scheme$1);

    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    var Oranges = ramp$1(scheme);

    function cividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
          + ")";
    }

    var cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0.0), cubehelix$3(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var c$2 = cubehelix$3();

    function rainbow(t) {
      if (t < 0 || t > 1) t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }

    function turbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
          + ")";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$1(x) {
      return function constant() {
        return x;
      };
    }

    const abs = Math.abs;
    const atan2 = Math.atan2;
    const cos$1 = Math.cos;
    const max$1 = Math.max;
    const min$1 = Math.min;
    const sin$1 = Math.sin;
    const sqrt = Math.sqrt;

    const epsilon = 1e-12;
    const pi = Math.PI;
    const halfPi = pi / 2;
    const tau$1 = 2 * pi;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
    }

    function withPath(shape) {
      let digits = 3;

      shape.digits = function(_) {
        if (!arguments.length) return digits;
        if (_ == null) {
          digits = null;
        } else {
          const d = Math.floor(_);
          if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        return shape;
      };

      return () => new Path$1(digits);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt(max$1(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$1(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null,
          path = withPath(arc);

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi,
            a1 = endAngle.apply(this, arguments) - halfPi,
            da = abs(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau$1 - epsilon) {
          context.moveTo(r1 * cos$1(a0), r1 * sin$1(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon) {
            context.moveTo(r0 * cos$1(a1), r0 * sin$1(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
              rc = min$1(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon) {
            var p0 = asin(rp / r0 * sin$1(ap)),
                p1 = asin(rp / r1 * sin$1(ap));
            if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos$1(a01),
              y01 = r1 * sin$1(a01),
              x10 = r0 * cos$1(a10),
              y10 = r0 * sin$1(a10);

          // Apply rounded corners?
          if (rc > epsilon) {
            var x11 = r1 * cos$1(a11),
                y11 = r1 * sin$1(a11),
                x00 = r0 * cos$1(a00),
                y00 = r0 * sin$1(a00),
                oc;

            // Restrict the corner radius according to the sector angle. If this
            // intersection fails, it’s probably because the arc is too small, so
            // disable the corner radius entirely.
            if (da < pi) {
              if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
                var ax = x01 - oc[0],
                    ay = y01 - oc[1],
                    bx = x11 - oc[0],
                    by = y11 - oc[1],
                    kc = 1 / sin$1(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                    lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = min$1(rc, (r0 - lc) / (kc - 1));
                rc1 = min$1(rc, (r1 - lc) / (kc + 1));
              } else {
                rc0 = rc1 = 0;
              }
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
        return [cos$1(a) * r, sin$1(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    var slice$1 = Array.prototype.slice;

    function array(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x(p) {
      return p[0];
    }

    function y(p) {
      return p[1];
    }

    function line$1(x$1, y$1) {
      var defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null,
          path = withPath(line);

      x$1 = typeof x$1 === "function" ? x$1 : (x$1 === undefined) ? x : constant$1(x$1);
      y$1 = typeof y$1 === "function" ? y$1 : (y$1 === undefined) ? y : constant$1(y$1);

      function line(data) {
        var i,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), line) : x$1;
      };

      line.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), line) : y$1;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area(x0, y0, y1) {
      var x1 = null,
          defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null,
          path = withPath(area);

      x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x : constant$1(+x0);
      y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$1(0) : constant$1(+y0);
      y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y : constant$1(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line$1().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$1(d) {
      return d;
    }

    function pie() {
      var value = identity$1,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$1(0),
          endAngle = constant$1(tau$1),
          padAngle = constant$1(0);

      function pie(data) {
        var i,
            n = (data = array(data)).length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : padAngle;
      };

      return pie;
    }

    var curveRadialLinear = curveRadial(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(line$1().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = area().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return a;
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    class Bump {
      constructor(context, x) {
        this._context = context;
        this._x = x;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x, y);
            else this._context.moveTo(x, y);
            break;
          }
          case 1: this._point = 2; // falls through
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
            break;
          }
        }
        this._x0 = x, this._y0 = y;
      }
    }

    class BumpRadial {
      constructor(context) {
        this._context = context;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {}
      point(x, y) {
        x = +x, y = +y;
        if (this._point === 0) {
          this._point = 1;
        } else {
          const p0 = pointRadial(this._x0, this._y0);
          const p1 = pointRadial(this._x0, this._y0 = (this._y0 + y) / 2);
          const p2 = pointRadial(x, this._y0);
          const p3 = pointRadial(x, y);
          this._context.moveTo(...p0);
          this._context.bezierCurveTo(...p1, ...p2, ...p3);
        }
        this._x0 = x, this._y0 = y;
      }
    }

    function bumpX(context) {
      return new Bump(context, true);
    }

    function bumpY(context) {
      return new Bump(context, false);
    }

    function bumpRadial(context) {
      return new BumpRadial(context);
    }

    function linkSource(d) {
      return d.source;
    }

    function linkTarget(d) {
      return d.target;
    }

    function link(curve) {
      let source = linkSource,
          target = linkTarget,
          x$1 = x,
          y$1 = y,
          context = null,
          output = null,
          path = withPath(link);

      function link() {
        let buffer;
        const argv = slice$1.call(arguments);
        const s = source.apply(this, argv);
        const t = target.apply(this, argv);
        if (context == null) output = curve(buffer = path());
        output.lineStart();
        argv[0] = s, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
        argv[0] = t, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
        output.lineEnd();
        if (buffer) return output = null, buffer + "" || null;
      }

      link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
      };

      link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
      };

      link.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), link) : x$1;
      };

      link.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), link) : y$1;
      };

      link.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
      };

      return link;
    }

    function linkHorizontal() {
      return link(bumpX);
    }

    function linkVertical() {
      return link(bumpY);
    }

    function linkRadial() {
      const l = link(bumpRadial);
      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;
      return l;
    }

    const sqrt3$2 = sqrt(3);

    var asterisk = {
      draw(context, size) {
        const r = sqrt(size + min$1(size / 28, 0.75)) * 0.59436;
        const t = r / 2;
        const u = t * sqrt3$2;
        context.moveTo(0, r);
        context.lineTo(0, -r);
        context.moveTo(-u, -t);
        context.lineTo(u, t);
        context.moveTo(-u, t);
        context.lineTo(u, -t);
      }
    };

    var circle$1 = {
      draw(context, size) {
        const r = sqrt(size / pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau$1);
      }
    };

    var cross = {
      draw(context, size) {
        const r = sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    const tan30 = sqrt(1 / 3);
    const tan30_2 = tan30 * 2;

    var diamond = {
      draw(context, size) {
        const y = sqrt(size / tan30_2);
        const x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var diamond2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.62625;
        context.moveTo(0, -r);
        context.lineTo(r, 0);
        context.lineTo(0, r);
        context.lineTo(-r, 0);
        context.closePath();
      }
    };

    var plus = {
      draw(context, size) {
        const r = sqrt(size - min$1(size / 7, 2)) * 0.87559;
        context.moveTo(-r, 0);
        context.lineTo(r, 0);
        context.moveTo(0, r);
        context.lineTo(0, -r);
      }
    };

    var square = {
      draw(context, size) {
        const w = sqrt(size);
        const x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var square2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.4431;
        context.moveTo(r, r);
        context.lineTo(r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, r);
        context.closePath();
      }
    };

    const ka = 0.89081309152928522810;
    const kr = sin$1(pi / 10) / sin$1(7 * pi / 10);
    const kx = sin$1(tau$1 / 10) * kr;
    const ky = -cos$1(tau$1 / 10) * kr;

    var star = {
      draw(context, size) {
        const r = sqrt(size * ka);
        const x = kx * r;
        const y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (let i = 1; i < 5; ++i) {
          const a = tau$1 * i / 5;
          const c = cos$1(a);
          const s = sin$1(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    const sqrt3$1 = sqrt(3);

    var triangle = {
      draw(context, size) {
        const y = -sqrt(size / (sqrt3$1 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3$1 * y, -y);
        context.lineTo(sqrt3$1 * y, -y);
        context.closePath();
      }
    };

    const sqrt3 = sqrt(3);

    var triangle2 = {
      draw(context, size) {
        const s = sqrt(size) * 0.6824;
        const t = s  / 2;
        const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
        context.moveTo(0, -s);
        context.lineTo(u, t);
        context.lineTo(-u, t);
        context.closePath();
      }
    };

    const c = -0.5;
    const s$1 = sqrt(3) / 2;
    const k = 1 / sqrt(12);
    const a = (k / 2 + 1) * 3;

    var wye = {
      draw(context, size) {
        const r = sqrt(size / a);
        const x0 = r / 2, y0 = r * k;
        const x1 = x0, y1 = r * k + r;
        const x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s$1 * y0, s$1 * x0 + c * y0);
        context.lineTo(c * x1 - s$1 * y1, s$1 * x1 + c * y1);
        context.lineTo(c * x2 - s$1 * y2, s$1 * x2 + c * y2);
        context.lineTo(c * x0 + s$1 * y0, c * y0 - s$1 * x0);
        context.lineTo(c * x1 + s$1 * y1, c * y1 - s$1 * x1);
        context.lineTo(c * x2 + s$1 * y2, c * y2 - s$1 * x2);
        context.closePath();
      }
    };

    var times = {
      draw(context, size) {
        const r = sqrt(size - min$1(size / 6, 1.7)) * 0.6189;
        context.moveTo(-r, -r);
        context.lineTo(r, r);
        context.moveTo(-r, r);
        context.lineTo(r, -r);
      }
    };

    // These symbols are designed to be filled.
    const symbolsFill = [
      circle$1,
      cross,
      diamond,
      square,
      star,
      triangle,
      wye
    ];

    // These symbols are designed to be stroked (with a width of 1.5px and round caps).
    const symbolsStroke = [
      circle$1,
      plus,
      times,
      triangle2,
      asterisk,
      square2,
      diamond2
    ];

    function Symbol$1(type, size) {
      let context = null,
          path = withPath(symbol);

      type = typeof type === "function" ? type : constant$1(type || circle$1);
      size = typeof size === "function" ? size : constant$1(size === undefined ? 64 : +size);

      function symbol() {
        let buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$1(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$1(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop() {}

    function point$5(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$5(this, this._x1, this._y1); // falls through
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
          default: point$5(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$5(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // falls through
          default: point$5(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisOpen(context) {
      return new BasisOpen(context);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var bundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$4(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$4(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // falls through
          default: point$4(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var curveCardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$4(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var curveCardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$4(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function point$3(that, x, y) {
      var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2;

      if (that._l01_a > epsilon) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }

      if (that._l23_a > epsilon) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
      }

      that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }

    function CatmullRom(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: this.point(this._x2, this._y2); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; // falls through
          default: point$3(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRom = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$3(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomClosed = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$3(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomOpen = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function linearClosed(context) {
      return new LinearClosed(context);
    }

    function sign$2(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3$2(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign$2(s0) + sign$2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2$2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point$2(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point$2(this, this._t0, slope2$2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point$2(this, slope2$2(this, t1 = slope3$2(this, x, y)), t1); break;
          default: point$2(this, this._t0, t1 = slope3$2(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function monotoneY(context) {
      return new MonotoneY(context);
    }

    function Natural(context) {
      this._context = context;
    }

    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            n = x.length;

        if (n) {
          this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
          if (n === 2) {
            this._context.lineTo(x[1], y[1]);
          } else {
            var px = controlPoints(x),
                py = controlPoints(y);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
          }
        }

        if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
      var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
      a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
      for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
      a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
      for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
      a[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
      b[n - 1] = (x[n] + a[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
      return [a, b];
    }

    function natural(context) {
      return new Natural(context);
    }

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function step(context) {
      return new Step(context, 0.5);
    }

    function stepBefore(context) {
      return new Step(context, 0);
    }

    function stepAfter(context) {
      return new Step(context, 1);
    }

    function none$1(series, order) {
      if (!((n = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }

    function none(series) {
      var n = series.length, o = new Array(n);
      while (--n >= 0) o[n] = n;
      return o;
    }

    function stackValue(d, key) {
      return d[key];
    }

    function stackSeries(key) {
      const series = [];
      series.key = key;
      return series;
    }

    function stack() {
      var keys = constant$1([]),
          order = none,
          offset = none$1,
          value = stackValue;

      function stack(data) {
        var sz = Array.from(keys.apply(this, arguments), stackSeries),
            i, n = sz.length, j = -1,
            oz;

        for (const d of data) {
          for (i = 0, ++j; i < n; ++i) {
            (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          }
        }

        for (i = 0, oz = array(order(sz)); i < n; ++i) {
          sz[oz[i]].index = i;
        }

        offset(sz, oz);
        return sz;
      }

      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys;
      };

      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
      };

      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order;
      };

      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
      };

      return stack;
    }

    function expand(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
        for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
        if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
      }
      none$1(series, order);
    }

    function diverging(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
        for (yp = yn = 0, i = 0; i < n; ++i) {
          if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
            d[0] = yp, d[1] = yp += dy;
          } else if (dy < 0) {
            d[1] = yn, d[0] = yn += dy;
          } else {
            d[0] = 0, d[1] = dy;
          }
        }
      }
    }

    function silhouette(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
        for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
      }
      none$1(series, order);
    }

    function wiggle(series, order) {
      if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
      for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
          var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2;
          for (var k = 0; k < i; ++k) {
            var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      none$1(series, order);
    }

    function appearance(series) {
      var peaks = series.map(peak);
      return none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
    }

    function peak(series) {
      var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
      while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
      return j;
    }

    function ascending(series) {
      var sums = series.map(sum);
      return none(series).sort(function(a, b) { return sums[a] - sums[b]; });
    }

    function sum(series) {
      var s = 0, i = -1, n = series.length, v;
      while (++i < n) if (v = +series[i][1]) s += v;
      return s;
    }

    function descending(series) {
      return ascending(series).reverse();
    }

    function insideOut(series) {
      var n = series.length,
          i,
          j,
          sums = series.map(sum),
          order = appearance(series),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = [];

      for (i = 0; i < n; ++i) {
        j = order[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }

      return bottoms.reverse().concat(tops);
    }

    function reverse(series) {
      return none(series).reverse();
    }

    var constant = x => () => x;

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        transform: {value: transform, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    var identity = new Transform(1, 0, 0);

    transform.prototype = Transform.prototype;

    function transform(node) {
      while (!node.__zoom) if (!(node = node.parentNode)) return identity;
      return node.__zoom;
    }

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }

    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }

    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity;
    }

    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }

    function zoom() {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchfirst,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0,
          tapDistance = 10;

      function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled, {passive: false})
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
          .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function(collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function() {
            gesture(this, arguments)
              .event(event)
              .start()
              .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
              .end();
          });
        }
      };

      zoom.scaleBy = function(selection, k, p, event) {
        zoom.scaleTo(selection, function() {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };

      zoom.scaleTo = function(selection, k, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };

      zoom.translateBy = function(selection, x, y, event) {
        zoom.transform(selection, function() {
          return constrain(this.__zoom.translate(
            typeof x === "function" ? x.apply(this, arguments) : x,
            typeof y === "function" ? y.apply(this, arguments) : y
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };

      zoom.translateTo = function(selection, x, y, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x === "function" ? -x.apply(this, arguments) : -x,
            typeof y === "function" ? -y.apply(this, arguments) : -y
          ), e, translateExtent);
        }, p, event);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point, event) {
        transition
            .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
            .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
            .tween("zoom", function() {
              var that = this,
                  args = arguments,
                  g = gesture(that, args).event(event),
                  e = extent.apply(that, args),
                  p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                  a = that.__zoom,
                  b = typeof transform === "function" ? transform.apply(that, args) : transform,
                  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
                g.zoom(null, t);
              };
            });
      }

      function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        event: function(event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = pointer(event);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event won’t trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
            g = gesture(this, args, true).event(event),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = pointer(event, currentTarget),
            x0 = event.clientX,
            y0 = event.clientY;

        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved(event) {
          noevent(event);
          if (!g.moved) {
            var dx = event.clientX - x0, dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event)
           .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }

      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
        else select(this).call(zoom.transform, t1, p0, event);
      }

      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, args, event.changedTouches.length === n).event(event),
            started, i, t, p;

        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t, p, l;

        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
          else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1],
              p1 = g.touch1[0], l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;

        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t;

        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }

      zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
      };

      zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
      };

      zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
      };

      zoom.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      zoom.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };

      return zoom;
    }

    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Adder: Adder,
        Delaunay: Delaunay,
        FormatSpecifier: FormatSpecifier,
        InternMap: InternMap,
        InternSet: InternSet,
        Node: Node$1,
        Path: Path$1,
        Voronoi: Voronoi,
        ZoomTransform: Transform,
        active: active,
        arc: arc,
        area: area,
        areaRadial: areaRadial,
        ascending: ascending$3,
        autoType: autoType,
        axisBottom: axisBottom,
        axisLeft: axisLeft,
        axisRight: axisRight,
        axisTop: axisTop,
        bin: bin,
        bisect: bisect,
        bisectCenter: bisectCenter,
        bisectLeft: bisectLeft,
        bisectRight: bisectRight,
        bisector: bisector,
        blob: blob,
        blur: blur$1,
        blur2: blur2,
        blurImage: blurImage,
        brush: brush,
        brushSelection: brushSelection,
        brushX: brushX,
        brushY: brushY,
        buffer: buffer,
        chord: chord,
        chordDirected: chordDirected,
        chordTranspose: chordTranspose,
        cluster: cluster,
        color: color$1,
        contourDensity: density,
        contours: Contours,
        count: count$1,
        create: create$1,
        creator: creator,
        cross: cross$2,
        csv: csv,
        csvFormat: csvFormat,
        csvFormatBody: csvFormatBody,
        csvFormatRow: csvFormatRow,
        csvFormatRows: csvFormatRows,
        csvFormatValue: csvFormatValue,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        cubehelix: cubehelix$3,
        cumsum: cumsum,
        curveBasis: basis,
        curveBasisClosed: basisClosed,
        curveBasisOpen: basisOpen,
        curveBumpX: bumpX,
        curveBumpY: bumpY,
        curveBundle: bundle,
        curveCardinal: curveCardinal,
        curveCardinalClosed: curveCardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCatmullRom: catmullRom,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveLinear: curveLinear,
        curveLinearClosed: linearClosed,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        descending: descending$2,
        deviation: deviation,
        difference: difference,
        disjoint: disjoint,
        dispatch: dispatch,
        drag: drag,
        dragDisable: dragDisable,
        dragEnable: yesdrag,
        dsv: dsv,
        dsvFormat: dsvFormat,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackInOut: backInOut,
        easeBackOut: backOut,
        easeBounce: bounceOut$1,
        easeBounceIn: bounceIn,
        easeBounceInOut: bounceInOut,
        easeBounceOut: bounceOut$1,
        easeCircle: circleInOut,
        easeCircleIn: circleIn,
        easeCircleInOut: circleInOut,
        easeCircleOut: circleOut,
        easeCubic: cubicInOut,
        easeCubicIn: cubicIn,
        easeCubicInOut: cubicInOut,
        easeCubicOut: cubicOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticInOut: elasticInOut,
        easeElasticOut: elasticOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpInOut: expInOut,
        easeExpOut: expOut,
        easeLinear: linear$2,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyInOut: polyInOut,
        easePolyOut: polyOut,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadInOut: quadInOut,
        easeQuadOut: quadOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinInOut: sinInOut,
        easeSinOut: sinOut,
        every: every,
        extent: extent$1,
        fcumsum: fcumsum,
        filter: filter$1,
        flatGroup: flatGroup,
        flatRollup: flatRollup,
        forceCenter: center,
        forceCollide: collide,
        forceLink: link$2,
        forceManyBody: manyBody,
        forceRadial: radial$1,
        forceSimulation: simulation,
        forceX: x$1,
        forceY: y$1,
        get format () { return format; },
        formatDefaultLocale: defaultLocale$1,
        formatLocale: formatLocale$1,
        get formatPrefix () { return formatPrefix; },
        formatSpecifier: formatSpecifier,
        fsum: fsum,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoArea: area$2,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
        geoBounds: bounds,
        geoCentroid: centroid$1,
        geoCircle: circle$2,
        geoClipAntimeridian: clipAntimeridian,
        geoClipCircle: clipCircle,
        geoClipExtent: extent,
        geoClipRectangle: clipRectangle,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoContains: contains$2,
        geoDistance: distance,
        geoEqualEarth: equalEarth,
        geoEqualEarthRaw: equalEarthRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoIdentity: identity$4,
        geoInterpolate: interpolate,
        geoLength: length$1,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoPath: index$2,
        geoProjection: projection,
        geoProjectionMutator: projectionMutator,
        geoRotation: rotation,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoStream: geoStream,
        geoTransform: transform$1,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        gray: gray,
        greatest: greatest,
        greatestIndex: greatestIndex,
        group: group,
        groupSort: groupSort,
        groups: groups,
        hcl: hcl$2,
        hierarchy: hierarchy,
        histogram: bin,
        hsl: hsl$2,
        html: html,
        image: image,
        index: index$4,
        indexes: indexes,
        interpolate: interpolate$2,
        interpolateArray: array$3,
        interpolateBasis: basis$2,
        interpolateBasisClosed: basisClosed$1,
        interpolateBlues: Blues,
        interpolateBrBG: BrBG,
        interpolateBuGn: BuGn,
        interpolateBuPu: BuPu,
        interpolateCividis: cividis,
        interpolateCool: cool,
        interpolateCubehelix: cubehelix$2,
        interpolateCubehelixDefault: cubehelix,
        interpolateCubehelixLong: cubehelixLong,
        interpolateDate: date$1,
        interpolateDiscrete: discrete,
        interpolateGnBu: GnBu,
        interpolateGreens: Greens,
        interpolateGreys: Greys,
        interpolateHcl: hcl$1,
        interpolateHclLong: hclLong,
        interpolateHsl: hsl$1,
        interpolateHslLong: hslLong,
        interpolateHue: hue,
        interpolateInferno: inferno,
        interpolateLab: lab,
        interpolateMagma: magma,
        interpolateNumber: interpolateNumber,
        interpolateNumberArray: numberArray,
        interpolateObject: object$1,
        interpolateOrRd: OrRd,
        interpolateOranges: Oranges,
        interpolatePRGn: PRGn,
        interpolatePiYG: PiYG,
        interpolatePlasma: plasma,
        interpolatePuBu: PuBu,
        interpolatePuBuGn: PuBuGn,
        interpolatePuOr: PuOr,
        interpolatePuRd: PuRd,
        interpolatePurples: Purples,
        interpolateRainbow: rainbow,
        interpolateRdBu: RdBu,
        interpolateRdGy: RdGy,
        interpolateRdPu: RdPu,
        interpolateRdYlBu: RdYlBu,
        interpolateRdYlGn: RdYlGn,
        interpolateReds: Reds,
        interpolateRgb: interpolateRgb,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateRound: interpolateRound,
        interpolateSinebow: sinebow,
        interpolateSpectral: Spectral,
        interpolateString: interpolateString,
        interpolateTransformCss: interpolateTransformCss,
        interpolateTransformSvg: interpolateTransformSvg,
        interpolateTurbo: turbo,
        interpolateViridis: viridis,
        interpolateWarm: warm,
        interpolateYlGn: YlGn,
        interpolateYlGnBu: YlGnBu,
        interpolateYlOrBr: YlOrBr,
        interpolateYlOrRd: YlOrRd,
        interpolateZoom: interpolateZoom,
        interrupt: interrupt,
        intersection: intersection,
        interval: interval,
        isoFormat: formatIso$1,
        isoParse: parseIso$1,
        json: json,
        lab: lab$1,
        lch: lch,
        least: least,
        leastIndex: leastIndex,
        line: line$1,
        lineRadial: lineRadial$1,
        link: link,
        linkHorizontal: linkHorizontal,
        linkRadial: linkRadial,
        linkVertical: linkVertical,
        local: local$1,
        map: map$2,
        matcher: matcher,
        max: max$4,
        maxIndex: maxIndex,
        mean: mean,
        median: median,
        medianIndex: medianIndex,
        merge: merge,
        min: min$3,
        minIndex: minIndex,
        mode: mode,
        namespace: namespace,
        namespaces: namespaces,
        nice: nice$1,
        now: now$1,
        pack: index$1,
        packEnclose: enclose,
        packSiblings: siblings,
        pairs: pairs,
        partition: partition,
        path: path,
        pathRound: pathRound,
        permute: permute,
        pie: pie,
        piecewise: piecewise,
        pointRadial: pointRadial,
        pointer: pointer,
        pointers: pointers,
        polygonArea: area$1,
        polygonCentroid: centroid,
        polygonContains: contains$1,
        polygonHull: hull,
        polygonLength: length,
        precisionFixed: precisionFixed,
        precisionPrefix: precisionPrefix,
        precisionRound: precisionRound,
        quadtree: quadtree,
        quantile: quantile$1,
        quantileIndex: quantileIndex,
        quantileSorted: quantileSorted,
        quantize: quantize$1,
        quickselect: quickselect,
        radialArea: areaRadial,
        radialLine: lineRadial$1,
        randomBates: bates,
        randomBernoulli: bernoulli,
        randomBeta: beta,
        randomBinomial: binomial,
        randomCauchy: cauchy,
        randomExponential: exponential,
        randomGamma: gamma,
        randomGeometric: geometric,
        randomInt: int,
        randomIrwinHall: irwinHall,
        randomLcg: lcg,
        randomLogNormal: logNormal,
        randomLogistic: logistic,
        randomNormal: normal,
        randomPareto: pareto,
        randomPoisson: poisson,
        randomUniform: uniform,
        randomWeibull: weibull,
        range: range$3,
        rank: rank,
        reduce: reduce,
        reverse: reverse$1,
        rgb: rgb,
        ribbon: ribbon$1,
        ribbonArrow: ribbonArrow,
        rollup: rollup,
        rollups: rollups,
        scaleBand: band,
        scaleDiverging: diverging$1,
        scaleDivergingLog: divergingLog,
        scaleDivergingPow: divergingPow,
        scaleDivergingSqrt: divergingSqrt,
        scaleDivergingSymlog: divergingSymlog,
        scaleIdentity: identity$2,
        scaleImplicit: implicit,
        scaleLinear: linear$1,
        scaleLog: log,
        scaleOrdinal: ordinal,
        scalePoint: point$6,
        scalePow: pow$1,
        scaleQuantile: quantile,
        scaleQuantize: quantize,
        scaleRadial: radial,
        scaleSequential: sequential,
        scaleSequentialLog: sequentialLog,
        scaleSequentialPow: sequentialPow,
        scaleSequentialQuantile: sequentialQuantile,
        scaleSequentialSqrt: sequentialSqrt,
        scaleSequentialSymlog: sequentialSymlog,
        scaleSqrt: sqrt$1,
        scaleSymlog: symlog,
        scaleThreshold: threshold,
        scaleTime: time,
        scaleUtc: utcTime,
        scan: scan,
        schemeAccent: Accent,
        schemeBlues: scheme$5,
        schemeBrBG: scheme$q,
        schemeBuGn: scheme$h,
        schemeBuPu: scheme$g,
        schemeCategory10: category10,
        schemeDark2: Dark2,
        schemeGnBu: scheme$f,
        schemeGreens: scheme$4,
        schemeGreys: scheme$3,
        schemeObservable10: observable10,
        schemeOrRd: scheme$e,
        schemeOranges: scheme,
        schemePRGn: scheme$p,
        schemePaired: Paired,
        schemePastel1: Pastel1,
        schemePastel2: Pastel2,
        schemePiYG: scheme$o,
        schemePuBu: scheme$c,
        schemePuBuGn: scheme$d,
        schemePuOr: scheme$n,
        schemePuRd: scheme$b,
        schemePurples: scheme$2,
        schemeRdBu: scheme$m,
        schemeRdGy: scheme$l,
        schemeRdPu: scheme$a,
        schemeRdYlBu: scheme$k,
        schemeRdYlGn: scheme$j,
        schemeReds: scheme$1,
        schemeSet1: Set1,
        schemeSet2: Set2,
        schemeSet3: Set3,
        schemeSpectral: scheme$i,
        schemeTableau10: Tableau10,
        schemeYlGn: scheme$8,
        schemeYlGnBu: scheme$9,
        schemeYlOrBr: scheme$7,
        schemeYlOrRd: scheme$6,
        select: select,
        selectAll: selectAll,
        selection: selection,
        selector: selector,
        selectorAll: selectorAll,
        shuffle: shuffle$2,
        shuffler: shuffler,
        some: some,
        sort: sort,
        stack: stack,
        stackOffsetDiverging: diverging,
        stackOffsetExpand: expand,
        stackOffsetNone: none$1,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAppearance: appearance,
        stackOrderAscending: ascending,
        stackOrderDescending: descending,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none,
        stackOrderReverse: reverse,
        stratify: stratify,
        style: styleValue,
        subset: subset,
        sum: sum$2,
        superset: superset,
        svg: svg,
        symbol: Symbol$1,
        symbolAsterisk: asterisk,
        symbolCircle: circle$1,
        symbolCross: cross,
        symbolDiamond: diamond,
        symbolDiamond2: diamond2,
        symbolPlus: plus,
        symbolSquare: square,
        symbolSquare2: square2,
        symbolStar: star,
        symbolTimes: times,
        symbolTriangle: triangle,
        symbolTriangle2: triangle2,
        symbolWye: wye,
        symbolX: times,
        symbols: symbolsFill,
        symbolsFill: symbolsFill,
        symbolsStroke: symbolsStroke,
        text: text,
        thresholdFreedmanDiaconis: thresholdFreedmanDiaconis,
        thresholdScott: thresholdScott,
        thresholdSturges: thresholdSturges,
        tickFormat: tickFormat,
        tickIncrement: tickIncrement,
        tickStep: tickStep,
        ticks: ticks,
        timeDay: timeDay,
        timeDays: timeDays,
        get timeFormat () { return timeFormat; },
        timeFormatDefaultLocale: defaultLocale,
        timeFormatLocale: formatLocale,
        timeFriday: timeFriday,
        timeFridays: timeFridays,
        timeHour: timeHour,
        timeHours: timeHours,
        timeInterval: timeInterval,
        timeMillisecond: millisecond,
        timeMilliseconds: milliseconds,
        timeMinute: timeMinute,
        timeMinutes: timeMinutes,
        timeMonday: timeMonday,
        timeMondays: timeMondays,
        timeMonth: timeMonth,
        timeMonths: timeMonths,
        get timeParse () { return timeParse; },
        timeSaturday: timeSaturday,
        timeSaturdays: timeSaturdays,
        timeSecond: second,
        timeSeconds: seconds,
        timeSunday: timeSunday,
        timeSundays: timeSundays,
        timeThursday: timeThursday,
        timeThursdays: timeThursdays,
        timeTickInterval: timeTickInterval,
        timeTicks: timeTicks,
        timeTuesday: timeTuesday,
        timeTuesdays: timeTuesdays,
        timeWednesday: timeWednesday,
        timeWednesdays: timeWednesdays,
        timeWeek: timeSunday,
        timeWeeks: timeSundays,
        timeYear: timeYear,
        timeYears: timeYears,
        timeout: timeout,
        timer: timer,
        timerFlush: timerFlush,
        transition: transition,
        transpose: transpose,
        tree: tree,
        treemap: index,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapResquarify: resquarify,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        tsv: tsv,
        tsvFormat: tsvFormat,
        tsvFormatBody: tsvFormatBody,
        tsvFormatRow: tsvFormatRow,
        tsvFormatRows: tsvFormatRows,
        tsvFormatValue: tsvFormatValue,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        union: union,
        unixDay: unixDay,
        unixDays: unixDays,
        utcDay: utcDay,
        utcDays: utcDays,
        get utcFormat () { return utcFormat; },
        utcFriday: utcFriday,
        utcFridays: utcFridays,
        utcHour: utcHour,
        utcHours: utcHours,
        utcMillisecond: millisecond,
        utcMilliseconds: milliseconds,
        utcMinute: utcMinute,
        utcMinutes: utcMinutes,
        utcMonday: utcMonday,
        utcMondays: utcMondays,
        utcMonth: utcMonth,
        utcMonths: utcMonths,
        get utcParse () { return utcParse; },
        utcSaturday: utcSaturday,
        utcSaturdays: utcSaturdays,
        utcSecond: second,
        utcSeconds: seconds,
        utcSunday: utcSunday,
        utcSundays: utcSundays,
        utcThursday: utcThursday,
        utcThursdays: utcThursdays,
        utcTickInterval: utcTickInterval,
        utcTicks: utcTicks,
        utcTuesday: utcTuesday,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday,
        utcWednesdays: utcWednesdays,
        utcWeek: utcSunday,
        utcWeeks: utcSundays,
        utcYear: utcYear,
        utcYears: utcYears,
        variance: variance,
        window: defaultView,
        xml: xml,
        zip: zip,
        zoom: zoom,
        zoomIdentity: identity,
        zoomTransform: transform
    });

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */


    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    /**
     * ============================================================================
     * MAIN CLASS
     * ============================================================================
     * @hidden
     */
    /**
     * Represents a relative value (percent).
     *
     * The Percent object, can be instantiated using two ways:
     *
     * * Via `new Percent(X)`.
     * * Via `am5.percent(X)`.
     *
     * You can also use shortcut functions for `0%`, `50%`, and `100%`:
     * * `am5.p0`
     * * `am5.p50`
     * * `am5.p100`
     */
    class Percent {
        /**
         * Constructor.
         *
         * @param percent  Percent value
         */
        constructor(percent) {
            /**
             * Value in percent.
             */
            Object.defineProperty(this, "_value", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._value = percent;
        }
        /**
         * Relative value.
         *
         * E.g. 100% is 1, 50% is 0.5, etc.
         *
         * This is useful to apply transformations to other values. E.g.:
         *
         * ```TypeScript
         * let value = 256;
         * let percent = new am5.p50;
         * console.log(value * percent.value); // outputs 128
         * ```
         * ```JavaScript
         * var value = 256;
         * var percent = new am5.p50;
         * console.log(value * percent.value); // outputs 128
         * ```
         *
         * Alternatively, you can use `am5.percent()` helper function:
         *
         * ```TypeScript
         * let value = 256;
         * let percent = am5.p50;
         * console.log(value * percent.value); // outputs 128
         * ```
         * ```JavaScript
         * var value = 256;
         * var percent = am5.p50;
         * console.log(value * percent.value); // outputs 128
         * ```
         *
         * @readonly
         * @return Relative value
         */
        get value() {
            return this._value / 100;
        }
        /**
         * Value in percent.
         *
         * @readonly
         * @return Percent
         */
        get percent() {
            return this._value;
        }
        toString() {
            return "" + this._value + "%";
        }
        interpolate(min, max) {
            return min + (this.value * (max - min));
        }
        static normalize(percent, min, max) {
            if (percent instanceof Percent) {
                return percent;
            }
            else {
                if (min === max) {
                    return new Percent(0);
                }
                else {
                    return new Percent(Math.min(Math.max((percent - min) * (1 / (max - min)), 0), 1) * 100);
                }
            }
        }
    }
    /**
     * Converts numeric percent value to a proper [[Percent]] object.
     *
     * ```TypeScript
     * pieSeries.set("radius", am5.percent(80));
     * ```
     * ```JavaScript
     * pieSeries.set("radius", am5.percent(80));
     * ```
     *
     * @param value  Percent
     * @return Percent object
     */
    function percent(value) {
        return new Percent(value);
    }
    /**
     * A shortcut function to `am5.percent(0)`.
     */
    const p0 = percent(0);
    /**
     * A shortcut function to `am5.percent(100)`.
     */
    const p100 = percent(100);
    /**
     * A shortcut function to `am5.percent(50)`.
     */
    const p50 = percent(50);

    /**
     * A collection of utility functions for various type checks and conversion
     * @hidden
     */
    /**
     * ============================================================================
     * TYPE CHECK
     * ============================================================================
     * @hidden
     */
    /**
     * Returns `true` if value is not a number (NaN).
     *
     * @param value Input value
     * @return Is NaN?
     */
    function isNaN$1(value) {
        return Number(value) !== value;
    }
    /**
     * Returns a type of the value.
     *
     * @param value  Input value
     * @return Type of the value
     * @ignore
     */
    function getType(value) {
        return ({}).toString.call(value);
    }
    /**
     * Asserts that the condition is true.
     *
     * @param condition  Condition to check
     * @param message    Message to display in the error
     * @ignore
     */
    function assert(condition, message = "Assertion failed") {
        if (!condition) {
            throw new Error(message);
        }
    }
    /**
     * ============================================================================
     * QUICK CONVERSION
     * ============================================================================
     * @hidden
     */
    /**
     * Converts any value into a `number`.
     *
     * @param value  Source value
     * @return Number representation of value
     */
    function toNumber(value) {
        if (value != null && !isNumber(value)) {
            let converted = Number(value);
            if (isNaN$1(converted) && isString(value) && value != "") {
                return toNumber(value.replace(/[^0-9.\-]+/g, ''));
            }
            return converted;
        }
        return value;
    }
    /**
     * Converts anything to Date object.
     *
     * @param value  A value of any type
     * @return Date object representing a value
     */
    function toDate(value) {
        if (isDate(value)) {
            // TODO maybe don't create a new Date ?
            return new Date(value);
        }
        else if (isNumber(value)) {
            return new Date(value);
        }
        else {
            // Try converting to number (assuming timestamp)
            let num = Number(value);
            if (!isNumber(num)) {
                return new Date(value);
            }
            else {
                return new Date(num);
            }
        }
    }
    /**
     * Converts numeric value into string. Deals with large or small numbers that
     * would otherwise use exponents.
     *
     * @param value  Numeric value
     * @return Numeric value as string
     */
    function numberToString(value) {
        // TODO handle Infinity and -Infinity
        if (isNaN$1(value)) {
            return "NaN";
        }
        if (value === Infinity) {
            return "Infinity";
        }
        if (value === -Infinity) {
            return "-Infinity";
        }
        // Negative 0
        if ((value === 0) && (1 / value === -Infinity)) {
            return "-0";
        }
        // Preserve negative and deal with absoute values
        let negative = value < 0;
        value = Math.abs(value);
        // TODO test this
        let parsed = /^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + value);
        let digits = parsed[1];
        let decimals = parsed[2] || "";
        let res;
        // Leave the nummber as it is if it does not use exponents
        if (parsed[3] === undefined) {
            res = (decimals === "" ? digits : digits + "." + decimals);
        }
        else {
            let exponent = +parsed[3];
            // Deal with decimals
            if (value < 1) {
                let zeros = exponent - 1;
                res = "0." + repeat("0", zeros) + digits + decimals;
                // Deal with integers
            }
            else {
                let zeros = exponent - decimals.length;
                if (zeros === 0) {
                    res = digits + decimals;
                }
                else if (zeros < 0) {
                    res = digits + decimals.slice(0, zeros) + "." + decimals.slice(zeros);
                }
                else {
                    res = digits + decimals + repeat("0", zeros);
                }
            }
        }
        return negative ? "-" + res : res;
    }
    /**
     * Repeats a `string` number of times as set in `amount`.
     *
     * @ignore Exclude from docs
     * @todo Make this faster
     * @param string  Source string
     * @param amount  Number of times to repeat string
     * @return New string
     */
    function repeat(string, amount) {
        return new Array(amount + 1).join(string);
    }
    /**
     * ============================================================================
     * TYPE CHECK
     * ============================================================================
     * @hidden
     */
    /**
     * Checks if parameter is `Date`.
     *
     * @param value  Input value
     * @return Is Date?
     */
    function isDate(value) {
        return getType(value) === "[object Date]";
    }
    /**
     * Checks if parameter is `string`.
     *
     * @param value  Input value
     * @return Is string?
     */
    function isString(value) {
        return typeof value === "string";
    }
    /**
     * Checks if parameter is `number`.
     *
     * @param value  Input value
     * @return Is number?
     */
    function isNumber(value) {
        return typeof value === "number" && Number(value) == value;
    }
    /**
     * Checks if parameter is `object`.
     *
     * @param value  Input value
     * @return Is object?
     */
    function isObject(value) {
        return typeof value === "object" && value !== null;
    }
    /**
     * Checks if parameter is `Array`.
     *
     * @param value  Input value
     * @return Is Array?
     */
    function isArray(value) {
        return Array.isArray(value);
    }
    /**
     * ============================================================================
     * STATIC CONSTANTS
     * ============================================================================
     * @hidden
     */
    /**
     * @ignore Exclude from docs
     */
    const PLACEHOLDER = "__§§§__";
    /**
     * @ignore Exclude from docs
     */
    const PLACEHOLDER2 = "__§§§§__";

    var Type = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PLACEHOLDER: PLACEHOLDER,
        PLACEHOLDER2: PLACEHOLDER2,
        assert: assert,
        getType: getType,
        isArray: isArray,
        isDate: isDate,
        isNaN: isNaN$1,
        isNumber: isNumber,
        isObject: isObject,
        isString: isString,
        numberToString: numberToString,
        repeat: repeat,
        toDate: toDate,
        toNumber: toNumber
    });

    /**
     * ============================================================================
     * UTILITY FUNCTIONS
     * ============================================================================
     * @hidden
     */
    /**
     * Searches `array` for `value`.
     *
     * Returns -1 if not found.
     *
     * @param array  Source array
     * @param value  Value to search
     * @returns Index
     */
    function indexOf(array, value) {
        const length = array.length;
        for (let i = 0; i < length; ++i) {
            // TODO handle NaN
            if (array[i] === value) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Calls `test` for each element in `array`.
     *
     * If `test` returns `true` then it immediately returns `true`.
     *
     * If `test` returns `false` for all of the elements in `array` then it returns `false`.
     *
     * @param array  Source array
     * @param test   Function which is called on each element
     * @returns Whether `test` returned true or not
     */
    function any(array, test) {
        const length = array.length;
        for (let i = 0; i < length; ++i) {
            if (test(array[i])) {
                return true;
            }
        }
        return false;
    }
    /**
     * Calls `fn` function for every member of array and returns a new array out
     * of all outputs.
     *
     * @param array  Source array
     * @param fn     Callback function
     * @returns New array
     */
    function map(array, fn) {
        const length = array.length;
        const output = new Array(length);
        for (let i = 0; i < length; ++i) {
            output[i] = fn(array[i], i);
        }
        return output;
    }
    /**
     * Iterates through all items in array and calls `fn` function for each of
     * them.
     *
     * @param array  Source array
     * @param fn     Callback function
     */
    function each$1(array, fn) {
        const length = array.length;
        for (let i = 0; i < length; ++i) {
            fn(array[i], i);
        }
    }
    /**
     * Iterates through all items in array in reverse order and calls `fn` function for each of
     * them.
     *
     * @param array  Source array
     * @param fn     Callback function
     */
    function eachReverse(array, fn) {
        let i = array.length;
        while (i > 0) {
            --i;
            fn(array[i], i);
        }
    }
    /**
     * Iterates through all items in array and calls `fn` function for each of
     * them.
     *
     * If `fn` call evaluates to `false`, further iteration is cancelled.
     *
     * @param array  Source array
     * @param fn     Callback function
     */
    function eachContinue$1(array, fn) {
        const length = array.length;
        for (let i = 0; i < length; ++i) {
            if (!fn(array[i], i)) {
                break;
            }
        }
    }
    /**
     * Shifts an item at `index` towards beginning of the array.
     *
     * @param array  Source array
     * @param index  Target element index
     */
    function shiftLeft(array, index) {
        const length = array.length;
        for (let i = index; i < length; ++i) {
            array[i - index] = array[i];
        }
        array.length = length - index;
    }
    /**
     * Returns the last item of the array.
     *
     * @param array  Source array
     * @returns Last item
     */
    function last(array) {
        const length = array.length;
        return length ? array[length - 1] : undefined;
    }
    /**
     * Returns the first item of the array.
     *
     * @param array  Source array
     * @returns Last item
     */
    function first(array) {
        return array[0];
    }
    /**
     * Inserts `element` into `array` at `index`.
     *
     * Caps `index` to be between `0` and `array.length`
     *
     * @param array    Source array
     * @param element  Item to insert
     * @param array    Index to insert item at
     */
    function insert(array, element, index) {
        //if (array) {
        index = Math.max(0, Math.min(index, array.length));
        array.splice(index, 0, element);
        //}
    }
    /**
     * Removes all copies of `element` from `array` (if they exist) and then
     * inserts `element` at `index`.
     *
     * @param array    Source array
     * @param element  Item
     * @param array    Index to move item to
     */
    function setIndex(array, element, index) {
        remove(array, element);
        insert(array, element, index);
    }
    /**
     * Pushes all of the elements from `input` into `array`.
     *
     * @param array  Output array
     * @param input  Input array
     */
    function pushAll(array, input) {
        const length = input.length;
        for (let i = 0; i < length; ++i) {
            array.push(input[i]);
        }
    }
    /**
     * Removes `element` from `array`.
     *
     * If there are multiple copies of `element`, they are all removed.
     *
     * @param array    Source array
     * @param element  Item to remove
     */
    function remove(array, element) {
        let found = false;
        let index = 0;
        for (;;) {
            index = array.indexOf(element, index);
            if (index === -1) {
                return found;
            }
            else {
                found = true;
                array.splice(index, 1);
            }
        }
    }
    function removeFirst(array, element) {
        let index = array.indexOf(element);
        if (index !== -1) {
            array.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Adds an `element` to `array`.
     *
     * If array already contains and item like this, it is removed before adding
     * it again.
     *
     * Optionally `toIndex` can be specified to add element at specific index.
     *
     * @param array    Source array
     * @param element  Item to add
     * @param array    Index to move item to
     */
    function move(array, element, toIndex) {
        // @todo this implementation must be the same as the List.moveValue method
        // @todo don't do anything if the desired index is the same as the current index
        let index = indexOf(array, element);
        // @todo remove all old values rather than only the first ?
        if (index !== -1) {
            removeIndex(array, index);
        }
        if (toIndex == null) {
            array.push(element);
        }
        else {
            insertIndex(array, toIndex, element);
        }
    }
    /**
     * Inserts `element` into `array` at `index`.
     *
     * If `index` is not provided, it will insert `element` at the end of `array`.
     *
     * @param array    Source array
     * @param element  Item to add
     * @param array    Index to add item at
     */
    function add$1(array, element, index) {
        // Append to the end if index is not set
        if (!isNumber(index)) {
            array.push(element);
        }
        // Add to the beginning of array if index is 0
        else if (index === 0) {
            array.unshift(element);
        }
        // Add to indicated place if index is set
        else {
            array.splice(index, 0, element);
        }
    }
    /**
     * Pushes `element` into `array` if it doesn't already exist.
     *
     * @param array    Source array
     * @param element  Item to add
     */
    function pushOne(array, element) {
        if (array.indexOf(element) === -1) {
            array.push(element);
        }
    }
    /**
     * Removes `element` from `array` (if it exists) and then inserts `element` at
     * `index`.
     *
     * If `index` is not provided, it will insert `element` at the end of `array`.
     *
     * @param array    Source array
     * @param element  Item to remove
     * @param array    Index to move item to
     */
    function replace(array, element, index) {
        // check if exists
        let ind = array.indexOf(element);
        // remove if exists
        if (ind !== -1) {
            array.splice(ind, 1);
        }
        // add to end if index is not set
        if (!isNumber(index)) {
            array.push(element);
        }
        // add to indicated place if index is set
        else {
            array.splice(index, 0, element);
        }
    }
    /**
     * Wraps `input` in an array, if it isn't already an array.
     *
     * @param input  Source value
     * @return An array
     */
    function toArray(input) {
        if (Array.isArray(input)) {
            return input;
        }
        else {
            return [input];
        }
    }
    /**
     * Returns `true` if `element` exists in `array`.
     *
     * @param array    Source array
     * @param element  Item to search for
     * @returns Item in array?
     */
    function has(array, element) {
        return indexOf(array, element) !== -1;
    }
    /**
     * Returns a shallow copy of `array`.
     *
     * @param array  Source array
     * @returns Copy of the array
     */
    function copy$2(array) {
        const length = array.length;
        // It's faster to create the array with a pre-defined length
        const output = new Array(length);
        for (let i = 0; i < length; ++i) {
            // Because the array has a pre-defined length, we have to assign rather than push
            // This is also faster than pushing
            output[i] = array[i];
        }
        return output;
    }
    /**
     * Returns a copy of `array` which contains all the elements between `start`
     * and `end`. (including `start` and excluding `end`)
     *
     * If `end` is not provided, it defaults to `array.length`.
     *
     * @param array  Source array
     * @param start  Start index
     * @param end    End index
     * @returns Part of the array
     */
    function slice(array, start, end = array.length) {
        const output = new Array(end - start);
        for (let i = start; i < end; ++i) {
            output[i - start] = array[i];
        }
        return output;
    }
    /**
     * Inserts a value into array at specific index.
     *
     * @param array  Source array
     * @param index  Index
     * @param value  Value to insert
     */
    function insertIndex(array, index, value) {
        array.splice(index, 0, value);
    }
    /**
     * Removes a value from array at specific index.
     *
     * @param array  Source array
     * @param index  Index
     */
    function removeIndex(array, index) {
        array.splice(index, 1);
    }
    /**
     * Searches the array using custom function and returns index of the item if
     * found.
     *
     * Will call `matches` function on all items of the array. If return value
     * evaluates to `true`, index is returned.
     *
     * Otherwise returns -1.
     *
     * @param array    Source array
     * @param matches  Search function
     * @returns Index of the item if found
     */
    function findIndex(array, matches) {
        const length = array.length;
        for (let i = 0; i < length; ++i) {
            if (matches(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * This is the same as `findIndex` except it searches from right to left.
     *
     * @param array    Source array
     * @param matches  Search function
     * @returns Index of the item if found
     */
    function findIndexReverse(array, matches) {
        let i = array.length;
        while (i > 0) {
            --i;
            if (matches(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Searches the array using custom function and returns item if found.
     *
     * Will call `matches` function on all items of the array. If return value
     * evaluates to `true`, index is returned.
     *
     * Otherwise returns `undefined`.
     *
     * @param array    Source array
     * @param matches  Search function
     * @returns Item if found
     */
    function find(array, matches) {
        const index = findIndex(array, matches);
        if (index !== -1) {
            return array[index];
        }
    }
    /**
     * This is the same as `find` except it searches from right to left.
     *
     * @param array    Source array
     * @param matches  Search function
     * @returns Item if found
     */
    function findReverse(array, matches) {
        const index = findIndexReverse(array, matches);
        if (index !== -1) {
            return array[index];
        }
    }
    /**
     * Searches the array using custom function and returns item if found.
     *
     * Will call `matches` function on all items of the array. If value
     * is not `undefined`, it returns it.
     *
     * Otherwise returns `undefined`.
     *
     * @param array    Source array
     * @param matches  Search function
     * @returns Item if found
     */
    function findMap(array, matches) {
        const length = array.length;
        for (let i = 0; i < length; ++i) {
            const value = matches(array[i], i);
            if (value !== undefined) {
                return value;
            }
        }
    }
    /**
     * Iterates through all items in array and calls `fn` function for each of
     * them.
     *
     * @param array  Source array
     * @param fn     Callback function
     */
    function shuffle(array) {
        // https://stackoverflow.com/a/2450976/449477
        let currentIndex = array.length, temporaryValue, randomIndex;
        // While there remain elements to shuffle...
        while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;
            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }
    }
    /**
     * Orders an array using specific `ordering` function and returns right-most index of
     * the `value`.
     *
     * @ignore Exclude from docs
     * @param array     Source array
     * @param ordering  An ordering function
     * @returns Result of the search
     */
    function getSortedIndex(array, ordering) {
        let start = 0;
        let end = array.length;
        let found = false;
        while (start < end) {
            // TODO is this faster/slower than using Math.floor ?
            const pivot = (start + end) >> 1;
            const order = ordering(array[pivot]);
            // less
            if (order < 0) {
                start = pivot + 1;
                // equal
            }
            else if (order === 0) {
                found = true;
                start = pivot + 1;
                // more
            }
            else {
                end = pivot;
            }
        }
        return {
            found: found,
            index: (found ? start - 1 : start)
        };
    }
    /**
     * Orders an array using specific `ordering` function and returns left-most index of
     * the `value`.
     *
     * @ignore Exclude from docs
     * @param array     Source array
     * @param ordering  An ordering function
     * @returns Result of the search
     */
    function getFirstSortedIndex(array, ordering) {
        let start = 0;
        let end = array.length;
        let found = false;
        while (start < end) {
            // TODO is this faster/slower than using Math.floor ?
            const pivot = (start + end) >> 1;
            const order = ordering(array[pivot]);
            // less
            if (order < 0) {
                start = pivot + 1;
                // equal
            }
            else if (order === 0) {
                found = true;
                end = pivot;
                // more
            }
            else {
                end = pivot;
            }
        }
        return {
            found: found,
            index: start
        };
    }
    function keepIf(array, keep) {
        let i = array.length;
        while (i > 0) {
            --i;
            if (!keep(array[i])) {
                array.splice(i, 1);
            }
        }
    }

    var Array$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        add: add$1,
        any: any,
        copy: copy$2,
        each: each$1,
        eachContinue: eachContinue$1,
        eachReverse: eachReverse,
        find: find,
        findIndex: findIndex,
        findIndexReverse: findIndexReverse,
        findMap: findMap,
        findReverse: findReverse,
        first: first,
        getFirstSortedIndex: getFirstSortedIndex,
        getSortedIndex: getSortedIndex,
        has: has,
        indexOf: indexOf,
        insert: insert,
        insertIndex: insertIndex,
        keepIf: keepIf,
        last: last,
        map: map,
        move: move,
        pushAll: pushAll,
        pushOne: pushOne,
        remove: remove,
        removeFirst: removeFirst,
        removeIndex: removeIndex,
        replace: replace,
        setIndex: setIndex,
        shiftLeft: shiftLeft,
        shuffle: shuffle,
        slice: slice,
        toArray: toArray
    });

    function keys(object) {
        return Object.keys(object);
    }
    /**
     * Returns an array of object's property names ordered using specific ordering
     * function.
     *
     * @param object  Source object
     * @param order   Ordering function
     * @returns Object property names
     */
    function keysOrdered(object, order) {
        return keys(object).sort(order);
    }
    function copy$1(object) {
        return Object.assign({}, object);
    }
    function each(object, f) {
        keys(object).forEach((key) => {
            f(key, object[key]);
        });
    }
    /**
     * Iterates through all properties of the object calling `fn` for each of them.
     *
     * If return value of the function evaluates to `false` further iteration is
     * cancelled.
     *
     * @param object  Source object
     * @param fn      Callback function
     */
    function eachContinue(object, fn) {
        for (let key in object) {
            if (hasKey(object, key)) {
                if (!fn(key, object[key])) {
                    break;
                }
            }
        }
    }
    /**
     * Orders object properties using custom `ord` function and iterates through
     * them calling `fn` for each of them.
     *
     * @param object  Source object
     * @param fn      Callback function
     * @param order   Ordering function
     */
    function eachOrdered(object, fn, ord) {
        each$1(keysOrdered(object, ord), (key) => {
            fn(key, object[key]);
        });
    }
    /**
     * Checks if `object` has a specific `key`.
     *
     * @param object  Source object
     * @param key     Property name
     * @returns Has key?
     */
    function hasKey(object, key) {
        return {}.hasOwnProperty.call(object, key);
    }
    /**
     * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.
     *
     * @param fromObject  Source object
     * @param toObject    Target object
     * @return Updated target object
     * @todo Maybe consolidate with utils.copy?
     */
    function softCopyProperties(source, target) {
        each(source, (key, value) => {
            // only if value is set
            //if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {
            if (value != null && target[key] == null) {
                target[key] = value;
            }
        });
        return target;
    }

    var Object$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        copy: copy$1,
        each: each,
        eachContinue: eachContinue,
        eachOrdered: eachOrdered,
        hasKey: hasKey,
        keys: keys,
        keysOrdered: keysOrdered,
        softCopyProperties: softCopyProperties
    });

    /**
     * ============================================================================
     * IMPORTS
     * ============================================================================
     * @hidden
     */
    /**
     * A base class for disposable objects.
     *
     * @ignore Exclude from docs
     */
    class DisposerClass {
        /**
         * Constructor.
         */
        constructor() {
            /**
             * Is object disposed?
             */
            Object.defineProperty(this, "_disposed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._disposed = false;
        }
        /**
         * Checks if object is disposed.
         *
         * @return Disposed?
         */
        isDisposed() {
            return this._disposed;
        }
        /**
         * Disposes the object.
         */
        dispose() {
            if (!this._disposed) {
                this._disposed = true;
                this._dispose();
            }
        }
    }
    /**
     * A class for creating an IDisposer.
     *
     * @ignore Exclude from docs
     */
    class Disposer {
        /**
         * Constructor.
         *
         * @param dispose  Function that disposes object
         */
        constructor(dispose) {
            /**
             * Is object disposed?
             */
            Object.defineProperty(this, "_disposed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * Method that disposes the object.
             */
            Object.defineProperty(this, "_dispose", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._disposed = false;
            this._dispose = dispose;
        }
        /**
         * Checks if object is disposed.
         *
         * @return Disposed?
         */
        isDisposed() {
            return this._disposed;
        }
        /**
         * Disposes the object.
         */
        dispose() {
            if (!this._disposed) {
                this._disposed = true;
                this._dispose();
            }
        }
    }
    /**
     * This can be extended by other classes to add a `_disposers` property.
     *
     * @ignore Exclude from docs
     */
    class ArrayDisposer extends DisposerClass {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_disposers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
        }
        _dispose() {
            each$1(this._disposers, (x) => {
                x.dispose();
            });
        }
    }
    /**
     * A collection of related disposers that can be disposed in one go.
     *
     * @ignore Exclude from docs
     */
    class MultiDisposer extends DisposerClass {
        constructor(disposers) {
            super();
            Object.defineProperty(this, "_disposers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._disposers = disposers;
        }
        _dispose() {
            each$1(this._disposers, (x) => {
                x.dispose();
            });
        }
        get disposers() {
            return this._disposers;
        }
    }
    /**
     * A special kind of Disposer that has attached value set.
     *
     * If a new value is set using `set()` method, the old disposer value is
     * disposed.
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    class MutableValueDisposer extends DisposerClass {
        constructor() {
            super(...arguments);
            /**
             * Current disposer.
             */
            Object.defineProperty(this, "_disposer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * Current value.
             */
            Object.defineProperty(this, "_value", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _dispose() {
            if (this._disposer != null) {
                this._disposer.dispose();
                this._disposer = undefined;
            }
        }
        /**
         * Returns current value.
         *
         * @return Value
         */
        get() {
            return this._value;
        }
        /**
         * Sets value and disposes previous disposer if it was set.
         *
         * @param value     New value
         * @param disposer  Disposer
         */
        set(value, disposer) {
            if (this._disposer != null) {
                this._disposer.dispose();
            }
            this._disposer = disposer;
            this._value = value;
        }
        /**
         * Resets the disposer value.
         */
        reset() {
            this.set(undefined, undefined);
        }
    }
    /**
     * @ignore Exclude from docs
     * @todo Description
     */
    class CounterDisposer extends Disposer {
        constructor() {
            super(...arguments);
            /**
             * [_counter description]
             *
             * @todo Description
             */
            Object.defineProperty(this, "_counter", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
        }
        /**
         * [increment description]
         *
         * @todo Description
         */
        increment() {
            // TODO throw an error if it is disposed
            ++this._counter;
            // TODO make this more efficient
            return new Disposer(() => {
                --this._counter;
                if (this._counter === 0) {
                    this.dispose();
                }
            });
        }
    }

    /**
     * ============================================================================
     * DOM FUNCTIONS
     * ============================================================================
     * @hidden
     */
    /**
     * Execute a function when DOM is ready.
     *
     * @since 5.0.2
     * @param  f  Callback
     */
    function ready(f) {
        if (document.readyState !== "loading") {
            f();
        }
        else {
            const listener = () => {
                if (document.readyState !== "loading") {
                    document.removeEventListener("readystatechange", listener);
                    f();
                }
            };
            document.addEventListener("readystatechange", listener);
        }
    }
    /**
     * Removes a DOM element.
     * @param  el  Target element
     */
    function removeElement(el) {
        if (el.parentNode) {
            el.parentNode.removeChild(el);
        }
    }
    /**
     * Function that adds a disposable event listener directly to a DOM element.
     *
     * @ignore Exclude from docs
     * @param dom       A DOM element to add event to
     * @param type      Event type
     * @param listener  Event listener
     * @returns Disposable event
     */
    function addEventListener(dom, type, listener, options) {
        //@todo proper type check for options: EventListenerOptions | boolean (TS for some reason gives error on passive parameter)
        dom.addEventListener(type, listener, options || false);
        return new Disposer(() => {
            dom.removeEventListener(type, listener, options || false);
        });
    }
    /**
     * Function that adds an event listener which is triggered when the browser's zoom changes.
     *
     * @param listener  Event listener
     * @returns Disposable event
     */
    function onZoom(listener) {
        // TODO use matchMedia instead ?
        return addEventListener(window, "resize", (_ev) => {
            listener();
        });
    }
    /**
     * @ignore
     */
    function supports(cap) {
        switch (cap) {
            case "touchevents":
                //return "ontouchstart" in document.documentElement;
                return window.hasOwnProperty("TouchEvent");
            case "pointerevents":
                return window.hasOwnProperty("PointerEvent");
            case "mouseevents":
                return window.hasOwnProperty("MouseEvent");
            case "wheelevents":
                return window.hasOwnProperty("WheelEvent");
            case "keyboardevents":
                return window.hasOwnProperty("KeyboardEvent");
        }
        return false;
    }
    /**
     * @ignore
     */
    function getPointerId(event) {
        let id = event.pointerId || 0;
        return id;
    }
    /**
     * Removes focus from any element by shifting focus to body.
     *
     * @ignore
     */
    function blur() {
        if (document.activeElement && document.activeElement != document.body) {
            if (document.activeElement.blur) {
                document.activeElement.blur();
            }
            else {
                let input = document.createElement("button");
                input.style.position = "fixed";
                input.style.top = "0px";
                input.style.left = "-10000px";
                document.body.appendChild(input);
                input.focus();
                input.blur();
                document.body.removeChild(input);
            }
        }
    }
    /**
     * Focuses element.
     *
     * @ignore
     */
    function focus(el) {
        if (el) {
            el.focus();
        }
    }
    /**
     * @ignore
     */
    function getRendererEvent(key) {
        if (supports("pointerevents")) {
            return key;
        }
        else if (supports("touchevents")) {
            switch (key) {
                case "pointerover": return "touchstart";
                case "pointerout": return "touchend";
                case "pointerleave": return "touchend";
                case "pointerdown": return "touchstart";
                case "pointermove": return "touchmove";
                case "pointerup": return "touchend";
                case "click": return "click";
                case "dblclick": return "dblclick";
            }
        }
        else if (supports("mouseevents")) {
            switch (key) {
                case "pointerover": return "mouseover";
                case "pointerout": return "mouseout";
                case "pointerleave": return "mouseleave";
                case "pointerdown": return "mousedown";
                case "pointermove": return "mousemove";
                case "pointerup": return "mouseup";
                case "click": return "click";
                case "dblclick": return "dblclick";
            }
        }
        return key;
    }
    /**
     * Determines if pointer event originated from a touch pointer or mouse.
     *
     * @param ev  Original event
     * @return Touch pointer?
     */
    function isTouchEvent(ev) {
        if (typeof Touch !== "undefined" && ev instanceof Touch) {
            return true;
        }
        else if (typeof PointerEvent !== "undefined" && ev instanceof PointerEvent && ev.pointerType != null) {
            switch (ev.pointerType) {
                case "touch":
                case "pen":
                case 2:
                    return true;
                case "mouse":
                case 4:
                    return false;
                default:
                    return !(ev instanceof MouseEvent);
            }
        }
        else if (ev.type != null) {
            if (ev.type.match(/^mouse/)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Sets style property on DOM element.
     *
     * @ignore Exclude from docs
     */
    function setStyle(dom, property, value) {
        dom.style[property] = value;
    }
    function getStyle(dom, property) {
        return dom.style[property];
    }
    /**
     * Gets the target of the event, works for shadow DOM too.
     */
    function getEventTarget(event) {
        if (event.composedPath) {
            const path = event.composedPath();
            if (path.length === 0) {
                return null;
            }
            else {
                return path[0];
            }
        }
        else {
            return event.target;
        }
    }
    /**
     * Checks of element `a` contains element `b`.
     *
     * @param a  Aleged ascendant
     * @param b  Aleged descendant
     * @return Contains?
     */
    function contains(a, b) {
        let cursor = b;
        while (true) {
            if (a === cursor) {
                return true;
            }
            else if (cursor.parentNode === null) {
                // TODO better ShadowRoot detection
                if (cursor.host == null) {
                    return false;
                }
                else {
                    cursor = cursor.host;
                }
            }
            else {
                cursor = cursor.parentNode;
            }
        }
    }
    /**
     * Returns `true` if pointer event originated on an element within Root.
     *
     * @since 5.2.8
     * @param  event   Event
     * @param  target  Target element
     */
    function isLocalEvent(event, target) {
        return event.target && contains(target.root.dom, event.target);
    }
    /**
     * Disables or enables interactivity of a DOM element.
     *
     * @param  target       Target element
     * @param  interactive  Interactive?
     */
    function setInteractive(target, interactive) {
        if (interactive) {
            target.style.pointerEvents = "auto";
        }
        else {
            target.style.pointerEvents = "none";
        }
    }
    function getEventKey(event) {
        if (event.key !== undefined) {
            return event.key;
        }
        switch (event.keyCode) {
            case 9: return "Tab";
            case 13: return "Enter";
            case 16: return "Shift";
            case 17: return "Control";
            case 27: return "Escape";
            case 32: return " ";
            case 37: return "ArrowLeft";
            case 38: return "ArrowUp";
            case 39: return "ArrowRight";
            case 40: return "ArrowDown";
            case 46: return "Delete";
        }
        return "" + event.keyCode;
    }
    /**
     * Returns the shadow root of the element or null
     *
     * @param a  Node
     * @return Root
     */
    function getShadowRoot(a) {
        let cursor = a;
        while (true) {
            if (cursor.parentNode === null) {
                // TODO better ShadowRoot detection
                if (cursor.host != null) {
                    return cursor;
                }
                else {
                    return null;
                }
            }
            else {
                cursor = cursor.parentNode;
            }
        }
    }
    /**
     * [rootStylesheet description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    let rootStylesheet;
    /**
     * @ignore Exclude from docs
     */
    function createStylesheet(element, text, nonce = "") {
        // TODO use createElementNS ?
        const e = document.createElement("style");
        e.type = "text/css";
        if (nonce != "") {
            e.setAttribute("nonce", nonce);
        }
        e.textContent = text;
        if (element === null) {
            document.head.appendChild(e);
        }
        else {
            element.appendChild(e);
        }
        return e;
    }
    /**
     * [getStylesheet description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @return [description]
     */
    function getStylesheet(element, nonce = "") {
        if (element === null) {
            if (rootStylesheet == null) {
                // TODO use createElementNS ?
                const e = document.createElement("style");
                e.type = "text/css";
                if (nonce != "") {
                    e.setAttribute("nonce", nonce);
                }
                document.head.appendChild(e);
                rootStylesheet = e.sheet;
            }
            return rootStylesheet;
        }
        else {
            // TODO use createElementNS ?
            const e = document.createElement("style");
            e.type = "text/css";
            if (nonce != "") {
                e.setAttribute("nonce", nonce);
            }
            element.appendChild(e);
            return e.sheet;
        }
    }
    /**
     * [makeStylesheet description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param selector  [description]
     * @return [description]
     */
    function appendStylesheet(root, selector) {
        const index = root.cssRules.length;
        root.insertRule(selector + "{}", index);
        return root.cssRules[index];
    }
    /**
     * Defines a class for a CSS rule.
     *
     * Can be used to dynamically add CSS to the document.
     */
    class StyleRule extends DisposerClass {
        /**
         * Constructor.
         *
         * @param selector  CSS selector
         * @param styles    An object of style attribute - value pairs
         */
        constructor(element, selector, styles, nonce = "") {
            super();
            Object.defineProperty(this, "_root", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * CSS rule.
             */
            Object.defineProperty(this, "_rule", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._root = getStylesheet(element, nonce);
            try {
                this._rule = appendStylesheet(this._root, selector);
            }
            catch (err) {
                // Create an empty rule on failed selectors
                this._rule = appendStylesheet(this._root, ":not(*)");
            }
            each(styles, (key, value) => {
                this.setStyle(key, value);
            });
        }
        /**
         * A CSS selector text.
         *
         * E.g.: `.myClass p`
         *
         * @param selector  CSS selector
         */
        set selector(selector) {
            this._rule.selectorText = selector;
        }
        /**
         * @return CSS selector
         */
        get selector() {
            return this._rule.selectorText;
        }
        // TODO test this
        _dispose() {
            // TODO a bit hacky
            const index = indexOf(this._root.cssRules, this._rule);
            if (index === -1) {
                throw new Error("Could not dispose StyleRule");
            }
            else {
                // TODO if it's empty remove it from the DOM ?
                this._root.deleteRule(index);
            }
        }
        /**
         * Sets the same style properties with browser-specific prefixes.
         *
         * @param name   Attribute name
         * @param value  Attribute value
         */
        _setVendorPrefixName(name, value) {
            const style = this._rule.style;
            style.setProperty("-webkit-" + name, value, "");
            style.setProperty("-moz-" + name, value, "");
            style.setProperty("-ms-" + name, value, "");
            style.setProperty("-o-" + name, value, "");
            style.setProperty(name, value, "");
        }
        /**
         * Sets a value for specific style attribute.
         *
         * @param name   Attribute
         * @param value  Value
         */
        setStyle(name, value) {
            if (name === "transition") {
                this._setVendorPrefixName(name, value);
            }
            else {
                this._rule.style.setProperty(name, value, "");
            }
        }
    }
    /**
     * Defines a class for an entire CSS style sheet.
     *
     * Can be used to dynamically add CSS to the document.
     */
    class StyleSheet extends DisposerClass {
        /**
         * Constructor.
         *
         * @param text  CSS stylesheet
         */
        constructor(element, text, nonce = "") {
            super();
            Object.defineProperty(this, "_element", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._element = createStylesheet(element, text, nonce);
        }
        _dispose() {
            if (this._element.parentNode) {
                this._element.parentNode.removeChild(this._element);
            }
        }
    }
    /**
     * Adds a class name to an HTML or SVG element.
     *
     * @ignore Exclude from docs
     * @param element    Element
     * @param className  Class name to add
     */
    function addClass(element, className) {
        if (!element) {
            return;
        }
        if (element.classList) {
            const classes = className.split(" ");
            each$1(classes, (name) => {
                element.classList.add(name);
            });
        }
        else {
            let currentClassName = element.getAttribute("class");
            if (currentClassName) {
                element.setAttribute("class", currentClassName.split(" ").filter((item) => {
                    return item !== className;
                }).join(" ") + " " + className);
            }
            else {
                element.setAttribute("class", className);
            }
        }
    }
    /**
     * Removes a class name from an HTML or SVG element.
     *
     * @ignore Exclude from docs
     * @param element    Element
     * @param className  Class name to add
     */
    function removeClass(element, className) {
        if (!element) {
            return;
        }
        if (element.classList) {
            element.classList.remove(className);
        }
        else {
            let currentClassName = element.getAttribute("class");
            if (currentClassName) {
                element.setAttribute("class", currentClassName.split(" ").filter((item) => {
                    return item !== className;
                }).join(" "));
            }
        }
    }
    // /**
    //  * Applies a set of styles to an element. Stores the original styles so they
    //  * can be restored later.
    //  *
    //  * @ignore
    //  * @param io      Element
    //   */
    // export function prepElementForDrag(dom: HTMLElement): void {
    // 	// @todo: save current values
    // 	// Define possible props
    // 	let props = [
    // 		"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
    // 		"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
    // 		"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
    // 		"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
    // 		"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
    // 		"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
    // 	];
    // 	for (let i = 0; i < props.length; i++) {
    // 		if (props[i] in dom.style) {
    // 			setStyle(dom, props[i], "none");
    // 		}
    // 	}
    // 	// Remove iOS-specific selection;
    // 	setStyle(dom, "tapHighlightColor", "rgba(0, 0, 0, 0)");
    // }
    // /**
    //  * Restores replaced styles
    //  *
    //  * @ignore
    //  * @param  io  Element
    //  */
    // export function unprepElementForDrag(dom: HTMLElement): void {
    // 	// Define possible props
    // 	let props = [
    // 		"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
    // 		"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
    // 		"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
    // 		"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
    // 		"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
    // 		"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
    // 	];
    // 	for (let i = 0; i < props.length; i++) {
    // 		if (props[i] in dom.style) {
    // 			setStyle(dom, props[i], "");
    // 		}
    // 	}
    // 	// Remove iOS-specific selection;
    // 	setStyle(dom, "tapHighlightColor", "");
    // }
    function iOS() {
        return /apple/i.test(navigator.vendor) && "ontouchend" in document;
    }
    function getSafeResolution() {
        return iOS() ? 1 : undefined;
    }
    function relativeToValue(percent, full) {
        if (isNumber(percent)) {
            return percent;
        }
        else if (percent != null && isNumber(percent.value) && isNumber(full)) {
            return full * percent.value;
        }
        else {
            return 0;
        }
    }
    /**
     * Returns number of decimals
     *
     * @ignore Exclude from docs
     * @param number  Input number
     * @return Number of decimals
     */
    function decimalPlaces(number) {
        let match = ('' + number).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
        if (!match) {
            return 0;
        }
        return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
    }
    /**
     * ============================================================================
     * STRING FORMATTING FUNCTIONS
     * ============================================================================
     * @hidden
     */
    /**
     * Pads a string with additional characters to certain length.
     *
     * @param value  A numeric value
     * @param len    Result string length in characters
     * @param char   A character to use for padding
     * @return Padded value as string
     */
    function padString(value, len = 0, char = "0") {
        if (typeof value !== "string") {
            value = value.toString();
        }
        return len > value.length ? Array(len - value.length + 1).join(char) + value : value;
    }
    function trimLeft(text) {
        return text.replace(/^[\s]*/, "");
    }
    function trimRight(text) {
        return text.replace(/[\s]*$/, "");
    }
    function trim(text) {
        return trimLeft(trimRight(text));
    }
    function truncateTextWithEllipsis(text, maxLength, breakWords = false, ellipsis = "...") {
        if (text.length > maxLength) {
            // Find the last non-alphanumeric character before maxLength
            let lastNonAlphanumericIndex = maxLength - 1;
            while (lastNonAlphanumericIndex >= 0 && text.charAt(lastNonAlphanumericIndex).match(/\w/)) {
                lastNonAlphanumericIndex--;
            }
            if (lastNonAlphanumericIndex >= 0 && breakWords == false) {
                return text.substring(0, lastNonAlphanumericIndex + 1) + '...';
            }
            else {
                // If no non-alphanumeric character found, truncate without breaking words
                return text.substring(0, maxLength) + ellipsis;
            }
        }
        else {
            return text;
        }
    }
    /**
     * Tries to determine format type.
     *
     * @ignore Exclude from docs
     * @param format  Format string
     * @return Format type ("string" | "number" | "date" | "duration")
     */
    function getFormat(format) {
        // Undefined?
        if (typeof format === "undefined") {
            return "string";
        }
        // Cleanup and lowercase format
        format = format.toLowerCase().replace(/^\[[^\]]*\]/, "");
        // Remove style tags
        format = format.replace(/\[[^\]]+\]/, "");
        // Trim
        format = format.trim();
        // Check for any explicit format hints (i.e. /Date)
        let hints = format.match(/\/(date|number|duration)$/);
        if (hints) {
            return hints[1];
        }
        // Check for explicit hints
        if (format === "number") {
            return "number";
        }
        if (format === "date") {
            return "date";
        }
        if (format === "duration") {
            return "duration";
        }
        // Detect number formatting symbols
        if (format.match(/[#0]/)) {
            return "number";
        }
        // Detect date formatting symbols
        if (format.match(/[ymwdhnsqaxkzgtei]/)) {
            return "date";
        }
        // Nothing? Let's display as string
        return "string";
    }
    /**
     * Cleans up format:
     * * Strips out formatter hints
     *
     * @ignore Exclude from docs
     * @param format  Format
     * @return Cleaned format
     */
    function cleanFormat(format) {
        return format.replace(/\/(date|number|duration)$/i, "");
    }
    /**
     * Strips all tags from the string.
     *
     * @param text  Source string
     * @return String without tags
     */
    function stripTags(text) {
        return text ? text.replace(/<[^>]*>/g, "") : text;
    }
    /**
     * Removes new lines and tags from a string.
     *
     * @param text  String to conver
     * @return Converted string
     */
    function plainText(text) {
        return text ? stripTags(("" + text).replace(/[\n\r]+/g, ". ")) : text;
    }
    /**
     * Escapes string so it can safely be used in a Regex.
     *
     * @param value  Unsescaped string
     * @return Escaped string
     */
    function escapeForRgex(value) {
        return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    }
    /**
     * Adds space before each uppercase letter.
     *
     * @param   str Input string
     * @return      Output string
     */
    function addSpacing(str) {
        let result = "";
        for (let i = 0; i < str.length; i++) {
            const char = str.charAt(i);
            if (char.toUpperCase() == char && i != 0) {
                result += " ";
            }
            result += char;
        }
        return result;
    }
    /**
     * Splits the string into separate characters. Keeps RTL words non-split.
     *
     * @param   source  Input
     * @return          Split text
     */
    function splitString(source) {
        // Regular expression to identify RTL characters
        const rtlChar = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
        // Regular expression to capture segments ending with specific Arabic characters
        const splitPattern = /([^اأدذرزو]*[اأدذرزو])/gi;
        // Split input string into array of words or characters, including whitespace
        let segments = source.split(/(\s+)/); // Split by whitespace, capturing it
        let result = [];
        segments.forEach(segment => {
            if (segment.match(/^\s+$/)) {
                // If the segment is purely whitespace
                if (segment = " ") {
                    segment = "  ";
                }
                result.push(segment);
            }
            else if (rtlChar.test(segment)) {
                // If the segment contains RTL characters, handle special splits
                let parts = segment.split(splitPattern).filter(part => part !== '');
                // Concatenate parts processed by the split pattern directly to result
                result = result.concat(parts);
            }
            else {
                // Treat this segment as LTR: split into characters
                result = result.concat([...segment]);
            }
        });
        return result;
    }
    /**
     * ============================================================================
     * DATE-RELATED FUNCTIONS
     * ============================================================================
     * @hidden
     */
    /**
     * Returns a year day.
     *
     * @param date  Date
     * @param utc   Assume UTC dates?
     * @return Year day
     * @todo Account for UTC
     */
    function getYearDay(date, utc = false) {
        const start = new Date(date.getFullYear(), 0, 0);
        const diff = (date.getTime() - start.getTime()) + ((start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000);
        const oneDay = 1000 * 60 * 60 * 24;
        return Math.floor(diff / oneDay);
    }
    /**
     * Returns week number for a given date.
     *
     * @param date  Date
     * @param utc   Assume UTC dates?
     * @return Week number
     * @todo Account for UTC
     */
    function getWeek(date, _utc = false) {
        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        const day = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - day);
        const firstDay = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d.getTime() - firstDay.getTime()) / 86400000) + 1) / 7);
    }
    /**
     * Returns a "week year" of the given date.
     *
     * @param date  Date
     * @param utc   Assume UTC dates?
     * @return Year of week
     * @since 5.3.0
     * @todo Account for UTC
     */
    function getWeekYear(date, _utc = false) {
        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        const day = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - day);
        const firstDay = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return firstDay.getFullYear();
    }
    /**
     * Returns a week number in the month.
     *
     * @param date  Source Date
     * @param utc   Assume UTC dates?
     * @return Week number in month
     */
    function getMonthWeek(date, utc = false) {
        const firstWeek = getWeek(new Date(date.getFullYear(), date.getMonth(), 1), utc);
        let currentWeek = getWeek(date, utc);
        if (currentWeek == 1) {
            currentWeek = 53;
        }
        return currentWeek - firstWeek + 1;
    }
    /**
     * Returns a year day out of the given week number.
     *
     * @param week     Week
     * @param year     Year
     * @param weekday  Weekday
     * @param utc      Assume UTC dates
     * @return Day in a year
     */
    function getDayFromWeek(week, year, weekday = 1, utc = false) {
        let date = new Date(year, 0, 4, 0, 0, 0, 0);
        if (utc) {
            date.setUTCFullYear(year);
        }
        let day = week * 7 + weekday - ((date.getDay() || 7) + 3);
        return day;
    }
    /**
     * Returns 12-hour representation out of the 24-hour hours.
     *
     * @param hours  24-hour number
     * @return 12-hour number
     */
    function get12Hours(hours, base) {
        if (hours > 12) {
            hours -= 12;
        }
        else if (hours === 0) {
            hours = 12;
        }
        return base != null ? hours + (base - 1) : hours;
    }
    /**
     * Returns a string name of the time zone.
     *
     * @param date     Date object
     * @param long     Should return long ("Pacific Standard Time") or short abbreviation ("PST")
     * @param savings  Include information if it's in daylight savings mode
     * @param utc      Assume UTC dates
     * @return Time zone name
     */
    function getTimeZone(date, long = false, savings = false, utc = false, timezone) {
        if (utc) {
            return long ? "Coordinated Universal Time" : "UTC";
        }
        else if (timezone) {
            const d1 = date.toLocaleString("en-US", { timeZone: timezone });
            const d2 = date.toLocaleString("en-US", { timeZone: timezone, timeZoneName: long ? "long" : "short" });
            return trim(d2.substr(d1.length));
        }
        let wotz = date.toLocaleString("UTC");
        let wtz = date.toLocaleString("UTC", { timeZoneName: long ? "long" : "short" }).substr(wotz.length);
        //wtz = wtz.replace(/[+-]+[0-9]+$/, "");
        if (savings === false) {
            wtz = wtz.replace(/ (standard|daylight|summer|winter) /i, " ");
        }
        return trim(wtz);
    }
    function getTimezoneOffset(timezone) {
        const date = new Date(Date.UTC(2012, 0, 1, 0, 0, 0, 0));
        const utcDate = new Date(date.toLocaleString("en-US", { timeZone: "UTC" }));
        const tzDate = new Date(date.toLocaleString("en-US", { timeZone: timezone }));
        return (tzDate.getTime() - utcDate.getTime()) / 6e4 * -1;
    }
    function capitalizeFirst(text) {
        return text.charAt(0).toUpperCase() + text.slice(1);
    }
    /**
     * The functions below are taken and adapted from Garry Tan's blog post:
     * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
     *
     * The further attributions go mjijackson.com, which now seems to be defunct.
     */
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h, s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     *
     * Function adapted from:
     * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
     *
     * @param h       The hue
     * @param s       The saturation
     * @param l       The lightness
     * @return The RGB representation
     */
    function hslToRgb(color) {
        let r, g, b;
        let h = color.h;
        let s = color.s;
        let l = color.l;
        if (s == 0) {
            r = g = b = l; // achromatic
        }
        else {
            let hue2rgb = function hue2rgb(p, q, t) {
                if (t < 0) {
                    t += 1;
                }
                if (t > 1) {
                    t -= 1;
                }
                if (t < 1 / 6) {
                    return p + (q - p) * 6 * t;
                }
                if (t < 1 / 2) {
                    return q;
                }
                if (t < 2 / 3) {
                    return p + (q - p) * (2 / 3 - t) * 6;
                }
                return p;
            };
            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            let p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
        };
    }
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h, s, and l in the set [0, 1].
     *
     * Function adapted from:
     * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
     *
     * @param r       The red color value
     * @param g       The green color value
     * @param b       The blue color value
     * @return The HSL representation
     */
    function rgbToHsl(color) {
        let r = color.r / 255;
        let g = color.g / 255;
        let b = color.b / 255;
        let max = Math.max(r, g, b);
        let min = Math.min(r, g, b);
        let h = 0;
        let s = 0;
        let l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            let d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return {
            h: h,
            s: s,
            l: l,
        };
    }
    /**
     * Converts HSV to HSL.
     *
     * https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL
     */
    function hsvToHsl(hsv) {
        const l = hsv.v * (1 - (hsv.s / 2));
        const s = (l === 0 || l === 1
            ? 0
            : (hsv.v - l) / Math.min(l, 1 - l));
        return {
            h: hsv.h,
            s,
            l,
            a: hsv.a,
        };
    }
    /**
     * Converts HSL to HSV.
     *
     * https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV
     */
    function hslToHsv(hsl) {
        const v = hsl.l + (hsl.s * Math.min(hsl.l, 1 - hsl.l));
        const s = (v === 0
            ? 0
            : 2 * (1 - (hsl.l / v)));
        return {
            h: hsl.h,
            s,
            v,
            a: hsl.a,
        };
    }
    /**
     * Returns a color that is `percent` brighter than the reference color.
     *
     * @param color    Reference color
     * @param percent  Brightness percent
     * @return Hex code of the new color
     */
    function lighten(rgb, percent) {
        if (rgb) {
            return {
                r: Math.max(0, Math.min(255, rgb.r + getLightnessStep(rgb.r, percent))),
                g: Math.max(0, Math.min(255, rgb.g + getLightnessStep(rgb.g, percent))),
                b: Math.max(0, Math.min(255, rgb.b + getLightnessStep(rgb.b, percent))),
                a: rgb.a
            };
        }
        else {
            // TODO is this correct ?
            return rgb;
        }
    }
    /**
     * Gets lightness step.
     *
     * @param value    Value
     * @param percent  Percent
     * @return Step
     */
    function getLightnessStep(value, percent) {
        let base = percent > 0 ? 255 - value : value;
        return Math.round(base * percent);
    }
    /**
     * Returns a color that is `percent` brighter than the source `color`.
     *
     * @param color    Source color
     * @param percent  Brightness percent
     * @return New color
     */
    function brighten(rgb, percent) {
        if (rgb) {
            let base = Math.min(Math.max(rgb.r, rgb.g, rgb.b), 230);
            //let base = Math.max(rgb.r, rgb.g, rgb.b);
            let step = getLightnessStep(base, percent);
            return {
                r: Math.max(0, Math.min(255, Math.round(rgb.r + step))),
                g: Math.max(0, Math.min(255, Math.round(rgb.g + step))),
                b: Math.max(0, Math.min(255, Math.round(rgb.b + step))),
                a: rgb.a
            };
        }
        else {
            // TODO is this correct ?
            return rgb;
        }
    }
    /**
     * Returns brightness step.
     *
     * @ignore Exclude from docs
     * @param value    Value
     * @param percent  Percent
     * @return Step
     */
    function getBrightnessStep(_value, percent) {
        let base = 255; //percent > 0 ? 255 - value : value;
        return Math.round(base * percent);
    }
    /**
     * Returns `true` if color is "light". Useful indetermining which contrasting
     * color to use for elements over this color. E.g.: you would want to use
     * black text over light background, and vice versa.
     *
     * @param color  Source color
     * @return Light?
     */
    function isLight(color) {
        return ((color.r * 299) + (color.g * 587) + (color.b * 114)) / 1000 >= 128;
    }
    /**
     * Returns a new [[iRGB]] object based on `rgb` parameter with specific
     * saturation applied.
     *
     * `saturation` can be in the range of 0 (fully desaturated) to 1 (fully
     * saturated).
     *
     * @param color       Base color
     * @param saturation  Saturation (0-1)
     * @return New color
     */
    function saturate(rgb, saturation) {
        if (rgb === undefined || saturation == 1) {
            return rgb;
        }
        let hsl = rgbToHsl(rgb);
        hsl.s = saturation;
        return hslToRgb(hsl);
    }
    /**
     * Returns a color which contrasts more with the source `color`.
     *
     * @param  color             Base color
     * @param  lightAlternative  Light option
     * @param  darkAlternative   Dark option
     * @return New color
     */
    function alternativeColor(color, lightAlternative = { r: 255, g: 255, b: 255 }, darkAlternative = { r: 255, g: 255, b: 255 }) {
        let light = lightAlternative;
        let dark = darkAlternative;
        if (isLight(darkAlternative)) {
            light = darkAlternative;
            dark = lightAlternative;
        }
        return isLight(color) ? dark : light;
    }
    /**
     * @ignore
     */
    function mergeTags(tags1, tags2) {
        if (!tags1) {
            tags1 = [];
        }
        return [...tags1, ...tags2].filter((value, index, self) => {
            return self.indexOf(value) === index;
        });
    }
    /**
     * @ignore
     */
    function sameBounds(a, b) {
        if (!b) {
            return false;
        }
        if (a.left != b.left) {
            return false;
        }
        if (a.right != b.right) {
            return false;
        }
        if (a.top != b.top) {
            return false;
        }
        if (a.bottom != b.bottom) {
            return false;
        }
        return true;
    }

    var Utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        StyleRule: StyleRule,
        StyleSheet: StyleSheet,
        addClass: addClass,
        addEventListener: addEventListener,
        addSpacing: addSpacing,
        alternativeColor: alternativeColor,
        blur: blur,
        brighten: brighten,
        capitalizeFirst: capitalizeFirst,
        cleanFormat: cleanFormat,
        contains: contains,
        decimalPlaces: decimalPlaces,
        escapeForRgex: escapeForRgex,
        focus: focus,
        get12Hours: get12Hours,
        getBrightnessStep: getBrightnessStep,
        getDayFromWeek: getDayFromWeek,
        getEventKey: getEventKey,
        getEventTarget: getEventTarget,
        getFormat: getFormat,
        getLightnessStep: getLightnessStep,
        getMonthWeek: getMonthWeek,
        getPointerId: getPointerId,
        getRendererEvent: getRendererEvent,
        getSafeResolution: getSafeResolution,
        getShadowRoot: getShadowRoot,
        getStyle: getStyle,
        getTimeZone: getTimeZone,
        getTimezoneOffset: getTimezoneOffset,
        getWeek: getWeek,
        getWeekYear: getWeekYear,
        getYearDay: getYearDay,
        hslToHsv: hslToHsv,
        hslToRgb: hslToRgb,
        hsvToHsl: hsvToHsl,
        iOS: iOS,
        isLight: isLight,
        isLocalEvent: isLocalEvent,
        isTouchEvent: isTouchEvent,
        lighten: lighten,
        mergeTags: mergeTags,
        onZoom: onZoom,
        padString: padString,
        plainText: plainText,
        ready: ready,
        relativeToValue: relativeToValue,
        removeClass: removeClass,
        removeElement: removeElement,
        rgbToHsl: rgbToHsl,
        sameBounds: sameBounds,
        saturate: saturate,
        setInteractive: setInteractive,
        setStyle: setStyle,
        splitString: splitString,
        stripTags: stripTags,
        supports: supports,
        trim: trim,
        trimLeft: trimLeft,
        trimRight: trimRight,
        truncateTextWithEllipsis: truncateTextWithEllipsis
    });

    /**
     * @ignore
     */
    function string2hex(string) {
        //string = cssColorNames[string.toLowerCase()] || string;
        if (string[0] === "#") {
            string = string.substr(1);
        }
        if (string.length == 3) {
            string = string[0].repeat(2) + string[1].repeat(2) + string[2].repeat(2);
        }
        return parseInt(string, 16);
    }
    /**
     * @ignore
     */
    function rgba2hex(color) {
        color = color.replace(/[ ]/g, "");
        // Init
        let matches = color.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
        // Try rgb() format
        if (matches) {
            matches.push("1");
        }
        else {
            matches = color.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i);
            if (!matches) {
                return 0x000000;
            }
        }
        let hex = "";
        for (let i = 1; i <= 3; i++) {
            let val = parseInt(matches[i]).toString(16);
            if (val.length == 1) {
                val = "0" + val;
            }
            hex += val;
        }
        return string2hex(hex);
    }
    /**
     * Returns a new [[Color]] object base on input.
     *
     * Accepts parameters in CSS hex or rgb/rtba strings, or hex numbers.
     *
     * * `"#f00"`
     * * `"#ff0000"`
     * * `"rgb(255, 0, 0)"`
     * * `"rgba(255, 0, 0, 1)"`
     * * `0xff0000`
     *
     * @param   input  Input color
     * @return         Color
     */
    function color(input) {
        return Color.fromAny(input);
    }
    /**
     * Wherever color needs to be specified in amCharts 5, `Color` object needs to
     * be used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more info
     * @important
     */
    class Color {
        constructor(hex) {
            Object.defineProperty(this, "_hex", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._hex = hex | 0;
        }
        /**
         * Color numeric value.
         */
        get hex() {
            return this._hex;
        }
        /**
         * Value of color's R channel.
         * @return R value
         */
        get r() {
            return this._hex >>> 16;
        }
        /**
         * Value of color's G channel.
         * @return G value
         */
        get g() {
            return (this._hex >> 8) & 0xFF;
        }
        /**
         * Value of color's B channel.
         * @return B value
         */
        get b() {
            return this._hex & 0xFF;
        }
        /**
         * Returns color CSS representation in form of `rgba(r, g, b, a)` string.
         *
         * @param   alpha  Opacity
         * @return         CSS string
         */
        toCSS(alpha = 1) {
            return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + alpha + ")";
        }
        /**
         * Returns color CSS representation in form of `#rgb` string.
         *
         * @return         CSS string
         */
        toCSSHex() {
            return "#" + padString(this.r.toString(16), 2) + padString(this.g.toString(16), 2) + padString(this.b.toString(16), 2);
        }
        /**
         * Returns color's HSL info.
         * @param   alpha Opacity
         * @return        HSL info
         */
        toHSL(alpha = 1) {
            return rgbToHsl({
                r: this.r,
                g: this.g,
                b: this.b,
                a: alpha
            });
        }
        /**
         * Converts HSL values into a new [[Color]] object.
         *
         * @param   h H value
         * @param   s S value
         * @param   l L value
         * @return    Color object
         */
        static fromHSL(h, s, l) {
            const rgb = hslToRgb({
                h: h,
                s: s,
                l: l
            });
            return this.fromRGB(rgb.r, rgb.g, rgb.b);
        }
        toString() {
            return this.toCSSHex();
        }
        /**
         * Converts hex number into a new [[Color]] object.
         *
         * ```TypeScript
         * Color.fromHex(0xff0000) // red
         * ```
         * ```JavaScript
         * Color.fromHex(0xff0000) // red
         * ```
         *
         * @param   hex  Hex color
         * @return       Color
         */
        static fromHex(hex) {
            return new Color(hex);
        }
        /**
         * Converts RGB values to a new [[Color]] object.
         *
         * @param   r  R value
         * @param   g  G value
         * @param   b  B value
         * @return     Color
         */
        static fromRGB(r, g, b) {
            return new Color((b | 0) + (g << 8) + (r << 16));
        }
        /**
         * Converts RGB string to a new [[Color]] object.
         *
         * ```TypeScript
         * Color.fromString("#ff0000") // red
         * ```
         * ```JavaScript
         * Color.fromString("#ff0000") // red
         * ```
         *
         * @param   s  RGB string
         * @return     Color
         */
        static fromString(s) {
            return new Color(string2hex(s));
        }
        /**
         * Converts CSS rgba() syntax to a new [[Color]] object.
         *
         * ```TypeScript
         * Color.fromCSS("rgba(255, 0, 0, 1)") // red
         * ```
         * ```JavaScript
         * Color.fromCSS("rgba(255, 0, 0, 1)") // red
         * ```
         *
         * @param  {string} s [description]
         * @return {Color}    [description]
         */
        static fromCSS(s) {
            return new Color(rgba2hex(s));
        }
        /**
         * Convert to color from virtually anything.
         *
         * Will throw an exception if unable to resolve the color.
         *
         * @param   s  Source
         * @return     Color
         */
        static fromAny(s) {
            if (isString(s)) {
                if (s[0] == "#") {
                    return Color.fromString(s);
                }
                else if (s.substr(0, 3) == "rgb") {
                    return Color.fromCSS(s);
                }
            }
            else if (isNumber(s)) {
                return Color.fromHex(s);
            }
            else if (s instanceof Color) {
                return Color.fromHex(s.hex);
            }
            throw new Error("Unknown color syntax: " + s);
        }
        /**
         * Returns a new [[Color]] object based on either `lightAlternative` or
         * `darkAlternative` depending on which one is more contrasting with
         * the `color`.
         *
         * @param   color             Reference color
         * @param   lightAlternative  Light color
         * @param   darkAlternative   Dark color
         * @return                    Alternative color
         */
        static alternative(color, lightAlternative, darkAlternative) {
            const rgb = alternativeColor({ r: color.r, g: color.g, b: color.b }, lightAlternative ? { r: lightAlternative.r, g: lightAlternative.g, b: lightAlternative.b } : undefined, darkAlternative ? { r: darkAlternative.r, g: darkAlternative.g, b: darkAlternative.b } : undefined);
            return this.fromRGB(rgb.r, rgb.g, rgb.b);
        }
        /**
         * Returns an intermediate Color between two reference colors depending on
         * the progress (`diff`) between the two.
         *
         * @param   diff  Progress
         * @param   from  Source color
         * @param   to    Target color
         * @param   mode  Interpolation mode
         * @return        Color
         */
        static interpolate(diff, from, to, mode = "rgb") {
            if (mode == "hsl") {
                const fromHSL = from.toHSL();
                const toHSL = to.toHSL();
                return Color.fromHSL(range(diff, fromHSL.h, toHSL.h), range(diff, fromHSL.s, toHSL.s), range(diff, fromHSL.l, toHSL.l));
            }
            else {
                return Color.fromRGB(range(diff, from.r, to.r), range(diff, from.g, to.g), range(diff, from.b, to.b));
            }
        }
        /**
         * Returns a new [[Color]] lightened by `percent` value.
         *
         * Use negative value to darken the color.
         *
         * @param   color    Source color
         * @param   percent  Percent
         * @return           New color
         */
        static lighten(color, percent) {
            const rgb = lighten({ r: color.r, g: color.g, b: color.b }, percent);
            return Color.fromRGB(rgb.r, rgb.g, rgb.b);
        }
        /**
         * Returns a new [[Color]] brightened by `percent` value.
         *
         * Use negative value to dim the color.
         *
         * @param   color    Source color
         * @param   percent  Percent
         * @return           New color
         */
        static brighten(color, percent) {
            const rgb = brighten({ r: color.r, g: color.g, b: color.b }, percent);
            return Color.fromRGB(rgb.r, rgb.g, rgb.b);
        }
        /**
         * Returns a new [[Color]] saturated by `percent` value.
         *
         * Value range is between `0` (fully desaturated), to `1` (full color).
         *
         * @param   color    Source color
         * @param   percent  Percent
         * @return           New color
         */
        static saturate(color, percent) {
            const rgb = saturate({ r: color.r, g: color.g, b: color.b }, percent);
            return Color.fromRGB(rgb.r, rgb.g, rgb.b);
        }
    }

    /**
     * Event Dispatcher module is used for registering listeners and dispatching
     * events across amCharts system.
     */
    /**
     * ============================================================================
     * IMPORTS
     * ============================================================================
     * @hidden
     */
    /**
     * Universal Event Dispatcher.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
     */
    class EventDispatcher {
        /**
         * Constructor
         */
        constructor() {
            Object.defineProperty(this, "_listeners", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_killed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_disabled", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_iterating", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_enabled", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_disposed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._listeners = [];
            this._killed = [];
            this._disabled = {};
            this._iterating = 0;
            this._enabled = true;
            this._disposed = false;
        }
        /**
         * Returns if this object has been already disposed.
         *
         * @return Disposed?
         */
        isDisposed() {
            return this._disposed;
        }
        /**
         * Dispose (destroy) this object.
         */
        dispose() {
            if (!this._disposed) {
                this._disposed = true;
                const a = this._listeners;
                this._iterating = 1;
                this._listeners = null;
                this._disabled = null;
                try {
                    each$1(a, (x) => {
                        x.disposer.dispose();
                    });
                }
                finally {
                    this._killed = null;
                    this._iterating = null;
                }
            }
        }
        /**
         * Checks if this particular event dispatcher has any listeners set.
         *
         * @return Has listeners?
         */
        hasListeners() {
            return this._listeners.length !== 0;
        }
        /**
         * Checks if this particular event dispatcher has any particular listeners set.
         *
         * @return Has particular event listeners?
         */
        hasListenersByType(type) {
            return any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);
        }
        /**
         * Enable dispatching of events if they were previously disabled by
         * `disable()`.
         */
        enable() {
            this._enabled = true;
        }
        /**
         * Disable dispatching of events until re-enabled by `enable()`.
         */
        disable() {
            this._enabled = false;
        }
        /**
         * Enable dispatching particular event, if it was disabled before by
         * `disableType()`.
         *
         * @param type Event type
         */
        enableType(type) {
            delete this._disabled[type];
        }
        /**
         * Disable dispatching of events for a certain event type.
         *
         * Optionally, can set how many dispatches to skip before automatically
         * re-enabling the dispatching.
         *
         * @param type    Event type
         * @param amount  Number of event dispatches to skip
         */
        disableType(type, amount = Infinity) {
            this._disabled[type] = amount;
        }
        /**
         * Removes listener from dispatcher.
         *
         * Will throw an exception if such listener does not exists.
         *
         * @param listener Listener to remove
         */
        _removeListener(listener) {
            if (this._iterating === 0) {
                const index = this._listeners.indexOf(listener);
                if (index === -1) {
                    throw new Error("Invalid state: could not remove listener");
                }
                this._listeners.splice(index, 1);
            }
            else {
                this._killed.push(listener);
            }
        }
        /**
         * Removes existing listener by certain parameters.
         *
         * @param once         Listener's once setting
         * @param type         Listener's type
         * @param callback     Callback function
         * @param context      Callback context
         */
        _removeExistingListener(once, type, callback, context) {
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            this._eachListener((info) => {
                if (info.once === once && // TODO is this correct ?
                    info.type === type &&
                    (callback === undefined || info.callback === callback) &&
                    info.context === context) {
                    info.disposer.dispose();
                }
            });
        }
        /**
         * Checks if dispatching for particular event type is enabled.
         *
         * @param type  Event type
         * @return Enabled?
         */
        isEnabled(type) {
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            // TODO is this check correct ?
            return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;
        }
        /**
         * Removes all listeners of a particular event type
         *
         * @param type  Listener's type
         */
        removeType(type) {
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            this._eachListener((info) => {
                if (info.type === type) {
                    info.disposer.dispose();
                }
            });
        }
        /**
         * Checks if there's already a listener with specific parameters.
         *
         * @param type      Listener's type
         * @param callback  Callback function
         * @param context   Callback context
         * @return Has listener?
         */
        has(type, callback, context) {
            const index = findIndex(this._listeners, (info) => {
                return info.once !== true && // Ignoring "once" listeners
                    info.type === type &&
                    (callback === undefined || info.callback === callback) &&
                    info.context === context;
            });
            return index !== -1;
        }
        /**
         * Checks whether event of the particular type should be dispatched.
         *
         * @param type  Event type
         * @return Dispatch?
         */
        _shouldDispatch(type) {
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            const count = this._disabled[type];
            if (!isNumber(count)) {
                return this._enabled;
            }
            else {
                if (count <= 1) {
                    delete this._disabled[type];
                }
                else {
                    --this._disabled[type];
                }
                return false;
            }
        }
        /**
         * [_eachListener description]
         *
         * All of this extra code is needed when a listener is removed while iterating
         *
         * @todo Description
         * @param fn [description]
         */
        _eachListener(fn) {
            ++this._iterating;
            try {
                each$1(this._listeners, fn);
            }
            finally {
                --this._iterating;
                // TODO should this be inside or outside the finally ?
                if (this._iterating === 0 && this._killed.length !== 0) {
                    // Remove killed listeners
                    each$1(this._killed, (killed) => {
                        this._removeListener(killed);
                    });
                    this._killed.length = 0;
                }
            }
        }
        /**
         * Dispatches an event immediately without waiting for next cycle.
         *
         * @param type   Event type
         * @param event  Event object
         * @todo automatically add in type and target properties if they are missing
         */
        dispatch(type, event) {
            if (this._shouldDispatch(type)) {
                // TODO check if it's faster to use an object of listeners rather than a single big array
                // TODO if the function throws, maybe it should keep going ?
                this._eachListener((listener) => {
                    if (!listener.killed && (listener.type === null || listener.type === type)) {
                        listener.dispatch(type, event);
                    }
                });
            }
        }
        /**
         * Shelves the event to be dispatched within next update cycle.
         *
         * @param type   Event type
         * @param event  Event object
         * @todo automatically add in type and target properties if they are missing
         */
        /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {
            if (this._shouldDispatch(type)) {
                this._eachListener((listener) => {
                    // TODO check if it's faster to use an object of listeners rather than a single big array
                    if (!listener.killed && (listener.type === null || listener.type === type)) {
                        // TODO if the function throws, maybe it should keep going ?
                        // TODO dispatch during the update cycle, rather than using whenIdle
                        $async.whenIdle(() => {
                            if (!listener.killed) {
                                listener.dispatch(type, event);
                            }
                        });
                    }
                });
            }
        }*/
        /**
         * Creates, catalogs and returns an [[EventListener]].
         *
         * Event listener can be disposed.
         *
         * @param once         Listener's once setting
         * @param type         Listener's type
         * @param callback     Callback function
         * @param context      Callback context
         * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
         * @param dispatch
         * @returns An event listener
         */
        _on(once, type, callback, context, shouldClone, dispatch) {
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            this._removeExistingListener(once, type, callback, context);
            const info = {
                type: type,
                callback: callback,
                context: context,
                shouldClone: shouldClone,
                dispatch: dispatch,
                killed: false,
                once: once,
                disposer: new Disposer(() => {
                    info.killed = true;
                    this._removeListener(info);
                })
            };
            this._listeners.push(info);
            return info;
        }
        /**
         * Creates an event listener to be invoked on **any** event.
         *
         * @param callback     Callback function
         * @param context      Callback context
         * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
         * @returns A disposable event listener
         */
        onAll(callback, context, shouldClone = true) {
            return this._on(false, null, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;
        }
        /**
         * Creates an event listener to be invoked on a specific event type.
         *
         * ```TypeScript
         * button.events.once("click", (ev) => {
         *   console.log("Button clicked");
         * }, this);
         * ```
         * ```JavaScript
         * button.events.once("click", (ev) => {
         *   console.log("Button clicked");
         * }, this);
         * ```
         *
         * The above will invoke our custom event handler whenever series we put
         * event on is hidden.
         *
         * @param type         Listener's type
         * @param callback     Callback function
         * @param context      Callback context
         * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
         * @returns A disposable event listener
         */
        on(type, callback, context, shouldClone = true) {
            return this._on(false, type, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;
        }
        /**
         * Creates an event listener to be invoked on a specific event type once.
         *
         * Once the event listener is invoked, it is automatically disposed.
         *
         * ```TypeScript
         * button.events.once("click", (ev) => {
         *   console.log("Button clicked");
         * }, this);
         * ```
         * ```JavaScript
         * button.events.once("click", (ev) => {
         *   console.log("Button clicked");
         * }, this);
         * ```
         *
         * The above will invoke our custom event handler the first time series we
         * put event on is hidden.
         *
         * @param type         Listener's type
         * @param callback     Callback function
         * @param context      Callback context
         * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
         * @returns A disposable event listener
         */
        once(type, callback, context, shouldClone = true) {
            const x = this._on(true, type, callback, context, shouldClone, (_type, event) => {
                x.disposer.dispose();
                callback.call(context, event);
            });
            // TODO maybe this should return a different Disposer ?
            return x.disposer;
        }
        /**
         * Removes the event listener with specific parameters.
         *
         * @param type         Listener's type
         * @param callback     Callback function
         * @param context      Callback context
         */
        off(type, callback, context) {
            this._removeExistingListener(false, type, callback, context);
        }
        /**
         * Copies all dispatcher parameters, including listeners, from another event
         * dispatcher.
         *
         * @param source Source event dispatcher
         * @ignore
         */
        copyFrom(source) {
            if (this._disposed) {
                throw new Error("EventDispatcher is disposed");
            }
            if (source === this) {
                throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
            }
            const disposers = [];
            each$1(source._listeners, (x) => {
                // TODO is this correct ?
                if (!x.killed && x.shouldClone) {
                    if (x.type === null) {
                        disposers.push(this.onAll(x.callback, x.context));
                    }
                    else if (x.once) {
                        disposers.push(this.once(x.type, x.callback, x.context));
                    }
                    else {
                        disposers.push(this.on(x.type, x.callback, x.context));
                    }
                }
            });
            return new MultiDisposer(disposers);
        }
    }

    /**
     * @ignore
     */
    function waitForAnimations(animations) {
        return __awaiter(this, void 0, void 0, function* () {
            if (animations !== undefined) {
                const promises = [];
                each(animations, (_, animation) => {
                    promises.push(animation.waitForStop());
                });
                yield Promise.all(promises);
            }
        });
    }
    /**
     * @ignore
     */
    function range(diff, from, to) {
        return from + (diff * (to - from));
    }
    /**
     * @ignore
     */
    function defaultInterpolate(diff, from, to) {
        if (diff >= 1) {
            return to;
        }
        else {
            return from;
        }
    }
    /**
     * @ignore
     */
    function percentInterpolate(diff, from, to) {
        return new Percent(range(diff, from.percent, to.percent));
    }
    /**
     * @ignore
     */
    function colorInterpolate(diff, from, to) {
        return Color.interpolate(diff, from, to);
    }
    /**
     * @ignore
     */
    function getInterpolate(from, to) {
        if (typeof from === "number" && typeof to === "number") {
            return range;
        }
        if (from instanceof Percent && to instanceof Percent) {
            return percentInterpolate;
        }
        if (from instanceof Color && to instanceof Color) {
            return colorInterpolate;
        }
        return defaultInterpolate;
    }
    var AnimationState;
    (function (AnimationState) {
        AnimationState[AnimationState["Stopped"] = 0] = "Stopped";
        AnimationState[AnimationState["Playing"] = 1] = "Playing";
        AnimationState[AnimationState["Paused"] = 2] = "Paused";
    })(AnimationState || (AnimationState = {}));
    /*export class AnimationValue extends AnimationTime {
        public _min: number;
        public _max: number;

        constructor(entity: Entity, duration: number, min: number, max: number) {
            super(entity, duration);
            this._min = min;
            this._max = max;
        }

        public get min(): number {
            return this._min;
        }

        public set min(value: number) {
            if (this._min !== value) {
                this._min = value;
                this._entity.markDirty();
            }
        }

        public get max(): number {
            return this._max;
        }

        public set max(value: number) {
            if (this._max !== value) {
                this._max = value;
                this._entity.markDirty();
            }
        }

        public currentValue(): number {
            return range(super.currentTime(), this._min, this._max);
        }

        public jumpToValue(value: number) {
            super.jumpToTime(normalize(value, this._min, this._max));
        }

        public tweenToValue(value: number) {
            super.tweenToTime(normalize(value, this._min, this._max));
        }
    }
    */

    /**
     * Checks if specific index fits into length.
     *
     * @param index  Index
     * @param len    Length
     * @ignore
     */
    function checkBounds(index, len) {
        if (!(index >= 0 && index < len)) {
            throw new Error("Index out of bounds: " + index);
        }
    }
    /**
     * A List class is used to hold a number of indexed items of the same type.
     */
    class List {
        /**
         * Constructor
         *
         * @param initial  Inital list of values to add to list
         */
        constructor(initial = []) {
            /**
             * List values.
             */
            Object.defineProperty(this, "_values", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "events", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new EventDispatcher()
            });
            this._values = initial;
        }
        /**
         * An array of values in the list.
         *
         * Do not use this property to add values. Rather use dedicated methods, like
         * `push()`, `removeIndex()`, etc.
         *
         * @readonly
         * @return List values
         */
        get values() {
            return this._values;
        }
        /**
         * Checks if list contains specific item reference.
         *
         * @param item  Item to search for
         * @return `true` if found, `false` if not found
         */
        contains(value) {
            return this._values.indexOf(value) !== -1;
        }
        /**
         * Removes specific item from the list.
         *
         * @param item An item to remove
         */
        removeValue(value) {
            let i = 0;
            let length = this._values.length;
            while (i < length) {
                // TODO handle NaN
                if (this._values[i] === value) {
                    this.removeIndex(i);
                    --length;
                }
                else {
                    ++i;
                }
            }
        }
        /**
         * Searches the list for specific item and returns its index.
         *
         * @param item  An item to search for
         * @return Index or -1 if not found
         */
        indexOf(value) {
            return indexOf(this._values, value);
        }
        /**
         * Number of items in list.
         *
         * @readonly
         * @return Number of items
         */
        get length() {
            return this._values.length;
        }
        /**
         * Checks if there's a value at specific index.
         *
         * @param index  Index
         * @return Value exists?
         */
        hasIndex(index) {
            return index >= 0 && index < this._values.length;
        }
        /**
         * Returns an item at specified index.
         *
         * @param index  Index
         * @return List item
         */
        getIndex(index) {
            return this._values[index];
        }
        _onPush(newValue) {
            if (this.events.isEnabled("push")) {
                this.events.dispatch("push", {
                    type: "push",
                    target: this,
                    newValue
                });
            }
        }
        _onInsertIndex(index, newValue) {
            if (this.events.isEnabled("insertIndex")) {
                this.events.dispatch("insertIndex", {
                    type: "insertIndex",
                    target: this,
                    index,
                    newValue
                });
            }
        }
        _onSetIndex(index, oldValue, newValue) {
            if (this.events.isEnabled("setIndex")) {
                this.events.dispatch("setIndex", {
                    type: "setIndex",
                    target: this,
                    index,
                    oldValue,
                    newValue
                });
            }
        }
        _onRemoveIndex(index, oldValue) {
            if (this.events.isEnabled("removeIndex")) {
                this.events.dispatch("removeIndex", {
                    type: "removeIndex",
                    target: this,
                    index,
                    oldValue
                });
            }
        }
        _onMoveIndex(oldIndex, newIndex, value) {
            if (this.events.isEnabled("moveIndex")) {
                this.events.dispatch("moveIndex", {
                    type: "moveIndex",
                    target: this,
                    oldIndex,
                    newIndex,
                    value,
                });
            }
        }
        _onClear(oldValues) {
            if (this.events.isEnabled("clear")) {
                this.events.dispatch("clear", {
                    type: "clear",
                    target: this,
                    oldValues
                });
            }
        }
        /**
         * Sets value at specific index.
         *
         * If there's already a value at the index, it is overwritten.
         *
         * @param index  Index
         * @param value  New value
         * @return New value
         */
        setIndex(index, value) {
            checkBounds(index, this._values.length);
            const oldValue = this._values[index];
            // Do nothing if the old value and the new value are the same
            if (oldValue !== value) {
                this._values[index] = value;
                this._onSetIndex(index, oldValue, value);
            }
            return oldValue;
        }
        /**
         * Adds an item to the list at a specific index, which pushes all the other
         * items further down the list.
         *
         * @param index Index
         * @param item  An item to add
         */
        insertIndex(index, value) {
            checkBounds(index, this._values.length + 1);
            insertIndex(this._values, index, value);
            this._onInsertIndex(index, value);
            return value;
        }
        /**
         * Swaps indexes of two items in the list.
         *
         * @param a  Item 1
         * @param b  Item 2
         */
        swap(a, b) {
            const len = this._values.length;
            checkBounds(a, len);
            checkBounds(b, len);
            if (a !== b) {
                const value_a = this._values[a];
                const value_b = this._values[b];
                this._values[a] = value_b;
                this._onSetIndex(a, value_a, value_b);
                this._values[b] = value_a;
                this._onSetIndex(b, value_b, value_a);
            }
        }
        /**
         * Removes a value at specific index.
         *
         * @param index  Index of value to remove
         * @return Removed value
         */
        removeIndex(index) {
            checkBounds(index, this._values.length);
            const oldValue = this._values[index];
            removeIndex(this._values, index);
            this._onRemoveIndex(index, oldValue);
            return oldValue;
        }
        /**
         * Moves an item to a specific index within the list.
         *
         * If the index is not specified it will move the item to the end of the
         * list.
         *
         * @param value  Item to move
         * @param index  Index to place item at
         */
        moveValue(value, toIndex) {
            // TODO don't do anything if the desired index is the same as the current index
            let index = this.indexOf(value);
            // TODO remove all old values rather than only the first ?
            if (index !== -1) {
                removeIndex(this._values, index);
                if (toIndex == null) {
                    const toIndex = this._values.length;
                    this._values.push(value);
                    this._onMoveIndex(index, toIndex, value);
                }
                else {
                    insertIndex(this._values, toIndex, value);
                    this._onMoveIndex(index, toIndex, value);
                }
            }
            else if (toIndex == null) {
                this._values.push(value);
                this._onPush(value);
            }
            else {
                insertIndex(this._values, toIndex, value);
                this._onInsertIndex(toIndex, value);
            }
            return value;
        }
        /**
         * Adds an item to the end of the list.
         *
         * @param item  An item to add
         */
        push(value) {
            this._values.push(value);
            this._onPush(value);
            return value;
        }
        /**
         * Adds an item as a first item in the list.
         *
         * @param item  An item to add
         */
        unshift(value) {
            this.insertIndex(0, value);
            return value;
        }
        /**
         * Adds multiple items to the list.
         *
         * @param items  An Array of items to add
         */
        pushAll(values) {
            each$1(values, (value) => {
                this.push(value);
            });
        }
        /**
         * Copies and adds items from abother list.
         *
         * @param source  A list top copy items from
         */
        copyFrom(source) {
            this.pushAll(source._values);
        }
        /**
         * Returns the last item from the list, and removes it.
         *
         * @return Item
         */
        pop() {
            let index = this._values.length - 1;
            return index < 0 ? undefined : this.removeIndex(this._values.length - 1);
        }
        /**
         * Returns the first item from the list, and removes it.
         *
         * @return Item
         */
        shift() {
            return this._values.length ? this.removeIndex(0) : undefined;
        }
        /**
         * Sets multiple items to the list.
         *
         * All current items are removed.
         *
         * @param newArray  New items
         */
        setAll(newArray) {
            const old = this._values;
            this._values = [];
            this._onClear(old);
            each$1(newArray, (value) => {
                this._values.push(value);
                this._onPush(value);
            });
        }
        /**
         * Removes all items from the list.
         */
        clear() {
            this.setAll([]);
        }
        /**
         * Returns an ES6 iterator for the list.
         */
        *[Symbol.iterator]() {
            const length = this._values.length;
            for (let i = 0; i < length; ++i) {
                yield this._values[i];
            }
        }
        /**
         * Calls `f` for each element in the list.
         *
         * `f` should have at least one parameter defined which will get a current
         * item, with optional second argument - index.
         */
        each(f) {
            each$1(this._values, f);
        }
        /**
         * Calls `f` for each element in the list, from right to left.
         *
         * `f` should have at least one parameter defined which will get a current
         * item, with optional second argument - index.
         */
        eachReverse(f) {
            eachReverse(this._values, f);
        }
    }
    /**
     * A version of a [[List]] where the elements are disposed automatically when
     * removed from the list, unless `autoDispose` is set to `false`.
     */
    class ListAutoDispose extends List {
        constructor() {
            super(...arguments);
            /**
             * Automatically disposes elements that are removed from the list.
             *
             * @default true
             */
            Object.defineProperty(this, "autoDispose", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "_disposed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        _onSetIndex(index, oldValue, newValue) {
            if (this.autoDispose) {
                oldValue.dispose();
            }
            super._onSetIndex(index, oldValue, newValue);
        }
        _onRemoveIndex(index, oldValue) {
            if (this.autoDispose) {
                oldValue.dispose();
            }
            super._onRemoveIndex(index, oldValue);
        }
        _onClear(oldValues) {
            if (this.autoDispose) {
                each$1(oldValues, (x) => {
                    x.dispose();
                });
            }
            super._onClear(oldValues);
        }
        isDisposed() {
            return this._disposed;
        }
        dispose() {
            if (!this._disposed) {
                this._disposed = true;
                if (this.autoDispose) {
                    each$1(this._values, (x) => {
                        x.dispose();
                    });
                }
            }
        }
    }
    /**
     * A version of a [[List]] that is able to create new elements as well as
     * apply additional settings to newly created items.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/list-templates/} for more info
     */
    class ListTemplate extends ListAutoDispose {
        constructor(template, make) {
            super();
            Object.defineProperty(this, "template", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "make", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.template = template;
            this.make = make;
        }
    }

    /**
     * A version of [[List]] to hold children of the [[Container]].
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info
     */
    class Children extends List {
        constructor(container) {
            super();
            Object.defineProperty(this, "_disposed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_container", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_events", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._container = container;
            this._events = this.events.onAll((change) => {
                if (change.type === "clear") {
                    each$1(change.oldValues, (x) => {
                        this._onRemoved(x);
                    });
                }
                else if (change.type === "push") {
                    this._onInserted(change.newValue);
                }
                else if (change.type === "setIndex") {
                    this._onRemoved(change.oldValue);
                    this._onInserted(change.newValue, change.index);
                }
                else if (change.type === "insertIndex") {
                    this._onInserted(change.newValue, change.index);
                }
                else if (change.type === "removeIndex") {
                    this._onRemoved(change.oldValue);
                }
                else if (change.type === "moveIndex") {
                    this._onRemoved(change.value);
                    this._onInserted(change.value, change.newIndex);
                }
                else {
                    throw new Error("Unknown IListEvent type");
                }
            });
        }
        _onInserted(child, index) {
            child._setParent(this._container, true);
            const childrenDisplay = this._container._childrenDisplay;
            if (index === undefined) {
                childrenDisplay.addChild(child._display);
            }
            else {
                childrenDisplay.addChildAt(child._display, index);
            }
        }
        _onRemoved(child) {
            this._container._childrenDisplay.removeChild(child._display);
            this._container.markDirtyBounds();
            this._container.markDirty();
        }
        /**
         * Returns `true` if obejct is disposed.
         */
        isDisposed() {
            return this._disposed;
        }
        /**
         * Permanently dispose this object.
         */
        dispose() {
            if (!this._disposed) {
                this._disposed = true;
                this._events.dispose();
                each$1(this.values, (child) => {
                    child.dispose();
                });
            }
        }
    }

    /**
     * ============================================================================
     * CONSTANTS
     * ============================================================================
     * @hidden
     */
    const PI = Math.PI;
    const HALFPI = PI / 2;
    const RADIANS = PI / 180;
    const DEGREES = 180 / PI;
    /**
     * Rounds the numeric value to whole number or specific precision of set.
     *
     * @param value      Value
     * @param precision  Precision (number of decimal points)
     * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.
     * @return Rounded value
     */
    function round$1(value, precision, floor) {
        if (!isNumber(precision) || precision <= 0) {
            let rounded = Math.round(value);
            if (floor) {
                if (rounded - value == 0.5) {
                    rounded--;
                }
            }
            return rounded;
        }
        else {
            let d = Math.pow(10, precision);
            return Math.round(value * d) / d;
        }
    }
    /**
     * Ceils the numeric value to whole number or specific precision of set.
     *
     * @param value      Value
     * @param precision  Precision (number of decimal points)
     * @return Rounded value
     */
    function ceil(value, precision) {
        if (!isNumber(precision) || precision <= 0) {
            return Math.ceil(value);
        }
        else {
            let d = Math.pow(10, precision);
            return Math.ceil(value * d) / d;
        }
    }
    /**
     * [getCubicControlPointA description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param p0        [description]
     * @param p1        [description]
     * @param p2        [description]
     * @param p3        [description]
     * @param tensionX  [description]
     * @param tensionY  [description]
     * @return [description]
     */
    function getCubicControlPointA(p0, p1, p2, tensionX, tensionY) {
        return { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };
    }
    /**
     * [getCubicControlPointB description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param p0        [description]
     * @param p1        [description]
     * @param p2        [description]
     * @param p3        [description]
     * @param tensionX  [description]
     * @param tensionY  [description]
     * @return [description]
     */
    function getCubicControlPointB(p1, p2, p3, tensionX, tensionY) {
        return { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };
    }
    function fitToRange(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }
    /**
     * Returns sine of an angle specified in degrees.
     *
     * @param value  Value
     * @return Sine
     */
    function sin(angle) {
        return Math.sin(RADIANS * angle);
    }
    /**
     * Returns tan of an angle specified in degrees.
     *
     * @param value  Value
     * @return Sine
     */
    function tan(angle) {
        return Math.tan(RADIANS * angle);
    }
    /**
     * Returns cosine of an angle specified in degrees.
     *
     * @param value  Value
     * @return Cosine
     */
    function cos(angle) {
        return Math.cos(RADIANS * angle);
    }
    // 0 to 360
    function normalizeAngle(value) {
        value = value % 360;
        if (value < 0) {
            value += 360;
        }
        return value;
    }
    // TODO this doesn't work properly for skewing, and it's probably broken for rotation too
    function getArcBounds(cx, cy, startAngle, endAngle, radius) {
        let minX = Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        let maxX = -Number.MAX_VALUE;
        let maxY = -Number.MAX_VALUE;
        let bpoints = [];
        bpoints.push(getArcPoint(radius, startAngle));
        bpoints.push(getArcPoint(radius, endAngle));
        let fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);
        let toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);
        for (let angle = fromAngle; angle <= toAngle; angle += 90) {
            if (angle >= startAngle && angle <= endAngle) {
                bpoints.push(getArcPoint(radius, angle));
            }
        }
        for (let i = 0; i < bpoints.length; i++) {
            let pt = bpoints[i];
            if (pt.x < minX) {
                minX = pt.x;
            }
            if (pt.y < minY) {
                minY = pt.y;
            }
            if (pt.x > maxX) {
                maxX = pt.x;
            }
            if (pt.y > maxY) {
                maxY = pt.y;
            }
        }
        return ({ left: cx + minX, top: cy + minY, right: cx + maxX, bottom: cy + maxY });
    }
    /**
     * Returns point on arc
     *
     * @param center point
     * @param radius
     * @param arc
     * @return {boolean}
     */
    function getArcPoint(radius, arc) {
        return ({ x: radius * cos(arc), y: radius * sin(arc) });
    }
    function mergeBounds(bounds) {
        const len = bounds.length;
        if (len > 0) {
            let bound = bounds[0];
            let left = bound.left;
            let top = bound.top;
            let right = bound.right;
            let bottom = bound.bottom;
            if (len > 1) {
                for (let i = 1; i < len; i++) {
                    bound = bounds[i];
                    left = Math.min(bound.left, left);
                    right = Math.max(bound.right, right);
                    top = Math.min(bound.top, top);
                    bottom = Math.max(bound.bottom, bottom);
                }
            }
            return { left, right, top, bottom };
        }
        return { left: 0, right: 0, top: 0, bottom: 0 };
    }
    function fitAngleToRange(value, startAngle, endAngle) {
        if (startAngle > endAngle) {
            let temp = startAngle;
            startAngle = endAngle;
            endAngle = temp;
        }
        value = normalizeAngle(value);
        let count = (startAngle - normalizeAngle(startAngle)) / 360;
        if (value < startAngle) {
            value += 360 * (count + 1);
        }
        let maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;
        let maxStart = startAngle + (endAngle - startAngle) / 2 - 180;
        if (value > endAngle) {
            if (value - 360 > startAngle) {
                value -= 360;
            }
            else {
                if (value < maxEnd) {
                    value = endAngle;
                }
                else {
                    value = startAngle;
                }
            }
        }
        if (value < startAngle) {
            if (value > maxStart) {
                value = startAngle;
            }
            else {
                value = endAngle;
            }
        }
        return value;
    }
    function inBounds(point, bounds) {
        if (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {
            return true;
        }
        return false;
    }
    function getAngle(point1, point2) {
        if (!point2) {
            point2 = { x: point1.x * 2, y: point1.y * 2 };
        }
        let diffX = point2.x - point1.x;
        let diffY = point2.y - point1.y;
        let angle = Math.atan2(diffY, diffX) * DEGREES;
        if (angle < 0) {
            angle += 360;
        }
        return normalizeAngle(angle);
    }
    /**
     * [getPointOnQuadraticCurve description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param pointA        [description]
     * @param pointB        [description]
     * @param controlPoint  [description]
     * @param position      [description]
     * @return [description]
     */
    function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {
        let x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;
        let y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;
        return { x: x, y: y };
    }
    function getPointOnLine(pointA, pointB, position) {
        return { x: pointA.x + (pointB.x - pointA.x) * position, y: pointA.y + (pointB.y - pointA.y) * position };
    }
    /**
     * Returns the closest value from the array of values to the reference value.
     *
     * @param values  Array of values
     * @param value   Reference value
     * @return Closes value from the array
     */
    function closest(values, referenceValue) {
        return values.reduce(function (prev, curr) {
            return (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);
        });
    }
    /**
     * Returns true if bounds overlap
     * @param bounds1 IBounds
     * @param bounds2 IBounds
     * @returns boolean
     */
    function boundsOverlap(bounds1, bounds2) {
        const horizontalOverlap = bounds1.left < bounds2.right && bounds1.right > bounds2.left;
        const verticalOverlap = bounds1.top < bounds2.bottom && bounds1.bottom > bounds2.top;
        return horizontalOverlap && verticalOverlap;
    }
    /**
     * Generates points of a spiral
     * @param cx
     * @param cy
     * @param radius
     * @param radiusY
     * @param innerRadius
     * @param step
     * @param radiusStep
     * @param startAngle
     * @param endAngle
     * @returns IPoint[]
     */
    function spiralPoints(cx, cy, radius, radiusY, innerRadius, step, radiusStep, startAngle, endAngle) {
        let r = innerRadius + 0.01;
        let angle = startAngle * RADIANS;
        let points = [];
        while (r < radius + radiusStep) {
            let stepSize = step;
            if (stepSize / 2 > r) {
                stepSize = 2 * r;
            }
            angle += 2 * Math.asin(stepSize / 2 / r);
            if (angle * DEGREES > endAngle + ((radius - innerRadius) / radiusStep) * 360) {
                break;
            }
            let degrees = angle * DEGREES;
            let point = { x: cx + r * Math.cos(angle), y: cy + r * radiusY / radius * Math.sin(angle) };
            points.push(point);
            r = innerRadius + degrees / 360 * radiusStep;
        }
        points.shift();
        return points;
    }
    /**
     * Returns true if circles overlap
     * @param circle1
     * @param circle2
     * @returns boolean
     */
    function circlesOverlap(circle1, circle2) {
        return Math.hypot(circle1.x - circle2.x, circle1.y - circle2.y) <= circle1.radius + circle2.radius;
    }

    var Math$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DEGREES: DEGREES,
        HALFPI: HALFPI,
        PI: PI,
        RADIANS: RADIANS,
        boundsOverlap: boundsOverlap,
        ceil: ceil,
        circlesOverlap: circlesOverlap,
        closest: closest,
        cos: cos,
        fitAngleToRange: fitAngleToRange,
        fitToRange: fitToRange,
        getAngle: getAngle,
        getArcBounds: getArcBounds,
        getArcPoint: getArcPoint,
        getCubicControlPointA: getCubicControlPointA,
        getCubicControlPointB: getCubicControlPointB,
        getPointOnLine: getPointOnLine,
        getPointOnQuadraticCurve: getPointOnQuadraticCurve,
        inBounds: inBounds,
        mergeBounds: mergeBounds,
        normalizeAngle: normalizeAngle,
        round: round$1,
        sin: sin,
        spiralPoints: spiralPoints,
        tan: tan
    });

    /**
     * A collection of easing functions
     *
     * Parts of this collection are taken from D3.js library (https://d3js.org/)
     */
    /**
     * ============================================================================
     * IMPORTS
     * ============================================================================
     * @hidden
     */
    /**
     * The functions below are from D3.js library (https://d3js.org/)
     *
     * ----------------------------------------------------------------------------
     * Copyright 2017 Mike Bostock
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     *	this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *	this list of conditions and the following disclaimer in the documentation
     *	and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its
     *	contributors may be used to endorse or promote products derived from this
     *	software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     * ----------------------------------------------------------------------------
     * @hidden
     */
    /**
     */
    function linear(t) {
        return t;
    }
    function quad(t) {
        return t * t;
    }
    function cubic(t) {
        return t * t * t;
    }
    function pow(t, e) {
        return Math.pow(t, e);
    }
    function exp(t) {
        return Math.pow(2, 10 * t - 10);
    }
    function sine(t) {
        return 1 - Math.cos(t * HALFPI);
    }
    function circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    /**
     * ============================================================================
     * TRANSFORMERS
     * ============================================================================
     * @hidden
     */
    /**
     */
    function yoyo(ease) {
        return function (t) {
            if (t < 0.5) {
                return ease(t * 2.0);
            }
            else {
                return ease((1.0 - t) * 2.0);
            }
        };
    }
    function out(ease) {
        return function (t) {
            return 1.0 - ease(1.0 - t);
        };
    }
    function inOut(ease) {
        return function (t) {
            if (t <= 0.5) {
                return ease(t * 2.0) / 2.0;
            }
            else {
                return 1.0 - (ease((1.0 - t) * 2.0) / 2.0);
            }
        };
    }
    /**
     * ============================================================================
     * BOUNCE
     * ============================================================================
     * @hidden
     */
    let b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
    function bounce(t) {
        return 1 - bounceOut(1 - t);
    }
    /**
     * @ignore
     */
    function bounceOut(t) {
        t = t;
        if (t < b1) {
            return b0 * t * t;
        }
        else if (t < b3) {
            return b0 * (t -= b2) * t + b4;
        }
        else if (t < b6) {
            return b0 * (t -= b5) * t + b7;
        }
        else {
            return b0 * (t -= b8) * t + b9;
        }
    }
    /**
     * ============================================================================
     * ELASTIC
     * ============================================================================
     * @hidden
     */
    /**
     * @ignore
     */
    let tau = 2 * Math.PI;
    /**
     * @ignore
     */
    let amplitude = 1;
    /**
     * @ignore
     */
    let period = 0.3 / tau;
    /**
     * @ignore
     */
    let s = Math.asin(1 / amplitude) * period;
    function elastic(t) {
        let v = t;
        return amplitude * Math.pow(2, 10 * --v) * Math.sin((s - v) / period);
    }

    var Ease = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bounce: bounce,
        circle: circle,
        cubic: cubic,
        elastic: elastic,
        exp: exp,
        inOut: inOut,
        linear: linear,
        out: out,
        pow: pow,
        quad: quad,
        sine: sine,
        yoyo: yoyo
    });

    /**
     * An object representing a collection of setting values to apply as required.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info
     */
    class State {
        constructor(entity, settings) {
            Object.defineProperty(this, "_entity", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_settings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_userSettings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            this._entity = entity;
            this._settings = settings;
            each(settings, (key) => {
                this._userSettings[key] = true;
            });
        }
        get(key, fallback) {
            const value = this._settings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
        /**
         * @ignore
         */
        setRaw(key, value) {
            this._settings[key] = value;
        }
        /**
         * Sets a setting `value` for the specified `key` to be set when the state
         * is applied.
         *
         * @param   key       Setting key
         * @param   value     Setting value
         * @return            Setting value
         */
        set(key, value) {
            this._userSettings[key] = true;
            this.setRaw(key, value);
        }
        /**
         * Removes a setting value for the specified `key`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         * @param   key       Setting key
         */
        remove(key) {
            delete this._userSettings[key];
            delete this._settings[key];
        }
        /**
         * Sets multiple settings at once.
         *
         * `settings` must be an object with key: value pairs.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         * @param settings Settings
         */
        setAll(settings) {
            keys(settings).forEach((key) => {
                this.set(key, settings[key]);
            });
        }
        _eachSetting(f) {
            each(this._settings, f);
        }
        /**
         * Applies the state to the target element.
         *
         * All setting values are set immediately.
         */
        apply() {
            const seen = {};
            seen["stateAnimationEasing"] = true;
            seen["stateAnimationDuration"] = true;
            const defaultState = this._entity.states.lookup("default");
            this._eachSetting((key, value) => {
                if (!seen[key]) {
                    seen[key] = true;
                    // save values to default state
                    if (this !== defaultState) {
                        if (!(key in defaultState._settings)) {
                            defaultState._settings[key] = this._entity.get(key);
                        }
                    }
                    this._entity.set(key, value);
                }
            });
        }
        /**
         * Applies the state to the target element.
         *
         * Returns an object representing all [[Animation]] objects created for
         * each setting key transition.
         *
         * @return           Animations
         */
        applyAnimate(duration) {
            if (duration == null) {
                duration = this._settings.stateAnimationDuration;
            }
            if (duration == null) {
                duration = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0));
            }
            let easing = this._settings.stateAnimationEasing;
            if (easing == null) {
                easing = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", cubic));
            }
            const defaultState = this._entity.states.lookup("default");
            const seen = {};
            seen["stateAnimationEasing"] = true;
            seen["stateAnimationDuration"] = true;
            const animations = {};
            this._eachSetting((key, value) => {
                if (!seen[key]) {
                    seen[key] = true;
                    // save values to default state
                    if (this != defaultState) {
                        if (!(key in defaultState._settings)) {
                            defaultState._settings[key] = this._entity.get(key);
                        }
                    }
                    const animation = this._entity.animate({
                        key: key,
                        to: value,
                        duration: duration,
                        easing: easing
                    });
                    if (animation) {
                        animations[key] = animation;
                    }
                }
            });
            return animations;
        }
    }
    /**
     * Collection of [[State]] objects for an element.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info
     */
    class States {
        constructor(entity) {
            Object.defineProperty(this, "_states", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_entity", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._entity = entity;
        }
        /**
         * Checks if a state by `name` exists. Returns it there is one.
         *
         * @param  name  State name
         * @return       State
         */
        lookup(name) {
            return this._states[name];
        }
        /**
         * Sets supplied `settings` on a state by the `name`.
         *
         * If such state does not yet exists, it is created.
         *
         * @param   name      State name
         * @param   settings  Settings
         * @return            New State
         */
        create(name, settings) {
            const state = this._states[name];
            if (state) {
                state.setAll(settings);
                return state;
            }
            else {
                const state = new State(this._entity, settings);
                this._states[name] = state;
                return state;
            }
        }
        /**
         * Removes the state called `name`.
         *
         * @param   name      State name
         */
        remove(name) {
            delete this._states[name];
        }
        /**
         * Applies a named state to the target element.
         *
         * @param  newState  State name
         */
        apply(newState) {
            const state = this._states[newState];
            if (state) {
                state.apply();
            }
            this._entity._applyState(newState);
        }
        /**
         * Applies a named state to the element.
         *
         * Returns an object representing all [[Animation]] objects created for
         * each setting key transition.
         *
         * @param   newState  State name
         * @return            Animations
         */
        applyAnimate(newState, duration) {
            let animations;
            const state = this._states[newState];
            if (state) {
                animations = state.applyAnimate(duration);
            }
            this._entity._applyStateAnimated(newState, duration);
            return animations;
        }
    }

    /**
     * @ignore
     */
    class Registry {
        constructor() {
            /**
             * Currently running version of amCharts.
             */
            Object.defineProperty(this, "version", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: "5.10.1"
            });
            /**
             * List of applied licenses.
             * @ignore
             */
            Object.defineProperty(this, "licenses", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            /**
             * Entities that have their `id` setting set.
             */
            Object.defineProperty(this, "entitiesById", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            /**
             * All created [[Root]] elements.
             */
            Object.defineProperty(this, "rootElements", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
        }
    }
    /**
        * @ignore
     */
    const registry = new Registry();
    /**
     * Adds a license, e.g.:
     *
     * ```TypeScript
     * am5.addLicense("xxxxxxxx");
     * ```
     * ```JavaScript
     * am5.addLicense("xxxxxxxx");
     * ```
     *
     * Multiple licenses can be added to cover for multiple products.
     *
     * @param  license  License key
     */
    function addLicense(license) {
        registry.licenses.push(license);
    }
    /**
     * Disposes all [[Root]] elements.
     */
    function disposeAllRootElements() {
        let root;
        while (root = registry.rootElements.pop()) {
            root.dispose();
        }
    }
    /**
     * Finds and returns a `Root` element assigned to a container with `id`.
     *
     * @param   id  Container ID
     * @return      Root
     * @since 5.9.2
     */
    function getRootById(id) {
        let found;
        registry.rootElements.forEach((item) => {
            if (item.dom.id == id) {
                found = item;
            }
        });
        return found;
    }

    /**
     * @ignore
     */
    function compare(left, right) {
        if (left === right) {
            return 0;
        }
        else if (left < right) {
            return -1;
        }
        else {
            return 1;
        }
    }
    /**
     * @ignore
     */
    function compareArray(left, right, f) {
        const leftLength = left.length;
        const rightLength = right.length;
        const length = Math.min(leftLength, rightLength);
        for (let i = 0; i < length; ++i) {
            const order = f(left[i], right[i]);
            if (order !== 0) {
                return order;
            }
        }
        return compare(leftLength, rightLength);
    }
    /**
     * @ignore
     */
    function compareNumber(a, b) {
        if (a === b) {
            return 0;
        }
        else if (a < b) {
            return -1;
        }
        else {
            return 1;
        }
    }

    /**
     * Allows to dynamically modify setting value of its target element.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
     */
    class Adapters {
        constructor(entity) {
            Object.defineProperty(this, "_entity", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_callbacks", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_disabled", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            this._entity = entity;
        }
        /**
         * Add a function (`callback`) that will modify value for setting `key`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
         */
        add(key, callback) {
            let callbacks = this._callbacks[key];
            if (callbacks === undefined) {
                callbacks = this._callbacks[key] = [];
            }
            callbacks.push(callback);
            this._entity._markDirtyKey(key);
            return new Disposer(() => {
                if (removeFirst(callbacks, callback)) {
                    this._entity._markDirtyKey(key);
                }
            });
        }
        /**
         * Removes all adapters for the specific key.
         *
         * @since 5.1.0
         */
        remove(key) {
            const callbacks = this._callbacks[key];
            if (callbacks !== undefined) {
                delete this._callbacks[key];
                if (callbacks.length !== 0) {
                    this._entity._markDirtyKey(key);
                }
            }
        }
        /**
         * Enables (previously disabled) adapters for specific key.
         *
         * @since 5.1.0
         */
        enable(key) {
            if (this._disabled[key]) {
                delete this._disabled[key];
                this._entity._markDirtyKey(key);
            }
        }
        /**
         * Disables all adapters for specific key.
         *
         * @since 5.1.0
         */
        disable(key) {
            if (!this._disabled[key]) {
                this._disabled[key] = true;
                this._entity._markDirtyKey(key);
            }
        }
        /**
         * @ignore
         */
        fold(key, value) {
            if (!this._disabled[key]) {
                const callbacks = this._callbacks[key];
                if (callbacks !== undefined) {
                    for (let i = 0, len = callbacks.length; i < len; ++i) {
                        value = callbacks[i](value, this._entity, key);
                    }
                }
            }
            return value;
        }
    }
    /**
     * Animation object.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/} for more info
     */
    class Animation {
        constructor(animation, from, to, duration, easing, loops, startingTime) {
            Object.defineProperty(this, "_animation", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_from", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_to", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_duration", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_easing", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_loops", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_interpolate", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_oldTime", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_time", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_stopped", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_playing", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "events", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new EventDispatcher()
            });
            this._animation = animation;
            this._from = from;
            this._to = to;
            this._duration = duration;
            this._easing = easing;
            this._loops = loops;
            this._interpolate = getInterpolate(from, to);
            this._oldTime = startingTime;
        }
        get to() {
            return this._to;
        }
        get from() {
            return this._from;
        }
        get playing() {
            return this._playing;
        }
        get stopped() {
            return this._stopped;
        }
        stop() {
            if (!this._stopped) {
                this._stopped = true;
                this._playing = false;
                if (this.events.isEnabled("stopped")) {
                    this.events.dispatch("stopped", {
                        type: "stopped",
                        target: this,
                    });
                }
            }
        }
        pause() {
            this._playing = false;
            this._oldTime = null;
        }
        play() {
            if (!this._stopped && !this._playing) {
                this._playing = true;
                this._animation._startAnimation();
            }
        }
        get percentage() {
            return this._time / this._duration;
        }
        waitForStop() {
            return new Promise((resolve, _reject) => {
                if (this._stopped) {
                    resolve();
                }
                else {
                    const listener = () => {
                        stopped.dispose();
                        resolve();
                    };
                    const stopped = this.events.on("stopped", listener);
                }
            });
        }
        _checkEnded() {
            if (this._loops > 1) {
                --this._loops;
                return false;
            }
            else {
                return true;
            }
        }
        _run(currentTime) {
            if (this._oldTime !== null) {
                this._time += currentTime - this._oldTime;
                if (this._time > this._duration) {
                    this._time = this._duration;
                }
            }
            this._oldTime = currentTime;
        }
        _reset(currentTime) {
            this._oldTime = currentTime;
            this._time = 0;
        }
        _value(diff) {
            return this._interpolate(this._easing(diff), this._from, this._to);
        }
    }
    /**
     * @ignore
     */
    let counter = 0;
    /**
     * Base class for [[Entity]] objects that support Settings.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     */
    class Settings {
        constructor(settings) {
            /**
             * Unique ID.
             */
            Object.defineProperty(this, "uid", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: ++counter
            });
            Object.defineProperty(this, "_settings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_privateSettings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_settingEvents", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_privateSettingEvents", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_prevSettings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_prevPrivateSettings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_animatingSettings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_animatingPrivateSettings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_disposed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            // TODO move this into Entity
            Object.defineProperty(this, "_userProperties", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            this._settings = settings;
        }
        _checkDirty() {
            keys(this._settings).forEach((key) => {
                this._userProperties[key] = true;
                this._markDirtyKey(key);
            });
        }
        /**
         * @ignore
         */
        resetUserSettings() {
            this._userProperties = {};
        }
        _runAnimation(currentTime) {
            let state = AnimationState.Stopped;
            if (!this.isDisposed()) {
                let playing = false;
                let paused = false;
                each(this._animatingSettings, (key, animation) => {
                    if (animation.stopped) {
                        this._stopAnimation(key);
                    }
                    else if (animation.playing) {
                        animation._run(currentTime);
                        const diff = animation.percentage;
                        if (diff >= 1) {
                            if (animation._checkEnded()) {
                                this.set(key, animation._value(1));
                            }
                            else {
                                playing = true;
                                animation._reset(currentTime);
                                this._set(key, animation._value(1));
                            }
                        }
                        else {
                            playing = true;
                            this._set(key, animation._value(diff));
                        }
                    }
                    else {
                        paused = true;
                    }
                });
                each(this._animatingPrivateSettings, (key, animation) => {
                    if (animation.stopped) {
                        this._stopAnimationPrivate(key);
                    }
                    else if (animation.playing) {
                        animation._run(currentTime);
                        const diff = animation.percentage;
                        if (diff >= 1) {
                            if (animation._checkEnded()) {
                                this.setPrivate(key, animation._value(1));
                            }
                            else {
                                playing = true;
                                animation._reset(currentTime);
                                this._setPrivate(key, animation._value(1));
                            }
                        }
                        else {
                            playing = true;
                            this._setPrivate(key, animation._value(diff));
                        }
                    }
                    else {
                        paused = true;
                    }
                });
                if (playing) {
                    state = AnimationState.Playing;
                }
                else if (paused) {
                    state = AnimationState.Paused;
                }
            }
            return state;
        }
        _markDirtyKey(_key) {
            this.markDirty();
        }
        _markDirtyPrivateKey(_key) {
            this.markDirty();
        }
        /**
         * Sets a callback function to invoke when specific key of settings changes
         * or is set.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
         * @param   key       Settings key
         * @param   callback  Callback
         * @return            Disposer for event
         */
        on(key, callback) {
            let events = this._settingEvents[key];
            if (events === undefined) {
                events = this._settingEvents[key] = [];
            }
            events.push(callback);
            return new Disposer(() => {
                removeFirst(events, callback);
                if (events.length === 0) {
                    delete this._settingEvents[key];
                }
            });
        }
        /**
         * Removes a callback for when value of a setting changes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
         * @param   key       Private settings key
         * @param   callback  Callback
         * @since 5.9.2
         */
        off(key, callback) {
            let events = this._settingEvents[key];
            if (events !== undefined && callback !== undefined) {
                removeFirst(events, callback);
            }
            else {
                delete this._settingEvents[key];
            }
        }
        /**
         * Sets a callback function to invoke when specific key of private settings
         * changes or is set.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
         * @param   key       Private settings key
         * @param   callback  Callback
         * @return            Disposer for event
         */
        onPrivate(key, callback) {
            let events = this._privateSettingEvents[key];
            if (events === undefined) {
                events = this._privateSettingEvents[key] = [];
            }
            events.push(callback);
            return new Disposer(() => {
                removeFirst(events, callback);
                if (events.length === 0) {
                    delete this._privateSettingEvents[key];
                }
            });
        }
        /**
         * Removes a callback for when value of a private setting changes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
         * @param   key       Private settings key
         * @param   callback  Callback
         * @since 5.9.2
         */
        offPrivate(key, callback) {
            let events = this._privateSettingEvents[key];
            if (events !== undefined && callback !== undefined) {
                removeFirst(events, callback);
            }
            else {
                delete this._privateSettingEvents[key];
            }
        }
        /**
         * @ignore
         */
        getRaw(key, fallback) {
            const value = this._settings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
        /**
         * Returns `true` if the setting exists.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         * @param   key        Settings key
         * @return  {boolean}  Key exists
         */
        has(key) {
            return key in this._settings;
        }
        get(key, fallback) {
            return this.getRaw(key, fallback);
        }
        _sendKeyEvent(key, value) {
            const events = this._settingEvents[key];
            if (events !== undefined) {
                each$1(events, (callback) => {
                    callback(value, this, key);
                });
            }
        }
        _sendPrivateKeyEvent(key, value) {
            const events = this._privateSettingEvents[key];
            if (events !== undefined) {
                each$1(events, (callback) => {
                    callback(value, this, key);
                });
            }
        }
        /**
         * @ignore
         */
        _setRaw(key, old, value) {
            this._prevSettings[key] = old;
            this._sendKeyEvent(key, value);
        }
        /**
         * @ignore
         */
        setRaw(key, value) {
            const old = this._settings[key];
            this._settings[key] = value;
            if (old !== value) {
                this._setRaw(key, old, value);
            }
        }
        /**
         * @ignore
         */
        _set(key, value) {
            const old = this._settings[key];
            this._settings[key] = value;
            if (old !== value) {
                this._setRaw(key, old, value);
                this._markDirtyKey(key);
            }
        }
        _stopAnimation(key) {
            const animation = this._animatingSettings[key];
            if (animation) {
                delete this._animatingSettings[key];
                animation.stop();
            }
        }
        /**
         * Sets a setting `value` for the specified `key`, and returns the same `value`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         * @param   key       Setting key
         * @param   value     Setting value
         * @return            Setting value
         */
        set(key, value) {
            this._set(key, value);
            this._stopAnimation(key);
            return value;
        }
        /**
         * Removes a setting value for the specified `key`;
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         * @param   key       Setting key
         */
        remove(key) {
            if (key in this._settings) {
                this._prevSettings[key] = this._settings[key];
                delete this._settings[key];
                this._sendKeyEvent(key, undefined);
                this._markDirtyKey(key);
            }
            this._stopAnimation(key);
        }
        /**
         * Removes all keys;
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         */
        removeAll() {
            each$1(keys(this._settings), (key) => {
                this.remove(key);
            });
        }
        /**
         * Returns a value of a private setting.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/#Private_settings} for more info
         */
        getPrivate(key, fallback) {
            const value = this._privateSettings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
        /**
         * @ignore
         */
        _setPrivateRaw(key, old, value) {
            this._prevPrivateSettings[key] = old;
            this._sendPrivateKeyEvent(key, value);
        }
        /**
         * @ignore
         */
        setPrivateRaw(key, value) {
            const old = this._privateSettings[key];
            this._privateSettings[key] = value;
            if (old !== value) {
                this._setPrivateRaw(key, old, value);
            }
        }
        /**
         * @ignore
         */
        _setPrivate(key, value) {
            const old = this._privateSettings[key];
            this._privateSettings[key] = value;
            if (old !== value) {
                this._setPrivateRaw(key, old, value);
                this._markDirtyPrivateKey(key);
            }
        }
        _stopAnimationPrivate(key) {
            const animation = this._animatingPrivateSettings[key];
            if (animation) {
                animation.stop();
                delete this._animatingPrivateSettings[key];
            }
        }
        /**
         * @ignore
         */
        setPrivate(key, value) {
            this._setPrivate(key, value);
            this._stopAnimationPrivate(key);
            return value;
        }
        /**
         * @ignore
         */
        removePrivate(key) {
            if (key in this._privateSettings) {
                this._prevPrivateSettings[key] = this._privateSettings[key];
                delete this._privateSettings[key];
                this._markDirtyPrivateKey(key);
            }
            this._stopAnimationPrivate(key);
        }
        /**
         * Sets multiple settings at once.
         *
         * `settings` must be an object with key: value pairs.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         * @param settings Settings
         */
        setAll(settings) {
            each(settings, (key, value) => {
                this.set(key, value);
            });
        }
        /**
         * Animates setting values from current/start values to new ones.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Animating_settings} for more info
         * @param   options  Animation options
         * @return           Animation object
         */
        animate(options) {
            const key = options.key;
            const to = options.to;
            const duration = options.duration || 0;
            const loops = options.loops || 1;
            const from = (options.from === undefined ? this.get(key) : options.from);
            const easing = (options.easing === undefined ? linear : options.easing);
            if (duration === 0) {
                this.set(key, to);
            }
            else {
                if (from === undefined || from === to) {
                    this.set(key, to);
                }
                else {
                    this.set(key, from);
                    const animation = this._animatingSettings[key] = new Animation(this, from, to, duration, easing, loops, this._animationTime());
                    this._startAnimation();
                    return animation;
                }
            }
            const animation = new Animation(this, from, to, duration, easing, loops, null);
            animation.stop();
            return animation;
        }
        /**
         * @ignore
         */
        animatePrivate(options) {
            const key = options.key;
            const to = options.to;
            const duration = options.duration || 0;
            const loops = options.loops || 1;
            const from = (options.from === undefined ? this.getPrivate(key) : options.from);
            const easing = (options.easing === undefined ? linear : options.easing);
            if (duration === 0) {
                this.setPrivate(key, to);
            }
            else {
                if (from === undefined || from === to) {
                    this.setPrivate(key, to);
                }
                else {
                    this.setPrivate(key, from);
                    const animation = this._animatingPrivateSettings[key] = new Animation(this, from, to, duration, easing, loops, this._animationTime());
                    this._startAnimation();
                    return animation;
                }
            }
            const animation = new Animation(this, from, to, duration, easing, loops, null);
            animation.stop();
            return animation;
        }
        _dispose() { }
        /**
         * Returns `true` if this element is disposed.
         *
         * @return Disposed
         */
        isDisposed() {
            return this._disposed;
        }
        /**
         * Disposes this object.
         */
        dispose() {
            if (!this._disposed) {
                this._disposed = true;
                this._dispose();
            }
        }
    }
    /**
     * Base class.
     *
     * @important
     */
    class Entity extends Settings {
        /**
         * IMPORTANT! Do not instantiate this class via `new Class()` syntax.
         *
         * Use static method `Class.new()` instead.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
         * @ignore
         */
        constructor(root, settings, isReal, templates = []) {
            super(settings);
            Object.defineProperty(this, "_root", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_user_id", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            }); // for testing purposes
            Object.defineProperty(this, "states", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new States(this)
            });
            Object.defineProperty(this, "adapters", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new Adapters(this)
            });
            Object.defineProperty(this, "events", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._createEvents()
            });
            Object.defineProperty(this, "_userPrivateProperties", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_dirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_dirtyPrivate", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_template", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // Templates for the themes
            Object.defineProperty(this, "_templates", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            // Internal templates which can be overridden by the user's templates
            Object.defineProperty(this, "_internalTemplates", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // Default themes which can be overridden by the user's themes
            Object.defineProperty(this, "_defaultThemes", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            // Disposers for all of the templates
            Object.defineProperty(this, "_templateDisposers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_disposers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            // Whether the template setup function should be run
            Object.defineProperty(this, "_runSetup", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "_disposerProperties", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            if (!isReal) {
                throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
            }
            this._root = root;
            this._internalTemplates = templates;
            if (settings.id) {
                this._registerId(settings.id);
            }
        }
        /**
         * Use this method to create an instance of this class.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
         * @param   root      Root element
         * @param   settings  Settings
         * @param   template  Template
         * @return            Instantiated object
         */
        static new(root, settings, template) {
            const x = (new this(root, settings, true));
            x._template = template;
            x._afterNew();
            return x;
        }
        static _new(root, settings, templates = []) {
            const x = (new this(root, settings, true, templates));
            x._afterNew();
            return x;
        }
        _afterNew() {
            this._checkDirty();
            let shouldApply = false;
            const template = this._template;
            if (template) {
                shouldApply = true;
                template._setObjectTemplate(this);
            }
            each$1(this._internalTemplates, (template) => {
                shouldApply = true;
                template._setObjectTemplate(this);
            });
            if (shouldApply) {
                this._applyTemplates(false);
            }
            this.states.create("default", {});
            this._setDefaults();
        }
        // This is the same as _afterNew, except it also applies the themes.
        // This should only be used for classes which don't have a parent (because they extend from Entity and not Sprite).
        _afterNewApplyThemes() {
            this._checkDirty();
            const template = this._template;
            if (template) {
                template._setObjectTemplate(this);
            }
            each$1(this._internalTemplates, (template) => {
                template._setObjectTemplate(this);
            });
            this.states.create("default", {});
            this._setDefaults();
            this._applyThemes();
        }
        _createEvents() {
            return new EventDispatcher();
        }
        /**
         * @ignore
         */
        get classNames() {
            return this.constructor.classNames;
        }
        /**
         * @ignore
         */
        get className() {
            return this.constructor.className;
        }
        _setDefaults() {
        }
        _setDefaultFn(key, f) {
            const value = this.get(key);
            if (value) {
                return value;
            }
            else {
                const value = f();
                this.set(key, value);
                return value;
            }
        }
        _setDefault(key, value) {
            if (!this.has(key)) {
                super.set(key, value);
            }
        }
        _setRawDefault(key, value) {
            if (!this.has(key)) {
                super.setRaw(key, value);
            }
        }
        _clearDirty() {
            keys(this._dirty).forEach((key) => {
                this._dirty[key] = false;
            });
            keys(this._dirtyPrivate).forEach((key) => {
                this._dirtyPrivate[key] = false;
            });
        }
        /**
         * @ignore
         */
        isDirty(key) {
            return !!this._dirty[key];
        }
        /**
         * @ignore
         */
        isPrivateDirty(key) {
            return !!this._dirtyPrivate[key];
        }
        _markDirtyKey(key) {
            this._dirty[key] = true;
            super._markDirtyKey(key);
        }
        _markDirtyPrivateKey(key) {
            this._dirtyPrivate[key] = true;
            super._markDirtyKey(key);
        }
        /**
         * Checks if element is of certain class (or inherits one).
         *
         * @param   type  Class name to check
         * @return {boolean} Is of class?
         */
        isType(type) {
            return this.classNames.indexOf(type) !== -1;
        }
        _pushPropertyDisposer(key, disposer) {
            let disposers = this._disposerProperties[key];
            if (disposers === undefined) {
                disposers = this._disposerProperties[key] = [];
            }
            disposers.push(disposer);
            return disposer;
        }
        _disposeProperty(key) {
            const disposers = this._disposerProperties[key];
            if (disposers !== undefined) {
                each$1(disposers, (disposer) => {
                    disposer.dispose();
                });
                delete this._disposerProperties[key];
            }
        }
        /**
         * @todo needs description
         * @param  value  Template
         */
        set template(value) {
            const template = this._template;
            if (template !== value) {
                this._template = value;
                if (template) {
                    template._removeObjectTemplate(this);
                }
                if (value) {
                    value._setObjectTemplate(this);
                }
                this._applyTemplates();
            }
        }
        get template() {
            return this._template;
        }
        /**
         * @ignore
         */
        markDirty() {
            this._root._addDirtyEntity(this);
        }
        _startAnimation() {
            this._root._addAnimation(this);
        }
        _animationTime() {
            return this._root.animationTime;
        }
        _applyState(_name) { }
        _applyStateAnimated(_name, _duration) { }
        get(key, fallback) {
            const value = this.adapters.fold(key, this._settings[key]);
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
        /**
         * @ignore
         */
        isUserSetting(key) {
            return this._userProperties[key] || false;
        }
        /**
         * Sets a setting `value` for the specified `key`, and returns the same `value`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         * @param   key       Setting key
         * @param   value     Setting value
         * @return            Setting value
         */
        set(key, value) {
            this._userProperties[key] = true;
            return super.set(key, value);
        }
        /**
         * @ignore
         */
        setRaw(key, value) {
            this._userProperties[key] = true;
            super.setRaw(key, value);
        }
        /**
         * Sets a setting `value` for the specified `key` only if the value for this key was not set previously using set method, and returns the same `value`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         * @param   key       Setting key
         * @param   value     Setting value
         * @return            Setting value
         */
        _setSoft(key, value) {
            if (!this._userProperties[key]) {
                return super.set(key, value);
            }
            return value;
        }
        /**
         * Removes a setting value for the specified `key`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
         * @param   key       Setting key
         */
        remove(key) {
            delete this._userProperties[key];
            this._removeTemplateProperty(key);
        }
        /**
         * @ignore
         */
        setPrivate(key, value) {
            this._userPrivateProperties[key] = true;
            return super.setPrivate(key, value);
        }
        /**
         * @ignore
         */
        setPrivateRaw(key, value) {
            this._userPrivateProperties[key] = true;
            super.setPrivateRaw(key, value);
        }
        /**
         * @ignore
         */
        removePrivate(key) {
            delete this._userPrivateProperties[key];
            this._removeTemplatePrivateProperty(key);
        }
        _setTemplateProperty(template, key, value) {
            if (!this._userProperties[key]) {
                const match = this._findTemplateByKey(key);
                if (template === match) {
                    super.set(key, value);
                }
            }
        }
        _setTemplatePrivateProperty(template, key, value) {
            if (!this._userPrivateProperties[key]) {
                const match = this._findTemplateByPrivateKey(key);
                if (template === match) {
                    super.setPrivate(key, value);
                }
            }
        }
        _removeTemplateProperty(key) {
            if (!this._userProperties[key]) {
                const match = this._findTemplateByKey(key);
                if (match) {
                    // TODO don't stop the animation if the property didn't change
                    super.set(key, match._settings[key]);
                }
                else {
                    super.remove(key);
                }
            }
        }
        _removeTemplatePrivateProperty(key) {
            if (!this._userPrivateProperties[key]) {
                const match = this._findTemplateByPrivateKey(key);
                if (match) {
                    // TODO don't stop the animation if the property didn't change
                    super.setPrivate(key, match._privateSettings[key]);
                }
                else {
                    super.removePrivate(key);
                }
            }
        }
        _walkParents(f) {
            f(this._root._rootContainer);
            f(this);
        }
        // TODO faster version of this method which is specialized to just 1 key
        _applyStateByKey(name) {
            const other = this.states.create(name, {});
            const seen = {};
            this._eachTemplate((template) => {
                const state = template.states.lookup(name);
                if (state) {
                    state._apply(other, seen);
                }
            });
            each(other._settings, (key) => {
                if (!seen[key] && !other._userSettings[key]) {
                    other.remove(key);
                }
            });
        }
        _applyTemplate(template, state) {
            this._templateDisposers.push(template._apply(this, state));
            each(template._settings, (key, value) => {
                if (!state.settings[key] && !this._userProperties[key]) {
                    state.settings[key] = true;
                    super.set(key, value);
                }
            });
            each(template._privateSettings, (key, value) => {
                if (!state.privateSettings[key] && !this._userPrivateProperties[key]) {
                    state.privateSettings[key] = true;
                    super.setPrivate(key, value);
                }
            });
            if (this._runSetup && template.setup) {
                this._runSetup = false;
                template.setup(this);
            }
        }
        /**
         * Calls the closure with each template and returns the first template which is true
         */
        _findStaticTemplate(f) {
            if (this._template) {
                if (f(this._template)) {
                    return this._template;
                }
            }
        }
        _eachTemplate(f) {
            this._findStaticTemplate((template) => {
                f(template);
                return false;
            });
            // _internalTemplates is sorted with most specific to the right
            eachReverse(this._internalTemplates, f);
            // _templates is sorted with most specific to the left
            each$1(this._templates, f);
        }
        _applyTemplates(remove = true) {
            if (remove) {
                this._disposeTemplates();
            }
            const state = {
                settings: {},
                privateSettings: {},
                states: {},
            };
            this._eachTemplate((template) => {
                this._applyTemplate(template, state);
            });
            if (remove) {
                each(this._settings, (key) => {
                    if (!this._userProperties[key] && !state.settings[key]) {
                        super.remove(key);
                    }
                });
                each(this._privateSettings, (key) => {
                    if (!this._userPrivateProperties[key] && !state.privateSettings[key]) {
                        super.removePrivate(key);
                    }
                });
            }
        }
        _findTemplate(f) {
            const value = this._findStaticTemplate(f);
            if (value === undefined) {
                // _internalTemplates is sorted with most specific to the right
                const value = findReverse(this._internalTemplates, f);
                if (value === undefined) {
                    // _templates is sorted with most specific to the left
                    return find(this._templates, f);
                }
                else {
                    return value;
                }
            }
            else {
                return value;
            }
        }
        _findTemplateByKey(key) {
            return this._findTemplate((template) => {
                return key in template._settings;
            });
        }
        _findTemplateByPrivateKey(key) {
            return this._findTemplate((template) => {
                return key in template._privateSettings;
            });
        }
        _disposeTemplates() {
            each$1(this._templateDisposers, (disposer) => {
                disposer.dispose();
            });
            this._templateDisposers.length = 0;
        }
        _removeTemplates() {
            each$1(this._templates, (template) => {
                template._removeObjectTemplate(this);
            });
            this._templates.length = 0;
        }
        _applyThemes(force = false) {
            let isConnected = false;
            const defaults = [];
            let themes = [];
            const themeTags = new Set();
            const tags = this.get("themeTagsSelf");
            if (tags) {
                each$1(tags, (tag) => {
                    themeTags.add(tag);
                });
            }
            this._walkParents((entity) => {
                if (entity === this._root._rootContainer) {
                    isConnected = true;
                }
                if (entity._defaultThemes.length > 0) {
                    defaults.push(entity._defaultThemes);
                }
                const theme = entity.get("themes");
                if (theme) {
                    themes.push(theme);
                }
                const tags = entity.get("themeTags");
                if (tags) {
                    each$1(tags, (tag) => {
                        themeTags.add(tag);
                    });
                }
            });
            themes = defaults.concat(themes);
            this._removeTemplates();
            if (isConnected || force) {
                eachReverse(this.classNames, (name) => {
                    const allRules = [];
                    each$1(themes, (themes) => {
                        each$1(themes, (theme) => {
                            const rules = theme._lookupRules(name);
                            if (rules) {
                                eachReverse(rules, (rule) => {
                                    const matches = rule.tags.every((tag) => {
                                        return themeTags.has(tag);
                                    });
                                    if (matches) {
                                        const result = getFirstSortedIndex(allRules, (x) => {
                                            const order = compare(rule.tags.length, x.tags.length);
                                            if (order === 0) {
                                                return compareArray(rule.tags, x.tags, compare);
                                            }
                                            else {
                                                return order;
                                            }
                                        });
                                        allRules.splice(result.index, 0, rule);
                                    }
                                });
                            }
                        });
                    });
                    each$1(allRules, (rule) => {
                        this._templates.push(rule.template);
                        rule.template._setObjectTemplate(this);
                    });
                });
            }
            this._applyTemplates();
            if (isConnected || force) {
                // This causes it to only run the setup function the first time that the themes are applied
                this._runSetup = false;
            }
            return isConnected || force;
        }
        _changed() { }
        _beforeChanged() {
            if (this.isDirty("id")) {
                const id = this.get("id");
                if (id) {
                    this._registerId(id);
                }
                const prevId = this._prevSettings.id;
                if (prevId) {
                    delete registry.entitiesById[prevId];
                }
            }
        }
        _registerId(id) {
            if (registry.entitiesById[id] && registry.entitiesById[id] !== this) {
                throw new Error("An entity with id \"" + id + "\" already exists.");
            }
            registry.entitiesById[id] = this;
        }
        _afterChanged() { }
        /**
         * @ignore
         */
        addDisposer(disposer) {
            this._disposers.push(disposer);
            return disposer;
        }
        _dispose() {
            super._dispose();
            const template = this._template;
            if (template) {
                template._removeObjectTemplate(this);
            }
            each$1(this._internalTemplates, (template) => {
                template._removeObjectTemplate(this);
            });
            this._removeTemplates();
            this._disposeTemplates();
            this.events.dispose();
            this._disposers.forEach((x) => {
                x.dispose();
            });
            each(this._disposerProperties, (_, disposers) => {
                each$1(disposers, (disposer) => {
                    disposer.dispose();
                });
            });
            const id = this.get("id");
            if (id) {
                delete registry.entitiesById[id];
            }
        }
        /**
         * Creates and returns a "disposable" timeout.
         *
         * @param   fn     Callback
         * @param   delay  Delay in milliseconds
         * @return         Timeout disposer
         */
        setTimeout(fn, delay) {
            const id = setTimeout(() => {
                this.removeDispose(disposer);
                fn();
            }, delay);
            const disposer = new Disposer(() => {
                clearTimeout(id);
            });
            this._disposers.push(disposer);
            return disposer;
        }
        /**
         * @ignore
         */
        removeDispose(target) {
            if (!this.isDisposed()) {
                let index = indexOf(this._disposers, target);
                if (index > -1) {
                    this._disposers.splice(index, 1);
                }
            }
            target.dispose();
        }
        /**
         * @ignore
         */
        hasTag(tag) {
            return indexOf(this.get("themeTags", []), tag) !== -1;
        }
        /**
         * @ignore
         */
        addTag(tag) {
            if (!this.hasTag(tag)) {
                const tags = this.get("themeTags", []);
                tags.push(tag);
                this.set("themeTags", tags);
            }
        }
        /**
         * @ignore
         */
        removeTag(tag) {
            if (this.hasTag(tag)) {
                const tags = this.get("themeTags", []);
                remove(tags, tag);
                this.set("themeTags", tags);
            }
        }
        _t(text, locale, ...rest) {
            return this._root.language.translate(text, locale, ...rest);
        }
        /**
         * An instance of [[Root]] object.
         *
         * @readonly
         * @since 5.0.6
         * @return Root object
         */
        get root() {
            return this._root;
        }
    }
    Object.defineProperty(Entity, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Entity"
    });
    Object.defineProperty(Entity, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ["Entity"]
    });

    class TemplateState {
        constructor(name, template, settings) {
            Object.defineProperty(this, "_settings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_template", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._name = name;
            this._template = template;
            this._settings = settings;
        }
        get(key, fallback) {
            const value = this._settings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
        set(key, value) {
            this._settings[key] = value;
            // TODO maybe only do this if the value changed ?
            this._template._stateChanged(this._name);
        }
        remove(key) {
            delete this._settings[key];
            // TODO maybe only do this if the value changed ?
            this._template._stateChanged(this._name);
        }
        setAll(settings) {
            keys(settings).forEach((key) => {
                this._settings[key] = settings[key];
            });
            this._template._stateChanged(this._name);
        }
        _apply(other, seen) {
            each(this._settings, (key, value) => {
                if (!seen[key] && !other._userSettings[key]) {
                    seen[key] = true;
                    other.setRaw(key, value);
                }
            });
        }
    }
    class TemplateStates {
        constructor(template) {
            Object.defineProperty(this, "_template", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_states", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            this._template = template;
        }
        lookup(name) {
            return this._states[name];
        }
        create(name, settings) {
            const state = this._states[name];
            if (state) {
                state.setAll(settings);
                return state;
            }
            else {
                const state = new TemplateState(name, this._template, settings);
                this._states[name] = state;
                this._template._stateChanged(name);
                return state;
            }
        }
        remove(name) {
            delete this._states[name];
            this._template._stateChanged(name);
        }
        _apply(entity, state) {
            each(this._states, (key, value) => {
                let seen = state.states[key];
                if (seen == null) {
                    seen = state.states[key] = {};
                }
                const other = entity.states.create(key, {});
                value._apply(other, seen);
            });
        }
    }
    class TemplateAdapters {
        constructor() {
            Object.defineProperty(this, "_callbacks", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
        }
        add(key, callback) {
            let callbacks = this._callbacks[key];
            if (callbacks === undefined) {
                callbacks = this._callbacks[key] = [];
            }
            callbacks.push(callback);
            return new Disposer(() => {
                removeFirst(callbacks, callback);
                if (callbacks.length === 0) {
                    delete this._callbacks[key];
                }
            });
        }
        remove(key) {
            const callbacks = this._callbacks[key];
            if (callbacks !== undefined) {
                delete this._callbacks[key];
            }
        }
        _apply(entity) {
            const disposers = [];
            each(this._callbacks, (key, callbacks) => {
                each$1(callbacks, (callback) => {
                    disposers.push(entity.adapters.add(key, callback));
                });
            });
            return new MultiDisposer(disposers);
        }
    }
    // TODO maybe extend from Properties ?
    class Template {
        constructor(settings, isReal) {
            Object.defineProperty(this, "_settings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_privateSettings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            // TODO code duplication with Properties
            Object.defineProperty(this, "_settingEvents", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_privateSettingEvents", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_entities", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "states", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new TemplateStates(this)
            });
            Object.defineProperty(this, "adapters", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new TemplateAdapters()
            });
            Object.defineProperty(this, "events", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new EventDispatcher()
            });
            Object.defineProperty(this, "setup", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            if (!isReal) {
                throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
            }
            this._settings = settings;
        }
        /**
         * Use this method to create an instance of this class.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
         * @param   root      Root element
         * @param   settings  Settings
         * @param   template  Template
         * @return            Instantiated object
         */
        static new(settings) {
            return new Template(settings, true);
        }
        /**
         * Array of all entities using this template.
         */
        get entities() {
            return this._entities;
        }
        get(key, fallback) {
            const value = this._settings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
        setRaw(key, value) {
            this._settings[key] = value;
        }
        set(key, value) {
            if (this._settings[key] !== value) {
                this.setRaw(key, value);
                this._entities.forEach((entity) => {
                    entity._setTemplateProperty(this, key, value);
                });
            }
        }
        remove(key) {
            if (key in this._settings) {
                delete this._settings[key];
                this._entities.forEach((entity) => {
                    entity._removeTemplateProperty(key);
                });
            }
        }
        removeAll() {
            each(this._settings, (key, _value) => {
                this.remove(key);
            });
        }
        getPrivate(key, fallback) {
            const value = this._privateSettings[key];
            if (value !== undefined) {
                return value;
            }
            else {
                return fallback;
            }
        }
        setPrivateRaw(key, value) {
            this._privateSettings[key] = value;
            return value;
        }
        setPrivate(key, value) {
            if (this._privateSettings[key] !== value) {
                this.setPrivateRaw(key, value);
                this._entities.forEach((entity) => {
                    entity._setTemplatePrivateProperty(this, key, value);
                });
            }
            return value;
        }
        removePrivate(key) {
            if (key in this._privateSettings) {
                delete this._privateSettings[key];
                this._entities.forEach((entity) => {
                    entity._removeTemplatePrivateProperty(key);
                });
            }
        }
        setAll(value) {
            each(value, (key, value) => {
                this.set(key, value);
            });
        }
        // TODO code duplication with Properties
        on(key, callback) {
            let events = this._settingEvents[key];
            if (events === undefined) {
                events = this._settingEvents[key] = [];
            }
            events.push(callback);
            return new Disposer(() => {
                removeFirst(events, callback);
                if (events.length === 0) {
                    delete this._settingEvents[key];
                }
            });
        }
        // TODO code duplication with Properties
        onPrivate(key, callback) {
            let events = this._privateSettingEvents[key];
            if (events === undefined) {
                events = this._privateSettingEvents[key] = [];
            }
            events.push(callback);
            return new Disposer(() => {
                removeFirst(events, callback);
                if (events.length === 0) {
                    delete this._privateSettingEvents[key];
                }
            });
        }
        _apply(entity, state) {
            const disposers = [];
            each(this._settingEvents, (key, events) => {
                each$1(events, (event) => {
                    disposers.push(entity.on(key, event));
                });
            });
            each(this._privateSettingEvents, (key, events) => {
                each$1(events, (event) => {
                    disposers.push(entity.onPrivate(key, event));
                });
            });
            this.states._apply(entity, state);
            disposers.push(this.adapters._apply(entity));
            disposers.push(entity.events.copyFrom(this.events));
            return new MultiDisposer(disposers);
        }
        _setObjectTemplate(entity) {
            this._entities.push(entity);
        }
        _removeObjectTemplate(entity) {
            remove(this._entities, entity);
        }
        _stateChanged(name) {
            this._entities.forEach((entity) => {
                entity._applyStateByKey(name);
            });
        }
    }

    //import { populateString } from "../util/PopulateString";
    /**
     * An [[EventDispatcher]] for [[Sprite]].
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
     */
    class SpriteEventDispatcher extends EventDispatcher {
        constructor(sprite) {
            super();
            Object.defineProperty(this, "_sprite", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_rendererDisposers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_dispatchParents", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            this._sprite = sprite;
        }
        _makePointerEvent(key, event) {
            return {
                type: key,
                originalEvent: event.event,
                point: event.point,
                simulated: event.simulated,
                native: event.native,
                target: this._sprite
            };
        }
        _onRenderer(key, dispatch) {
            // TODO: is this OK? it'd be good not to require to set this on each individual element
            this._sprite.set("interactive", true);
            this._sprite._display.interactive = true;
            let events = this._rendererDisposers[key];
            if (events === undefined) {
                const disposer = this._sprite._display.on(key, (e) => {
                    dispatch.call(this, e);
                });
                events = this._rendererDisposers[key] = new CounterDisposer(() => {
                    delete this._rendererDisposers[key];
                    disposer.dispose();
                });
            }
            return events.increment();
        }
        _on(once, type, callback, context, shouldClone, dispatch) {
            const info = super._on(once, type, callback, context, shouldClone, dispatch);
            const rendererEvent = SpriteEventDispatcher.RENDERER_EVENTS[type];
            if (rendererEvent !== undefined) {
                info.disposer = new MultiDisposer([
                    info.disposer,
                    this._onRenderer(type, rendererEvent),
                ]);
            }
            return info;
        }
        /**
         * Will stop any bubbling up of the event to element's parents.
         *
         * Should be called in an event handler, e.g.:
         *
         * ```TypeScript
         * element.events.on("pointerdown", function(ev) {
         *   // Do something here and prevent from "pointerdown" bubbling up
         *   // ...
         *   ev.target.events.stopParentDispatch();
         * });
         * ```
         * ```JavaScript
         * element.events.on("pointerdown", function(ev) {
         *   // Do something here and prevent from "pointerdown" bubbling up
         *   // ...
         *   ev.target.events.stopParentDispatch();
         * });
         * ```
         */
        stopParentDispatch() {
            this._dispatchParents = false;
        }
        /**
         * @ignore
         */
        dispatchParents(type, event) {
            const old = this._dispatchParents;
            this._dispatchParents = true;
            try {
                this.dispatch(type, event);
                if (this._dispatchParents && this._sprite.parent) {
                    this._sprite.parent.events.dispatchParents(type, event);
                }
            }
            finally {
                this._dispatchParents = old;
            }
        }
    }
    Object.defineProperty(SpriteEventDispatcher, "RENDERER_EVENTS", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {
            "click": function (event) {
                if (this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", event))) {
                    this.dispatch("click", this._makePointerEvent("click", event));
                }
            },
            "rightclick": function (event) {
                if (this.isEnabled("rightclick")) {
                    this.dispatch("rightclick", this._makePointerEvent("rightclick", event));
                }
            },
            "middleclick": function (event) {
                if (this.isEnabled("middleclick")) {
                    this.dispatch("middleclick", this._makePointerEvent("middleclick", event));
                }
            },
            "dblclick": function (event) {
                this.dispatchParents("dblclick", this._makePointerEvent("dblclick", event));
            },
            "pointerover": function (event) {
                const sprite = this._sprite;
                let dispatch = true;
                if (sprite.getPrivate("trustBounds")) {
                    sprite._getBounds();
                    const bounds = sprite.globalBounds();
                    if (sprite.isType("Graphics")) {
                        const strokeWidth = sprite.get("strokeWidth", 1) / 2;
                        if (strokeWidth >= 1) {
                            bounds.left -= strokeWidth;
                            bounds.right += strokeWidth;
                            bounds.top -= strokeWidth;
                            bounds.bottom += strokeWidth;
                        }
                    }
                    if (!inBounds(event.point, bounds)) {
                        dispatch = false;
                        sprite._root._renderer.removeHovering(sprite._display);
                    }
                }
                if (dispatch && this.isEnabled("pointerover")) {
                    this.dispatch("pointerover", this._makePointerEvent("pointerover", event));
                }
            },
            "pointerout": function (event) {
                if (this.isEnabled("pointerout")) {
                    this.dispatch("pointerout", this._makePointerEvent("pointerout", event));
                }
            },
            "pointerdown": function (event) {
                this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", event));
            },
            "pointerup": function (event) {
                if (this.isEnabled("pointerup")) {
                    this.dispatch("pointerup", this._makePointerEvent("pointerup", event));
                }
            },
            "globalpointerup": function (event) {
                if (this.isEnabled("globalpointerup")) {
                    this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", event));
                }
            },
            "globalpointermove": function (event) {
                if (this.isEnabled("globalpointermove")) {
                    this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", event));
                }
            },
            "wheel": function (event) {
                this.dispatchParents("wheel", {
                    type: "wheel",
                    target: this._sprite,
                    originalEvent: event.event,
                    point: event.point,
                });
            },
        }
    });
    /**
     * A base class for all visual elements.
     *
     * @important
     */
    class Sprite extends Entity {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_adjustedLocalBounds", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: { left: 0, right: 0, top: 0, bottom: 0 }
            });
            Object.defineProperty(this, "_localBounds", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: { left: 0, right: 0, top: 0, bottom: 0 }
            });
            Object.defineProperty(this, "_parent", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_dataItem", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_templateField", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_sizeDirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            // Will be true only when dragging
            Object.defineProperty(this, "_isDragging", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            // The event when the dragging starts
            Object.defineProperty(this, "_dragEvent", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // The position when dragging starts
            Object.defineProperty(this, "_dragPoint", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_isHidden", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_isShowing", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_isHiding", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_isDown", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_downPoint", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_downPoints", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_toggleDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_dragDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltipDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_hoverDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_focusDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltipMoveDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltipPointerDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_statesHandled", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        _afterNew() {
            this.setPrivateRaw("visible", true);
            super._afterNew();
        }
        /**
         * Marks some setting as dirty. Could be used to trigger adapter.
         * @param key
         */
        markDirtyKey(key) {
            this._markDirtyKey(key);
        }
        _markDirtyKey(key) {
            super._markDirtyKey(key);
            if (key == "x" || key == "y" || key == "dx" || key == "dy") {
                this.markDirtyBounds();
                this._addPercentagePositionChildren();
                this.markDirtyPosition();
            }
        }
        _markDirtyPrivateKey(key) {
            super._markDirtyPrivateKey(key);
            if (key == "x" || key == "y") {
                this.markDirtyPosition();
            }
        }
        _removeTemplateField() {
            if (this._templateField) {
                this._templateField._removeObjectTemplate(this);
            }
        }
        _createEvents() {
            return new SpriteEventDispatcher(this);
        }
        _processTemplateField() {
            let template;
            const field = this.get("templateField");
            if (field) {
                const dataItem = this.dataItem;
                if (dataItem) {
                    const context = dataItem.dataContext;
                    if (context) {
                        template = context[field];
                        if (!(template instanceof Template) && template) {
                            template = Template.new(template);
                        }
                    }
                }
            }
            if (this._templateField !== template) {
                this._removeTemplateField();
                this._templateField = template;
                if (template) {
                    template._setObjectTemplate(this);
                }
                this._applyTemplates();
            }
        }
        // TODO change this to run before the element is added to the parent, so that way
        //      it doesn't need to apply the themes twice
        _setDataItem(dataItem) {
            const oldDataItem = this._dataItem;
            this._dataItem = dataItem;
            this._processTemplateField();
            const eventType = "dataitemchanged";
            if (dataItem != oldDataItem) {
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, {
                        type: eventType,
                        target: this,
                        oldDataItem: oldDataItem,
                        newDataItem: dataItem
                    });
                }
            }
        }
        /**
         * A [[DataItem]] used for this element.
         *
         * NOTE: data item is being assigned automatically in most cases where it
         * matters. Use this accessor to set data item only if you know what you're
         * doing.
         *
         * @param  value  Data item
         */
        set dataItem(value) {
            this._setDataItem(value);
        }
        /**
         * @return DataItem
         */
        get dataItem() {
            if (this._dataItem) {
                return this._dataItem;
            }
            else {
                let parent = this._parent;
                while (parent) {
                    if (parent._dataItem) {
                        return parent._dataItem;
                    }
                    else {
                        parent = parent._parent;
                    }
                }
            }
        }
        _addPercentageSizeChildren() {
            let parent = this.parent;
            if (parent) {
                if (this.get("width") instanceof Percent || this.get("height") instanceof Percent) {
                    pushOne(parent._percentageSizeChildren, this);
                }
                else {
                    removeFirst(parent._percentageSizeChildren, this);
                }
            }
        }
        _addPercentagePositionChildren() {
            let parent = this.parent;
            if (parent) {
                if (this.get("x") instanceof Percent || this.get("y") instanceof Percent) {
                    pushOne(parent._percentagePositionChildren, this);
                }
                else {
                    removeFirst(parent._percentagePositionChildren, this);
                }
            }
        }
        /**
         * @ignore
         */
        markDirtyPosition() {
            this._root._addDirtyPosition(this);
        }
        updatePivotPoint() {
            const bounds = this._localBounds;
            if (bounds) {
                const centerX = this.get("centerX");
                if (centerX != null) {
                    this._display.pivot.x = bounds.left + relativeToValue(centerX, bounds.right - bounds.left);
                }
                const centerY = this.get("centerY");
                if (centerY != null) {
                    this._display.pivot.y = bounds.top + relativeToValue(centerY, bounds.bottom - bounds.top);
                }
            }
        }
        _beforeChanged() {
            super._beforeChanged();
            // handling states in beforeChanged, otherwise states is not applied without animated theme
            this._handleStates();
            if (this.isDirty("tooltip")) {
                const previous = this._prevSettings.tooltip;
                if (previous) {
                    previous.dispose();
                }
            }
            if (this.isDirty("layer") || this.isDirty("layerMargin")) {
                this._display.setLayer(this.get("layer"), this.get("layerMargin"));
                this.markDirtyLayer();
            }
            if (this.isDirty("tooltipPosition")) {
                const tooltipMoveDp = this._tooltipMoveDp;
                if (tooltipMoveDp) {
                    tooltipMoveDp.dispose();
                    this._tooltipMoveDp = undefined;
                }
                const tooltipPointerDp = this._tooltipPointerDp;
                if (tooltipPointerDp) {
                    tooltipPointerDp.dispose();
                    this._tooltipPointerDp = undefined;
                }
                if (this.get("tooltipPosition") == "pointer") {
                    if (this.isHover()) {
                        this._tooltipMoveDp = this.events.on("globalpointermove", (e) => {
                            this.showTooltip(e.point);
                        });
                    }
                    this._tooltipPointerDp = new MultiDisposer([
                        this.events.on("pointerover", () => {
                            this._tooltipMoveDp = this.events.on("globalpointermove", (e) => {
                                this.showTooltip(e.point);
                            });
                        }),
                        this.events.on("pointerout", () => {
                            const tooltipMoveDp = this._tooltipMoveDp;
                            if (tooltipMoveDp) {
                                tooltipMoveDp.dispose();
                                this._tooltipMoveDp = undefined;
                            }
                        })
                    ]);
                }
            }
        }
        _handleStates() {
            if (!this._statesHandled) {
                if (this.isDirty("active")) {
                    if (this.get("active")) {
                        this.states.applyAnimate("active");
                        this.set("ariaChecked", true);
                    }
                    else {
                        if (!this.isHidden()) {
                            this.states.applyAnimate("default");
                        }
                        this.set("ariaChecked", false);
                    }
                    this.markDirtyAccessibility();
                }
                if (this.isDirty("disabled")) {
                    if (this.get("disabled")) {
                        this.states.applyAnimate("disabled");
                        this.set("ariaChecked", false);
                    }
                    else {
                        if (!this.isHidden()) {
                            this.states.applyAnimate("default");
                        }
                        this.set("ariaChecked", true);
                    }
                    this.markDirtyAccessibility();
                }
                this._statesHandled = true;
            }
        }
        _changed() {
            super._changed();
            const display = this._display;
            const events = this.events;
            if (this.isDirty("draggable")) {
                const draggable = this.get("draggable");
                if (draggable) {
                    this.set("interactive", true);
                    this._dragDp = new MultiDisposer([
                        events.on("pointerdown", (ev) => {
                            this.dragStart(ev);
                        }),
                        events.on("globalpointermove", (ev) => {
                            this.dragMove(ev);
                        }),
                        events.on("globalpointerup", (ev) => {
                            this.dragStop(ev);
                        })
                    ]);
                }
                else {
                    if (this._dragDp) {
                        this._dragDp.dispose();
                        this._dragDp = undefined;
                    }
                }
                display.cancelTouch = draggable ? true : false;
            }
            if (this.isDirty("tooltipText") || this.isDirty("tooltipHTML") || this.isDirty("showTooltipOn")) {
                const tooltipText = this.get("tooltipText");
                const tooltipHTML = this.get("tooltipHTML");
                const showTooltipOn = this.get("showTooltipOn", "hover");
                if (this._tooltipDp) {
                    this._tooltipDp.dispose();
                    this._tooltipDp = undefined;
                }
                if (tooltipText || tooltipHTML) {
                    if (showTooltipOn == "click") {
                        this._tooltipDp = new MultiDisposer([
                            events.on("click", () => {
                                this.setTimeout(() => this.showTooltip(), 10);
                            }),
                            addEventListener(document, "click", (_ev) => {
                                this.hideTooltip();
                            })
                        ]);
                        this._disposers.push(this._tooltipDp);
                    }
                    else if (showTooltipOn == "always") ;
                    else {
                        this._tooltipDp = new MultiDisposer([
                            events.on("pointerover", () => {
                                this.showTooltip();
                            }),
                            events.on("pointerout", () => {
                                this.hideTooltip();
                            })
                        ]);
                        this._disposers.push(this._tooltipDp);
                    }
                }
            }
            if (this.isDirty("toggleKey")) {
                let toggleKey = this.get("toggleKey");
                if (toggleKey && toggleKey != "none") {
                    this._toggleDp = events.on("click", () => {
                        if (!this._isDragging) {
                            this.set(toggleKey, !this.get(toggleKey));
                        }
                    });
                }
                else {
                    if (this._toggleDp) {
                        this._toggleDp.dispose();
                        this._toggleDp = undefined;
                    }
                }
            }
            if (this.isDirty("opacity")) {
                display.alpha = Math.max(0, this.get("opacity", 1));
                if (this.get("focusable")) {
                    this.markDirtyAccessibility();
                }
            }
            if (this.isDirty("rotation")) {
                this.markDirtyBounds();
                display.angle = this.get("rotation", 0);
            }
            if (this.isDirty("scale")) {
                this.markDirtyBounds();
                display.scale = this.get("scale", 0);
            }
            if (this.isDirty("centerX") || this.isDirty("centerY")) {
                this.markDirtyBounds();
                this.updatePivotPoint();
            }
            if (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) {
                if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {
                    display.visible = false;
                    this.hideTooltip();
                }
                else {
                    display.visible = true;
                }
                this.markDirtyBounds();
                if (this.get("focusable")) {
                    this.markDirtyAccessibility();
                }
            }
            if (this.isDirty("width") || this.isDirty("height")) {
                this.markDirtyBounds();
                this._addPercentageSizeChildren();
                const parent = this.parent;
                if (parent) {
                    if ((this.isDirty("width") && this.get("width") instanceof Percent) || (this.isDirty("height") && this.get("height") instanceof Percent)) {
                        parent.markDirty();
                        parent._prevWidth = 0;
                    }
                }
                this._sizeDirty = true;
            }
            if (this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("minWidth") || this.isDirty("minHeight") || this.isPrivateDirty("maxWidth") || this.isPrivateDirty("maxHeight") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight") || this.isDirty("marginLeft") || this.isDirty("marginTop") || this.isDirty("marginRight") || this.isDirty("marginBottom")) {
                this.markDirtyBounds();
                this._sizeDirty = true;
            }
            if (this._sizeDirty) {
                this._updateSize();
            }
            if (this.isDirty("wheelable")) {
                const wheelable = this.get("wheelable");
                if (wheelable) {
                    this.set("interactive", true);
                }
                display.wheelable = wheelable ? true : false;
            }
            // Accessibility
            if (this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) {
                if (this.get("focusable")) {
                    this._root._registerTabindexOrder(this);
                }
                else {
                    this._root._unregisterTabindexOrder(this);
                }
            }
            if (this.isDirty("filter")) {
                //this.markDirtyBounds();
                display.filter = this.get("filter");
            }
            let filter = this.get("filter", "");
            if (this.isDirty("blur")) {
                const blur = this.get("blur", 0);
                if (blur != 0) {
                    filter += " blur(" + blur + "px)";
                }
            }
            if (this.isDirty("saturate")) {
                const saturate = this.get("saturate", 1);
                if (saturate != 1) {
                    filter += " saturate(" + saturate + ")";
                }
            }
            if (this.isDirty("brightness")) {
                const brightness = this.get("brightness", 1);
                if (brightness != 1) {
                    filter += " brightness(" + brightness + ")";
                }
            }
            if (this.isDirty("contrast")) {
                const contrast = this.get("contrast", 1);
                if (contrast != 1) {
                    filter += " contrast(" + contrast + ")";
                }
            }
            if (this.isDirty("sepia")) {
                const sepia = this.get("sepia", 0);
                if (sepia != 0) {
                    filter += " sepia(" + sepia + ")";
                }
            }
            if (this.isDirty("hue")) {
                const hue = this.get("hue", 0);
                if (hue != 0) {
                    filter += " hue-rotate(" + hue + "deg)";
                }
            }
            if (this.isDirty("invert")) {
                const invert = this.get("invert", 0);
                if (invert != 0) {
                    filter += " invert(" + invert + ")";
                }
            }
            if (filter) {
                display.filter = filter;
            }
            if (this.isDirty("cursorOverStyle")) {
                display.cursorOverStyle = this.get("cursorOverStyle");
            }
            if (this.isDirty("hoverOnFocus")) {
                if (this.get("hoverOnFocus")) {
                    this._focusDp = new MultiDisposer([
                        events.on("focus", () => {
                            // TODO: proper hover, not just tooltip
                            this.showTooltip();
                        }),
                        events.on("blur", () => {
                            // TODO: proper hover, not just tooltip
                            this.hideTooltip();
                        })
                    ]);
                }
                else {
                    if (this._focusDp) {
                        this._focusDp.dispose();
                        this._focusDp = undefined;
                    }
                }
            }
            if (this.isDirty("focusable")) {
                if (this.get("focusable")) {
                    this._root._registerTabindexOrder(this);
                }
                else {
                    this._root._unregisterTabindexOrder(this);
                }
                this.markDirtyAccessibility();
            }
            if (this.isPrivateDirty("focusable")) {
                this.markDirtyAccessibility();
            }
            if (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) {
                // display.accessibility.ariaLabel = populateString(this, this.get("ariaLabel", ""));
                // @todo make sure ariaLabel gets populated in Root
                this.markDirtyAccessibility();
            }
            if (this.isDirty("exportable")) {
                display.exportable = this.get("exportable");
            }
            if (this.isDirty("interactive")) {
                const events = this.events;
                if (this.get("interactive") && !events.isDisposed()) {
                    this._hoverDp = new MultiDisposer([
                        events.on("click", (ev) => {
                            if (isTouchEvent(ev.originalEvent)) {
                                if (!this.getPrivate("touchHovering")) {
                                    this.setTimeout(() => {
                                        this._handleOver();
                                        if (this.get("tooltipText") || this.get("tooltipHTML")) {
                                            this.showTooltip();
                                        }
                                        this.setPrivateRaw("touchHovering", true);
                                        this.events.dispatch("pointerover", {
                                            type: "pointerover",
                                            target: ev.target,
                                            originalEvent: ev.originalEvent,
                                            point: ev.point,
                                            simulated: ev.simulated
                                        });
                                    }, 10);
                                }
                            }
                        }),
                        events.on("globalpointerup", (ev) => {
                            if (isTouchEvent(ev.originalEvent)) {
                                if (this.getPrivate("touchHovering")) {
                                    this._handleOut();
                                    if (this.get("tooltipText") || this.get("tooltipHTML")) {
                                        this.hideTooltip();
                                    }
                                    this.setPrivateRaw("touchHovering", false);
                                    this.events.dispatch("pointerout", {
                                        type: "pointerout",
                                        target: ev.target,
                                        originalEvent: ev.originalEvent,
                                        point: ev.point,
                                        simulated: ev.simulated
                                    });
                                }
                            }
                            if (this._isDown) {
                                this._handleUp(ev);
                            }
                            //this._isDown = false;
                        }),
                        events.on("pointerover", () => {
                            this._handleOver();
                        }),
                        events.on("pointerout", () => {
                            this._handleOut();
                        }),
                        events.on("pointerdown", (e) => {
                            this._handleDown(e);
                        })
                    ]);
                }
                else {
                    this._display.interactive = false;
                    if (this._hoverDp) {
                        this._hoverDp.dispose();
                        this._hoverDp = undefined;
                    }
                }
            }
            if (this.isDirty("forceInactive")) {
                this._display.inactive = this.get("forceInactive", null);
            }
            if (this.get("showTooltipOn") == "always" && this._display.visible) {
                this.showTooltip();
            }
        }
        /**
         * @ignore
         * @todo should this be user-accessible?
         */
        dragStart(e) {
            this._dragEvent = e;
            this.events.stopParentDispatch();
        }
        /**
         * @ignore
         * @todo should this be user-accessible?
         */
        dragStop(e) {
            this._dragEvent = undefined;
            this._dragPoint = undefined;
            this.events.stopParentDispatch();
            if (this._isDragging) {
                this._isDragging = false;
                const type = "dragstop";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, {
                        type: type,
                        target: this,
                        originalEvent: e.originalEvent,
                        point: e.point,
                        simulated: e.simulated,
                    });
                }
            }
        }
        _handleOver() {
            if (!this.isHidden()) {
                if (this.get("active") && this.states.lookup("hoverActive")) {
                    this.states.applyAnimate("hoverActive");
                }
                else if (this.get("disabled") && this.states.lookup("hoverDisabled")) {
                    this.states.applyAnimate("hoverDisabled");
                }
                else {
                    this.states.applyAnimate("hover");
                }
                if (this.get("draggable") && this._isDown && this.states.lookup("down")) {
                    this.states.applyAnimate("down");
                }
            }
        }
        _handleOut() {
            if (!this.isHidden()) {
                if (this.get("active") && this.states.lookup("active")) {
                    this.states.applyAnimate("active");
                }
                else if (this.get("disabled") && this.states.lookup("disabled")) {
                    this.states.applyAnimate("disabled");
                }
                else {
                    if (this.states.lookup("hover") || this.states.lookup("hoverActive")) {
                        this.states.applyAnimate("default");
                    }
                }
                if (this.get("draggable") && this._isDown && this.states.lookup("down")) {
                    this.states.applyAnimate("down");
                }
            }
        }
        _handleUp(e) {
            if (!this.isHidden()) {
                if (this.get("active") && this.states.lookup("active")) {
                    this.states.applyAnimate("active");
                }
                else if (this.get("disabled") && this.states.lookup("disabled")) {
                    this.states.applyAnimate("disabled");
                }
                else if (this.states.lookup("down")) {
                    if (this.isHover()) {
                        this.states.applyAnimate("hover");
                    }
                    else {
                        this.states.applyAnimate("default");
                    }
                }
                // @todo remove this once migrated to _downPoints
                this._downPoint = undefined;
                const pointerId = getPointerId(e.originalEvent);
                delete this._downPoints[pointerId];
                if (keys(this._downPoints).length == 0) {
                    this._isDown = false;
                }
            }
        }
        _hasMoved(e) {
            // @todo remove this once migrated to _downPoints
            // if (this._downPoint) {
            // 	const x = Math.abs(this._downPoint.x - e.point.x);
            // 	const y = Math.abs(this._downPoint.y - e.point.y);
            // 	return (x > 5) || (y > 5);
            // }
            const pointerId = getPointerId(e.originalEvent);
            const downPoint = this._downPoints[pointerId];
            if (downPoint) {
                const x = Math.abs(downPoint.x - e.point.x);
                const y = Math.abs(downPoint.y - e.point.y);
                return (x > 5) || (y > 5);
            }
            return false;
        }
        _hasDown() {
            return keys(this._downPoints).length > 0;
        }
        _handleDown(e) {
            const parent = this.parent;
            if (parent && !this.get("draggable")) {
                parent._handleDown(e);
            }
            if (this.get("interactive") && !this.isHidden()) {
                if (this.states.lookup("down")) {
                    this.states.applyAnimate("down");
                }
                this._downPoint = {
                    x: e.point.x,
                    y: e.point.y
                };
                // @todo remove this once migrated to _downPoints
                this._isDown = true;
                const pointerId = getPointerId(e.originalEvent);
                this._downPoints[pointerId] = {
                    x: e.point.x,
                    y: e.point.y
                };
            }
        }
        /**
         * @ignore
         * @todo should this be user-accessible?
         */
        dragMove(e) {
            let dragEvent = this._dragEvent;
            if (dragEvent) {
                if (dragEvent.simulated && !e.simulated) {
                    return true;
                }
                let angle = 0;
                let parent = this.parent;
                let scale = 1;
                while (parent != null) {
                    angle += parent.get("rotation", 0);
                    parent = parent.parent;
                    if (parent) {
                        scale *= parent.get("scale", 1);
                    }
                }
                let x = (e.point.x - dragEvent.point.x) / scale;
                let y = (e.point.y - dragEvent.point.y) / scale;
                const events = this.events;
                if (dragEvent.simulated && !this._isDragging) {
                    this._isDragging = true;
                    this._dragEvent = e;
                    this._dragPoint = {
                        x: this.x(),
                        y: this.y()
                    };
                    const type = "dragstart";
                    if (events.isEnabled(type)) {
                        events.dispatch(type, {
                            type: type,
                            target: this,
                            originalEvent: e.originalEvent,
                            point: e.point,
                            simulated: e.simulated,
                        });
                    }
                }
                if (this._isDragging) {
                    let dragPoint = this._dragPoint;
                    this.set("x", dragPoint.x + x * cos(angle) + y * sin(angle));
                    this.set("y", dragPoint.y + y * cos(angle) - x * sin(angle));
                    const type = "dragged";
                    if (events.isEnabled(type)) {
                        events.dispatch(type, {
                            type: type,
                            target: this,
                            originalEvent: e.originalEvent,
                            point: e.point,
                            simulated: e.simulated,
                        });
                    }
                }
                else {
                    if (Math.hypot(x, y) > 5) {
                        this._isDragging = true;
                        this._dragEvent = e;
                        this._dragPoint = {
                            x: this.x(),
                            y: this.y()
                        };
                        const type = "dragstart";
                        if (events.isEnabled(type)) {
                            events.dispatch(type, {
                                type: type,
                                target: this,
                                originalEvent: e.originalEvent,
                                point: e.point,
                                simulated: e.simulated
                            });
                        }
                    }
                }
            }
        }
        _updateSize() {
        }
        _getBounds() {
            this._localBounds = this._display.getLocalBounds();
        }
        /**
         * Returns depth (how deep in the hierachy of the content tree) of this
         * element.
         *
         * @return Depth
         */
        depth() {
            let self = this.parent;
            let depth = 0;
            while (true) {
                if (self) {
                    ++depth;
                    self = self.parent;
                }
                else {
                    return depth;
                }
            }
        }
        /**
         * @ignore
         */
        markDirtySize() {
            this._sizeDirty = true;
            this.markDirty();
        }
        /**
         * @ignore
         */
        markDirtyBounds() {
            const display = this._display;
            if (this.get("isMeasured")) {
                this._root._addDirtyBounds(this);
                display.isMeasured = true;
                display.invalidateBounds();
                const parent = this.parent;
                if (parent && this.get("position") != "absolute") {
                    if (parent.get("width") == null || parent.get("height") == null || parent.get("layout")) {
                        parent.markDirtyBounds();
                    }
                }
                if (this.get("focusable") && this.isFocus()) {
                    this.markDirtyAccessibility();
                }
            }
        }
        /**
         * @ignore
         */
        markDirtyAccessibility() {
            //if (this._root.focused(this)) {
            this._root._invalidateAccessibility(this);
            //}
        }
        /**
         * @ignore
         */
        markDirtyLayer() {
            //this._display.markDirtyLayer(this.isDirty("opacity") || this.isDirty("visible")); https://codepen.io/team/amcharts/pen/gOWZPmP <- problems
            this._display.markDirtyLayer(true);
        }
        /**
         * @ignore
         */
        markDirty() {
            super.markDirty();
            this.markDirtyLayer();
        }
        _updateBounds() {
            const oldBounds = this._adjustedLocalBounds;
            let newBounds;
            // if display.visible == false, it still returns bounds
            if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {
                newBounds = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                this._localBounds = newBounds;
                this._adjustedLocalBounds = newBounds;
            }
            else {
                this._getBounds();
                this._fixMinBounds(this._localBounds);
                this.updatePivotPoint();
                this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds);
                newBounds = this._adjustedLocalBounds;
            }
            if (!oldBounds || (oldBounds.left !== newBounds.left || oldBounds.top !== newBounds.top || oldBounds.right !== newBounds.right || oldBounds.bottom !== newBounds.bottom)) {
                const eventType = "boundschanged";
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, { type: eventType, target: this });
                }
                if (this.parent) {
                    this.parent.markDirty();
                    this.parent.markDirtyBounds();
                }
                // Update tooltip position together with the Sprite
                if (this.getPrivate("showingTooltip")) {
                    this.showTooltip();
                }
            }
        }
        _fixMinBounds(bounds) {
            let minWidth = this.get("minWidth", this.getPrivate("minWidth"));
            let minHeight = this.get("minHeight", this.getPrivate("minHeight"));
            if (isNumber(minWidth)) {
                if (bounds.right - bounds.left < minWidth) {
                    bounds.right = bounds.left + minWidth;
                }
            }
            if (isNumber(minHeight)) {
                if (bounds.bottom - bounds.top < minHeight) {
                    bounds.bottom = bounds.top + minHeight;
                }
            }
            let privateWidth = this.getPrivate("width");
            let privateHeight = this.getPrivate("height");
            if (isNumber(privateWidth)) {
                if (privateWidth > 0) {
                    bounds.right = bounds.left + privateWidth;
                }
                else {
                    bounds.left = bounds.right + privateWidth;
                }
            }
            if (isNumber(privateHeight)) {
                if (privateHeight > 0) {
                    bounds.bottom = bounds.top + privateHeight;
                }
                else {
                    bounds.top = bounds.bottom + privateHeight;
                }
            }
        }
        _removeParent(parent) {
            if (parent) {
                parent.children.removeValue(this);
                removeFirst(parent._percentageSizeChildren, this);
                removeFirst(parent._percentagePositionChildren, this);
            }
        }
        _clearDirty() {
            super._clearDirty();
            this._sizeDirty = false;
            this._statesHandled = false;
        }
        /**
         * Simulate hover over element.
         */
        hover() {
            if (!this.isDisposed()) {
                this.showTooltip();
                this._handleOver();
            }
        }
        /**
         * Simulate unhover over element.
         */
        unhover() {
            if (!this.isDisposed()) {
                this.hideTooltip();
                this._handleOut();
            }
        }
        /**
         * Shows element's [[Tooltip]].
         */
        showTooltip(point) {
            if (!this.isDisposed()) {
                const tooltip = this.getTooltip();
                const tooltipText = this.get("tooltipText");
                const tooltipHTML = this.get("tooltipHTML");
                if ((tooltipText || tooltipHTML) && tooltip) {
                    const tooltipPosition = this.get("tooltipPosition");
                    const tooltipTarget = this.getPrivate("tooltipTarget", this);
                    if (tooltipPosition == "fixed" || !point) {
                        this._display._setMatrix();
                        point = this.toGlobal(tooltipTarget._getTooltipPoint());
                    }
                    tooltip.set("pointTo", point);
                    tooltip.set("tooltipTarget", tooltipTarget);
                    if (!tooltip.get("x")) {
                        tooltip.set("x", point.x);
                    }
                    if (!tooltip.get("y")) {
                        tooltip.set("y", point.y);
                    }
                    if (tooltipText) {
                        tooltip.label.set("text", tooltipText);
                    }
                    if (tooltipHTML) {
                        tooltip.label.set("html", tooltipHTML);
                    }
                    const dataItem = this.dataItem;
                    if (dataItem) {
                        tooltip.label._setDataItem(dataItem);
                    }
                    if (this.get("showTooltipOn") == "always" && (point.x < 0 || point.x > this._root.width() || point.y < 0 || point.y > this._root.height())) {
                        this.hideTooltip();
                        return;
                    }
                    tooltip.label.text.markDirtyText();
                    const promise = tooltip.show();
                    this.setPrivateRaw("showingTooltip", true);
                    return promise;
                }
            }
        }
        /**
         * Hides element's [[Tooltip]].
         */
        hideTooltip() {
            const tooltip = this.getTooltip();
            if (tooltip) {
                if (tooltip.get("tooltipTarget") == this.getPrivate("tooltipTarget", this) || this.get("tooltip") == tooltip) {
                    let timeout = tooltip.get("keepTargetHover") && tooltip.get("stateAnimationDuration", 0) == 0 ? 400 : undefined;
                    const promise = tooltip.hide(timeout);
                    this.setPrivateRaw("showingTooltip", false);
                    return promise;
                }
            }
        }
        _getTooltipPoint() {
            const bounds = this._localBounds;
            if (bounds) {
                let x = 0;
                let y = 0;
                if (!this.get("isMeasured")) {
                    x = relativeToValue(this.get("tooltipX", 0), this.width());
                    y = relativeToValue(this.get("tooltipY", 0), this.height());
                }
                else {
                    x = bounds.left + relativeToValue(this.get("tooltipX", 0), bounds.right - bounds.left);
                    y = bounds.top + relativeToValue(this.get("tooltipY", 0), bounds.bottom - bounds.top);
                }
                return { x, y };
            }
            return { x: 0, y: 0 };
        }
        /**
         * Returns [[Tooltip]] used for this element.
         *
         * @return Tooltip
         */
        getTooltip() {
            let tooltip = this.get("tooltip");
            if (!tooltip) {
                let parent = this.parent;
                if (parent) {
                    return parent.getTooltip();
                }
            }
            else {
                return tooltip;
            }
        }
        _updatePosition() {
            const parent = this.parent;
            let dx = this.get("dx", 0);
            let dy = this.get("dy", 0);
            let x = this.get("x");
            let _x = this.getPrivate("x");
            let xx = 0;
            let yy = 0;
            const position = this.get("position");
            if (x instanceof Percent) {
                if (parent) {
                    x = parent.innerWidth() * x.value + parent.get("paddingLeft", 0);
                }
                else {
                    x = 0;
                }
            }
            if (isNumber(x)) {
                xx = x + dx;
            }
            else {
                if (_x != null) {
                    xx = _x;
                }
                else if (parent) {
                    if (position == "relative") {
                        xx = parent.get("paddingLeft", 0) + dx;
                    }
                }
            }
            let y = this.get("y");
            let _y = this.getPrivate("y");
            if (y instanceof Percent) {
                if (parent) {
                    y = parent.innerHeight() * y.value + parent.get("paddingTop", 0);
                }
                else {
                    y = 0;
                }
            }
            if (isNumber(y)) {
                yy = y + dy;
            }
            else {
                if (_y != null) {
                    yy = _y;
                }
                else if (parent) {
                    if (position == "relative") {
                        yy = parent.get("paddingTop", 0) + dy;
                    }
                }
            }
            const display = this._display;
            if (display.x != xx || display.y != yy) {
                display.invalidateBounds();
                display.x = xx;
                display.y = yy;
                const eventType = "positionchanged";
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, { type: eventType, target: this });
                }
            }
            // Update tooltip position together with the Sprite
            if (this.getPrivate("showingTooltip")) {
                this.showTooltip();
            }
        }
        /**
         * Returns element's actual X position in pixels.
         *
         * @return X (px)
         */
        x() {
            let x = this.get("x");
            let _x = this.getPrivate("x");
            const parent = this.parent;
            if (parent) {
                if (x instanceof Percent) {
                    return relativeToValue(x, parent.innerWidth()) + parent.get("paddingLeft", 0);
                }
                else {
                    if (!isNumber(x)) {
                        if (_x != null) {
                            return _x;
                        }
                        else {
                            return parent.get("paddingLeft", this._display.x);
                        }
                    }
                    else {
                        return x;
                    }
                }
            }
            return this._display.x;
        }
        /**
         * Returns element's actual Y position in pixels.
         *
         * @return Y (px)
         */
        y() {
            let _y = this.getPrivate("y");
            if (_y != null) {
                return _y;
            }
            let y = this.get("y");
            const parent = this.parent;
            if (parent) {
                if (y instanceof Percent) {
                    return relativeToValue(y, parent.innerHeight()) + parent.get("paddingTop", 0);
                }
                else {
                    if (!isNumber(y)) {
                        if (_y != null) {
                            return _y;
                        }
                        else {
                            return parent.get("paddingTop", this._display.y);
                        }
                    }
                    else {
                        return y;
                    }
                }
            }
            return this._display.y;
        }
        _dispose() {
            super._dispose();
            this._display.dispose();
            this._removeTemplateField();
            this._removeParent(this.parent);
            this._root._removeFocusElement(this);
            const tooltip = this.get("tooltip");
            if (tooltip) {
                tooltip.dispose();
            }
            this.markDirty();
        }
        /**
         * @ignore
         */
        adjustedLocalBounds() {
            this._fixMinBounds(this._adjustedLocalBounds);
            return this._adjustedLocalBounds;
        }
        /**
         * Returns local coordinates of the element's bounds.
         *
         * @ignore
         * @return Global bounds
         */
        localBounds() {
            return this._localBounds;
        }
        /**
         * Returns adjusted local coordinates of the element's bounds.
         *
         * @ignore
         * @return Global bounds
         */
        bounds() {
            const bounds = this._adjustedLocalBounds;
            const x = this.x();
            const y = this.y();
            return { left: bounds.left + x, right: bounds.right + x, top: bounds.top + y, bottom: bounds.bottom + y };
        }
        /**
         * Returns global coordinates of the element's bounds.
         *
         * @ignore
         * @return Global bounds
         */
        globalBounds() {
            const bounds = this.localBounds();
            const p0 = this.toGlobal({ x: bounds.left, y: bounds.top });
            const p1 = this.toGlobal({ x: bounds.right, y: bounds.top });
            const p2 = this.toGlobal({ x: bounds.right, y: bounds.bottom });
            const p3 = this.toGlobal({ x: bounds.left, y: bounds.bottom });
            return {
                left: Math.min(p0.x, p1.x, p2.x, p3.x),
                top: Math.min(p0.y, p1.y, p2.y, p3.y),
                right: Math.max(p0.x, p1.x, p2.x, p3.x),
                bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
            };
        }
        _onShow(_duration) {
        }
        _onHide(_duration) {
        }
        /**
         * Plays initial reveal animation regardless if element is currently hidden
         * or visible.
         *
         * @param   duration  Duration of the animation in milliseconds
         * @param   delay     Delay showing of the element by X milliseconds
         * @return            Promise
         */
        appear(duration, delay) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.hide(0);
                if (delay) {
                    return new Promise((success, _error) => {
                        this.setTimeout(() => {
                            success(this.show(duration));
                        }, delay);
                    });
                }
                else {
                    return this.show(duration);
                }
            });
        }
        /**
         * Shows currently hidden element and returns a `Promise` which completes
         * when all showing animations are finished.
         *
         * ```TypeScript
         * series.show().then(function(ev) {
         *   console.log("Series is now fully visible");
         * })
         * ```
         * ```JavaScript
         * series.show().then(function(ev) {
         *   console.log("Series is now fully visible");
         * })
         * ```
         *
         * @return Promise
         */
        show(duration) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._isShowing) {
                    this._isHidden = false;
                    this._isShowing = true;
                    this._isHiding = false;
                    if (this.states.lookup("default").get("visible")) {
                        this.set("visible", true);
                    }
                    this._onShow(duration);
                    const animations = this.states.applyAnimate("default", duration);
                    yield waitForAnimations(animations);
                    this._isShowing = false;
                }
            });
        }
        /**
         * Hides the element and returns a `Promise` which completes when all hiding
         * animations are finished.
         *
         * ```TypeScript
         * series.hide().then(function(ev) {
         *   console.log("Series finished hiding");
         * })
         * ```
         * ```JavaScript
         * series.hide().then(function(ev) {
         *   console.log("Series finished hiding");
         * })
         * ```
         *
         * @return Promise
         */
        hide(duration) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this._isHiding && !this._isHidden) {
                    this._isHiding = true;
                    this._isShowing = false;
                    let state = this.states.lookup("hidden");
                    if (!state) {
                        state = this.states.create("hidden", {
                            "opacity": 0,
                            "visible": false
                        });
                    }
                    this._isHidden = true;
                    this._onHide(duration);
                    const animations = this.states.applyAnimate("hidden", duration);
                    yield waitForAnimations(animations);
                    this._isHiding = false;
                }
            });
        }
        /**
         * Returns `true` if this element is currently hidden.
         *
         * @return Is hidden?
         */
        isHidden() {
            return this._isHidden;
        }
        /**
         * Returns `true` if this element is currently animating to a default state.
         *
         * @return Is showing?
         */
        isShowing() {
            return this._isShowing;
        }
        /**
         * Returns `true` if this element is currently animating to a hidden state.
         *
         * @return Is hiding?
         */
        isHiding() {
            return this._isHiding;
        }
        /**
         * Returns `true` if this element is currently hovered by a pointer.
         *
         * @return Is hovered?
         */
        isHover() {
            return this._display.hovering();
        }
        /**
         * Returns `true` if this element does currently have focus.
         *
         * @return Is focused?
         */
        isFocus() {
            return this._root.focused(this);
        }
        /**
         * Returns `true` if this element is currently being dragged.
         *
         * @return Is dragged?
         */
        isDragging() {
            return this._isDragging;
        }
        /**
         * Returns `false` if if either public or private setting `visible` is set
         * to `false`, or `forceHidden` is set to `true`.
         *
         * @return Visible?
         */
        isVisible() {
            if (this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden")) {
                return true;
            }
            return false;
        }
        /**
         * Same as `isVisible()`, except it checks all ascendants, too.
         *
         * @since 5.2.7
         * @return Visible?
         */
        isVisibleDeep() {
            return this._parent ? (this._parent.isVisibleDeep() && this.isVisible()) : this.isVisible();
        }
        /**
         * Returns an actual opacity of the element, taking into account all parents.
         *
         * @return Opacity
         * @since 5.2.11
         */
        compositeOpacity() {
            const opacity = this.get("opacity", 1);
            return this._parent ? (this._parent.compositeOpacity() * opacity) : opacity;
        }
        /**
         * Returns an actual scale of the element, taking into account all parents.
         *
         * @return Opacity
         * @since 5.9.2
         */
        compositeScale() {
            const scale = this.get("scale", 1);
            return this._parent ? (this._parent.compositeScale() * scale) : scale;
        }
        /**
         * Returns an actual roation of the element, taking into account all parents.
         *
         * @return Opacity
         * @since 5.9.2
         */
        compositeRotation() {
            const rotation = this.get("rotation", 0);
            return this._parent ? (this._parent.compositeRotation() + rotation) : rotation;
        }
        /**
         * Returns width of this element in pixels.
         *
         * @return Width (px)
         */
        width() {
            let width = this.get("width");
            let maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));
            let minWidth = this.get("minWidth", this.getPrivate("minWidth"));
            let privateWidth = this.getPrivate("width");
            let w = 0;
            if (isNumber(privateWidth)) {
                w = privateWidth;
            }
            else {
                if (width == null) {
                    if (this._adjustedLocalBounds) {
                        w = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left;
                    }
                }
                else {
                    if (width instanceof Percent) {
                        const parent = this.parent;
                        if (parent) {
                            w = parent.innerWidth() * width.value;
                        }
                        else {
                            w = this._root.width() * width.value;
                        }
                    }
                    else if (isNumber(width)) {
                        w = width;
                    }
                }
            }
            if (isNumber(minWidth)) {
                w = Math.max(minWidth, w);
            }
            if (isNumber(maxWidth)) {
                w = Math.min(maxWidth, w);
            }
            return w;
        }
        /**
         * Returns maximum allowed width of this element in pixels.
         *
         * @return Maximum width (px)
         */
        maxWidth() {
            let maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));
            if (isNumber(maxWidth)) {
                return maxWidth;
            }
            else {
                let width = this.get("width");
                if (isNumber(width)) {
                    return width;
                }
            }
            const parent = this.parent;
            if (parent) {
                return parent.innerWidth();
            }
            return this._root.width();
        }
        /**
         * Returns maximum allowed height of this element in pixels.
         *
         * @return Maximum height (px)
         */
        maxHeight() {
            let maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));
            if (isNumber(maxHeight)) {
                return maxHeight;
            }
            else {
                let height = this.get("height");
                if (isNumber(height)) {
                    return height;
                }
            }
            const parent = this.parent;
            if (parent) {
                return parent.innerHeight();
            }
            return this._root.height();
        }
        /**
         * Returns height of this element in pixels.
         *
         * @return Height (px)
         */
        height() {
            let height = this.get("height");
            let maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));
            let minHeight = this.get("minHeight", this.getPrivate("minHeight"));
            let privateHeight = this.getPrivate("height");
            let h = 0;
            if (isNumber(privateHeight)) {
                h = privateHeight;
            }
            else {
                if (height == null) {
                    if (this._adjustedLocalBounds) {
                        h = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top;
                    }
                }
                else {
                    if (height instanceof Percent) {
                        const parent = this.parent;
                        if (parent) {
                            h = parent.innerHeight() * height.value;
                        }
                        else {
                            h = this._root.height() * height.value;
                        }
                    }
                    else if (isNumber(height)) {
                        h = height;
                    }
                }
            }
            if (isNumber(minHeight)) {
                h = Math.max(minHeight, h);
            }
            if (isNumber(maxHeight)) {
                h = Math.min(maxHeight, h);
            }
            return h;
        }
        _findStaticTemplate(f) {
            // templateField overrides template
            if (this._templateField && f(this._templateField)) {
                return this._templateField;
            }
            return super._findStaticTemplate(f);
        }
        _walkParents(f) {
            if (this._parent) {
                this._walkParent(f);
            }
        }
        _walkParent(f) {
            if (this._parent) {
                this._parent._walkParent(f);
            }
            f(this);
        }
        /**
         * Parent [[Container]] of this element.
         *
         * @return Parent container
         */
        get parent() {
            return this._parent;
        }
        _setParent(parent, updateChildren = false) {
            const prevParent = this._parent;
            if (parent !== prevParent) {
                this.markDirtyBounds();
                parent.markDirty();
                this._parent = parent;
                if (updateChildren) {
                    this._removeParent(prevParent);
                    if (parent) {
                        this._addPercentageSizeChildren();
                        this._addPercentagePositionChildren();
                    }
                }
                this.markDirtyPosition();
                this._applyThemes();
            }
        }
        /**
         * Returns an instance of [[NumberFormatter]] used in this element.
         *
         * If this element does not have it set, global one form [[Root]] is used.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
         * @return NumberFormatter instace
         */
        getNumberFormatter() {
            return this.get("numberFormatter", this._root.numberFormatter);
        }
        /**
         * Returns an instance of [[DateFormatter]] used in this element.
         *
         * If this element does not have it set, global one form [[Root]] is used.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
         * @return DateFormatter instace
         */
        getDateFormatter() {
            return this.get("dateFormatter", this._root.dateFormatter);
        }
        /**
         * Returns an instance of [[DurationFormatter]] used in this element.
         *
         * If this element does not have it set, global one form [[Root]] is used.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
         * @return DurationFormatter instace
         */
        getDurationFormatter() {
            return this.get("durationFormatter", this._root.durationFormatter);
        }
        /**
         * Converts X/Y coordinate within this element to a global coordinate.
         *
         * @param  point  Local coordinate
         * @return        Global coordinate
         */
        toGlobal(point) {
            return this._display.toGlobal(point);
        }
        /**
         * Converts global X/Y coordinate to a coordinate within this element.
         *
         * @param  point  Global coordinate
         * @return        Local coordinate
         */
        toLocal(point) {
            return this._display.toLocal(point);
        }
        _getDownPoint() {
            const id = this._getDownPointId();
            if (id) {
                return this._downPoints[id];
            }
        }
        _getDownPointId() {
            if (this._downPoints) {
                return keysOrdered(this._downPoints, (a, b) => {
                    if (a > b) {
                        return 1;
                    }
                    if (a < b) {
                        return -1;
                    }
                    return 0;
                })[0];
            }
        }
        /**
         * Moves sprite to the end of the parent's children array.
         *
         * Depending on `layout` setting of the parten container, it may effect the
         * positioning or overlapping order of the elements.
         */
        toFront() {
            const parent = this.parent;
            if (parent) {
                parent.children.moveValue(this, parent.children.length - 1);
            }
        }
        /**
         * Moves sprite to the beginning of the parent's children array.
         *
         * Depending on `layout` setting of the parten container, it may effect the
         * positioning or overlapping order of the elements.
         */
        toBack() {
            const parent = this.parent;
            if (parent) {
                parent.children.moveValue(this, 0);
            }
        }
    }
    Object.defineProperty(Sprite, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Sprite"
    });
    Object.defineProperty(Sprite, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([Sprite.className])
    });

    /**
     * Base class for patterns.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
     */
    class Pattern extends Entity {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_display", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._root._renderer.makeGraphics()
            });
            Object.defineProperty(this, "_backgroundDisplay", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._root._renderer.makeGraphics()
            });
            Object.defineProperty(this, "_clear", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_pattern", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _afterNew() {
            // Applying themes because pattern will not have parent
            super._afterNewApplyThemes();
        }
        get pattern() {
            return this._pattern;
        }
        _draw() { }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("repetition") || this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation") || this.isDirty("strokeWidth") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("colorOpacity") || this.isDirty("fillOpacity")) {
                this._clear = true;
            }
            this._checkDirtyFill();
        }
        _checkDirtyFill() {
            if (this.isDirty("color") || this.isDirty("fill")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear) {
                const repetition = this.get("repetition", "");
                const width = this.get("width", 100);
                const height = this.get("height", 100);
                const fill = this.get("fill");
                const fillOpacity = this.get("fillOpacity", 1);
                const backgroundDisplay = this._backgroundDisplay;
                const display = this._display;
                display.clear();
                backgroundDisplay.clear();
                if (fill && (fillOpacity > 0)) {
                    backgroundDisplay.beginFill(fill, fillOpacity);
                    backgroundDisplay.drawRect(0, 0, width, height);
                    backgroundDisplay.endFill();
                }
                display.angle = this.get("rotation", 0);
                //display.pivot = { x: width / 2, y: height / 2 };
                this._draw();
                this._pattern = this._root._renderer.createPattern(display, backgroundDisplay, repetition, width, height);
            }
            this._clear = false;
        }
    }
    Object.defineProperty(Pattern, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Pattern"
    });
    Object.defineProperty(Pattern, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([Pattern.className])
    });

    /**
     * Picture pattern.
     *
     * @since 5.2.15
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
     */
    class PicturePattern extends Pattern {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_image", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _beforeChanged() {
            super._beforeChanged();
            this._clear = true;
            if (this.isDirty("src")) {
                this._load();
            }
            const canvas = this.get("canvas");
            if (canvas) {
                this.set("width", canvas.width);
                this.set("height", canvas.height);
            }
        }
        _draw() {
            super._draw();
            const image = this._image;
            if (image) {
                const patternWidth = this.get("width", 100);
                const patternHeight = this.get("height", 100);
                // Fit
                const fit = this.get("fit", "image");
                let width = 0;
                let height = 0;
                if (fit == "pattern") {
                    width = patternWidth;
                    height = patternHeight;
                }
                else {
                    width = image.width;
                    height = image.height;
                    if (fit == "image") {
                        this.set("width", width);
                        this.set("height", height);
                    }
                }
                // Position
                const centered = this.get("centered", true);
                let x = 0;
                let y = 0;
                if (centered) {
                    x = patternWidth / 2 - width / 2;
                    y = patternHeight / 2 - height / 2;
                }
                this._display.image(image, width, height, x, y);
            }
            const canvas = this.get("canvas");
            if (canvas) {
                this._display.image(canvas, canvas.width, canvas.height, 0, 0);
            }
        }
        _load() {
            const src = this.get("src");
            if (src) {
                const image = new Image();
                //image.crossOrigin = "Anonymous";
                image.src = src;
                image.decode().then(() => {
                    this._image = image;
                    this._draw();
                    if (this.events.isEnabled("loaded")) {
                        this.events.dispatch("loaded", { type: "loaded", target: this });
                    }
                }).catch((_error) => {
                    // TODO: maybe raise error?
                });
            }
        }
    }
    Object.defineProperty(PicturePattern, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PicturePattern"
    });
    Object.defineProperty(PicturePattern, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Pattern.classNames.concat([PicturePattern.className])
    });

    /**
     * From https://github.com/pixijs/pixi.js/blob/3dd0ff9a935f0bc13a09aefff9eb2872f02c51b9/packages/canvas/canvas-renderer/src/utils/mapCanvasBlendModesToPixi.ts#L13
     */
    var BlendMode;
    (function (BlendMode) {
        BlendMode["ADD"] = "lighter";
        BlendMode["COLOR"] = "color";
        BlendMode["COLOR_BURN"] = "color-burn";
        BlendMode["COLOR_DODGE"] = "color-dodge";
        BlendMode["DARKEN"] = "darken";
        BlendMode["DIFFERENCE"] = "difference";
        BlendMode["DST_OVER"] = "destination-over";
        BlendMode["EXCLUSION"] = "exclusion";
        BlendMode["HARD_LIGHT"] = "hard-light";
        BlendMode["HUE"] = "hue";
        BlendMode["LIGHTEN"] = "lighten";
        BlendMode["LUMINOSITY"] = "luminosity";
        BlendMode["MULTIPLY"] = "multiply";
        BlendMode["NORMAL"] = "source-over";
        BlendMode["OVERLAY"] = "overlay";
        BlendMode["SATURATION"] = "saturation";
        BlendMode["SCREEN"] = "screen";
        BlendMode["SOFT_LIGHT"] = "soft-light";
        BlendMode["SRC_ATOP"] = "source-atop";
        BlendMode["XOR"] = "xor";
    })(BlendMode || (BlendMode = {}));

    const visualSettings = ["fill", "fillOpacity", "stroke", "strokeWidth", "strokeOpacity", "fillPattern", "strokePattern", "fillGradient", "strokeGradient", "strokeDasharray", "strokeDashoffset", "shadowBlur", "shadowColor", "shadowOpacity", "shadowOffsetX", "shadowOffsetY", "blur", "sepia", "invert", "brightness", "hue", "contrast", "saturate"];
    /**
     * Base class used for drawing shapes.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     * @important
     */
    class Graphics extends Sprite {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_display", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._root._renderer.makeGraphics()
            });
            Object.defineProperty(this, "_clear", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("draw") || this.isDirty("svgPath")) {
                this.markDirtyBounds();
            }
            if (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("visible") || this.isDirty("forceHidden") || this.isDirty("scale") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("lineJoin") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) {
                this._clear = true;
            }
            this._display.crisp = this.get("crisp", false);
            if (this.isDirty("fillGradient")) {
                const gradient = this.get("fillGradient");
                if (gradient) {
                    this._display.isMeasured = true;
                    const gradientTarget = gradient.get("target");
                    if (gradientTarget) {
                        this._disposers.push(gradientTarget.events.on("boundschanged", () => {
                            this._markDirtyKey("fill");
                        }));
                        this._disposers.push(gradientTarget.events.on("positionchanged", () => {
                            this._markDirtyKey("fill");
                        }));
                    }
                }
            }
            if (this.isDirty("strokeGradient")) {
                const gradient = this.get("strokeGradient");
                if (gradient) {
                    this._display.isMeasured = true;
                    const gradientTarget = gradient.get("target");
                    if (gradientTarget) {
                        this._disposers.push(gradientTarget.events.on("boundschanged", () => {
                            this._markDirtyKey("stroke");
                        }));
                        this._disposers.push(gradientTarget.events.on("positionchanged", () => {
                            this._markDirtyKey("stroke");
                        }));
                    }
                }
            }
        }
        _changed() {
            super._changed();
            if (this._clear) {
                this.markDirtyBounds();
                this.markDirtyLayer();
                this._display.clear();
                let strokeDasharray = this.get("strokeDasharray");
                if (isNumber(strokeDasharray)) {
                    if (strokeDasharray < 0.5) {
                        strokeDasharray = [0];
                    }
                    else {
                        strokeDasharray = [strokeDasharray];
                    }
                }
                this._display.setLineDash(strokeDasharray);
                const strokeDashoffset = this.get("strokeDashoffset");
                if (strokeDashoffset) {
                    this._display.setLineDashOffset(strokeDashoffset);
                }
                const blendMode = this.get("blendMode", BlendMode.NORMAL);
                this._display.blendMode = blendMode;
                const draw = this.get("draw");
                if (draw && typeof draw === "function") {
                    draw(this._display, this);
                }
                const svgPath = this.get("svgPath");
                if (svgPath != null) {
                    this._display.svgPath(svgPath);
                }
            }
        }
        _afterChanged() {
            super._afterChanged();
            if (this._clear) {
                const fill = this.get("fill");
                const fillGradient = this.get("fillGradient");
                const fillPattern = this.get("fillPattern");
                const fillOpacity = this.get("fillOpacity");
                const stroke = this.get("stroke");
                const strokeGradient = this.get("strokeGradient");
                const strokePattern = this.get("strokePattern");
                const shadowColor = this.get("shadowColor");
                const shadowBlur = this.get("shadowBlur");
                const shadowOffsetX = this.get("shadowOffsetX");
                const shadowOffsetY = this.get("shadowOffsetY");
                const shadowOpacity = this.get("shadowOpacity");
                if (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {
                    this._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);
                }
                if (fill && !fillGradient) {
                    this._display.beginFill(fill, fillOpacity);
                    this._display.endFill();
                }
                if (fillGradient) {
                    if (fill) {
                        const stops = fillGradient.get("stops", []);
                        if (stops.length) {
                            each$1(stops, (stop) => {
                                if ((!stop.color || stop.colorInherited) && fill) {
                                    stop.color = fill;
                                    stop.colorInherited = true;
                                }
                                if (stop.opacity == null || stop.opacityInherited) {
                                    stop.opacity = fillOpacity;
                                    stop.opacityInherited = true;
                                }
                            });
                        }
                    }
                    const gradient = fillGradient.getFill(this);
                    if (gradient) {
                        this._display.beginFill(gradient, fillOpacity);
                        this._display.endFill();
                    }
                }
                if (fillPattern) {
                    const pattern = fillPattern.pattern;
                    if (pattern) {
                        this._display.beginFill(pattern, fillOpacity);
                        this._display.endFill();
                        if (fillPattern instanceof PicturePattern) {
                            fillPattern.events.once("loaded", () => {
                                this._clear = true;
                                this.markDirty();
                            });
                        }
                    }
                }
                if (stroke || strokeGradient || strokePattern) {
                    const strokeOpacity = this.get("strokeOpacity");
                    let strokeWidth = this.get("strokeWidth", 1);
                    if (this.get("nonScalingStroke")) {
                        strokeWidth = strokeWidth / this.get("scale", 1);
                    }
                    if (this.get("crisp")) {
                        strokeWidth /= this._root._renderer.resolution;
                    }
                    const lineJoin = this.get("lineJoin");
                    if (stroke && !strokeGradient) {
                        this._display.lineStyle(strokeWidth, stroke, strokeOpacity, lineJoin);
                        this._display.endStroke();
                    }
                    if (strokeGradient) {
                        const stops = strokeGradient.get("stops", []);
                        if (stops.length) {
                            each$1(stops, (stop) => {
                                if ((!stop.color || stop.colorInherited) && stroke) {
                                    stop.color = stroke;
                                    stop.colorInherited = true;
                                }
                                if (stop.opacity == null || stop.opacityInherited) {
                                    stop.opacity = strokeOpacity;
                                    stop.opacityInherited = true;
                                }
                            });
                        }
                        const gradient = strokeGradient.getFill(this);
                        if (gradient) {
                            this._display.lineStyle(strokeWidth, gradient, strokeOpacity, lineJoin);
                            this._display.endStroke();
                        }
                    }
                    if (strokePattern) {
                        /*
                        let changed = false;
                        
                        if (stroke && (!strokePattern.get("color") || strokePattern.get("colorInherited"))) {
                            strokePattern.set("color", stroke);
                            strokePattern.set("colorInherited", true);
                            changed = true;
                        }
                        if (changed) {
                            // @todo: is this OK?
                            strokePattern._changed();
                        }
                        */
                        let pattern = strokePattern.pattern;
                        if (pattern) {
                            this._display.lineStyle(strokeWidth, pattern, strokeOpacity, lineJoin);
                            this._display.endStroke();
                            if (strokePattern instanceof PicturePattern) {
                                strokePattern.events.once("loaded", () => {
                                    this._clear = true;
                                    this.markDirty();
                                });
                            }
                        }
                    }
                }
                if (this.getPrivate("showingTooltip")) {
                    this.showTooltip();
                }
            }
            this._clear = false;
        }
    }
    Object.defineProperty(Graphics, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Graphics"
    });
    Object.defineProperty(Graphics, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Sprite.classNames.concat([Graphics.className])
    });

    /**
     * Draws a rectangle.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     * @important
     */
    class Rectangle extends Graphics {
        _afterNew() {
            super._afterNew();
            this._display.isMeasured = true;
            this.setPrivateRaw("trustBounds", true);
        }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear && !this.get("draw")) {
                this._draw();
            }
        }
        _draw() {
            this._display.drawRect(0, 0, this.width(), this.height());
        }
        _updateSize() {
            this.markDirty();
            this._clear = true;
        }
    }
    Object.defineProperty(Rectangle, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Rectangle"
    });
    Object.defineProperty(Rectangle, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Rectangle.className])
    });

    function eachChildren(container, f) {
        if (container.get("reverseChildren", false)) {
            container.children.eachReverse(f);
        }
        else {
            container.children.each(f);
        }
    }
    /**
     * Base class for [[Container]] layouts.
     */
    class Layout extends Entity {
    }
    Object.defineProperty(Layout, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Layout"
    });
    Object.defineProperty(Layout, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([Layout.className])
    });

    /**
     * A horizontal children layout for [[Container]].
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
     */
    class HorizontalLayout extends Layout {
        /**
         * @ignore
         */
        updateContainer(container) {
            let paddingLeft = container.get("paddingLeft", 0);
            let availableWidth = container.innerWidth();
            let totalPercent = 0;
            eachChildren(container, (child) => {
                if (child.isVisible()) {
                    if (child.get("position") == "relative") {
                        let childWidth = child.get("width");
                        if (childWidth instanceof Percent) {
                            totalPercent += childWidth.value;
                            let w = availableWidth * childWidth.value;
                            let minWidth = child.get("minWidth", child.getPrivate("minWidth", -Infinity));
                            if (minWidth > w) {
                                availableWidth -= minWidth;
                                totalPercent -= childWidth.value;
                            }
                            let maxWidth = child.get("maxWidth", child.getPrivate("maxWidth", Infinity));
                            if (w > maxWidth) {
                                availableWidth -= maxWidth;
                                totalPercent -= childWidth.value;
                            }
                        }
                        else {
                            if (!isNumber(childWidth)) {
                                childWidth = child.width();
                            }
                            availableWidth -= childWidth + child.get("marginLeft", 0) + child.get("marginRight", 0);
                        }
                    }
                }
            });
            if (availableWidth <= 0 || availableWidth == Infinity) {
                availableWidth = .1;
            }
            //if (availableWidth > 0) {
            eachChildren(container, (child) => {
                if (child.isVisible()) {
                    if (child.get("position") == "relative") {
                        let childWidth = child.get("width");
                        if (childWidth instanceof Percent) {
                            let privateWidth = availableWidth * childWidth.value / totalPercent - child.get("marginLeft", 0) - child.get("marginRight", 0);
                            let minWidth = child.get("minWidth", child.getPrivate("minWidth", -Infinity));
                            let maxWidth = child.get("maxWidth", child.getPrivate("maxWidth", Infinity));
                            privateWidth = Math.min(Math.max(minWidth, privateWidth), maxWidth);
                            child.setPrivate("width", privateWidth);
                        }
                        else {
                            if (child._prevSettings.width instanceof Percent) {
                                child.setPrivate("width", undefined);
                            }
                        }
                    }
                }
            });
            //}
            let prevX = paddingLeft;
            eachChildren(container, (child) => {
                if (child.get("position") == "relative") {
                    if (child.isVisible()) {
                        let bounds = child.adjustedLocalBounds();
                        let marginLeft = child.get("marginLeft", 0);
                        let marginRight = child.get("marginRight", 0);
                        let maxWidth = child.get("maxWidth");
                        let left = bounds.left;
                        let right = bounds.right;
                        if (maxWidth) {
                            if (right - left > maxWidth) {
                                right = left + maxWidth;
                            }
                        }
                        let x = prevX + marginLeft - left;
                        child.setPrivate("x", x);
                        prevX = x + right + marginRight;
                    }
                    else {
                        child.setPrivate("x", undefined);
                    }
                }
            });
        }
    }
    Object.defineProperty(HorizontalLayout, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "HorizontalLayout"
    });
    Object.defineProperty(HorizontalLayout, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Layout.classNames.concat([HorizontalLayout.className])
    });

    /**
     * A vertical children layout for [[Container]].
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
     */
    class VerticalLayout extends Layout {
        /**
         * @ignore
         */
        updateContainer(container) {
            let paddingTop = container.get("paddingTop", 0);
            let availableHeight = container.innerHeight();
            let totalPercent = 0;
            eachChildren(container, (child) => {
                if (child.isVisible()) {
                    if (child.get("position") == "relative") {
                        let childHeight = child.get("height");
                        if (childHeight instanceof Percent) {
                            totalPercent += childHeight.value;
                            let h = availableHeight * childHeight.value;
                            let minHeight = child.get("minHeight", child.getPrivate("minHeight", -Infinity));
                            if (minHeight > h) {
                                availableHeight -= minHeight;
                                totalPercent -= childHeight.value;
                            }
                            let maxHeight = child.get("maxHeight", child.getPrivate("maxHeight", Infinity));
                            if (h > maxHeight) {
                                availableHeight -= maxHeight;
                                totalPercent -= childHeight.value;
                            }
                        }
                        else {
                            if (!isNumber(childHeight)) {
                                childHeight = child.height();
                            }
                            availableHeight -= childHeight + child.get("marginTop", 0) + child.get("marginBottom", 0);
                        }
                    }
                }
            });
            if (availableHeight <= 0 || availableHeight == Infinity) {
                availableHeight = .1;
            }
            //if (availableHeight > 0) {
            eachChildren(container, (child) => {
                if (child.isVisible()) {
                    if (child.get("position") == "relative") {
                        let childHeight = child.get("height");
                        if (childHeight instanceof Percent) {
                            let privateHeight = availableHeight * childHeight.value / totalPercent - child.get("marginTop", 0) - child.get("marginBottom", 0);
                            let minHeight = child.get("minHeight", child.getPrivate("minHeight", -Infinity));
                            let maxHeight = child.get("maxHeight", child.getPrivate("maxHeight", Infinity));
                            privateHeight = Math.min(Math.max(minHeight, privateHeight), maxHeight);
                            child.setPrivate("height", privateHeight);
                        }
                        else {
                            if (child._prevSettings.height instanceof Percent) {
                                child.setPrivate("height", undefined);
                            }
                        }
                    }
                }
            });
            //}
            let prevY = paddingTop;
            eachChildren(container, (child) => {
                if (child.get("position") == "relative") {
                    if (child.isVisible()) {
                        let bounds = child.adjustedLocalBounds();
                        let marginTop = child.get("marginTop", 0);
                        let top = bounds.top;
                        let bottom = bounds.bottom;
                        let maxHeight = child.get("maxHeight");
                        if (maxHeight) {
                            if (bottom - top > maxHeight) {
                                bottom = top + maxHeight;
                            }
                        }
                        let marginBottom = child.get("marginBottom", 0);
                        let y = prevY + marginTop - top;
                        child.setPrivate("y", y);
                        prevY = y + bottom + marginBottom;
                    }
                    else {
                        child.setPrivate("y", undefined);
                    }
                }
            });
        }
    }
    Object.defineProperty(VerticalLayout, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "VerticalLayout"
    });
    Object.defineProperty(VerticalLayout, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Layout.classNames.concat([VerticalLayout.className])
    });

    /**
     * A grid children layout for [[Container]].
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
     */
    class GridLayout extends Layout {
        _afterNew() {
            this._setRawDefault("maxColumns", Number.MAX_VALUE);
            super._afterNew();
        }
        /**
         * @ignore
         */
        updateContainer(container) {
            let paddingLeft = container.get("paddingLeft", 0);
            let paddingRight = container.get("paddingRight", 0);
            let paddingTop = container.get("paddingTop", 0);
            let availableWidth = container.maxWidth() - paddingLeft - paddingRight;
            let minCellWidth = availableWidth;
            let maxCellWidth = 1;
            eachChildren(container, (child) => {
                if (child.get("visible") && child.getPrivate("visible") && !child.get("forceHidden")) {
                    if (child.get("position") != "absolute") {
                        let childWidth = child.width();
                        if (childWidth < minCellWidth) {
                            minCellWidth = childWidth;
                        }
                        if (childWidth > maxCellWidth) {
                            maxCellWidth = childWidth;
                        }
                    }
                }
            });
            minCellWidth = fitToRange(minCellWidth, 1, availableWidth);
            maxCellWidth = fitToRange(maxCellWidth, 1, availableWidth);
            let columnCount = 1;
            if (this.get("fixedWidthGrid")) {
                columnCount = availableWidth / maxCellWidth;
            }
            else {
                columnCount = availableWidth / minCellWidth;
            }
            columnCount = Math.max(1, Math.floor(columnCount));
            columnCount = Math.min(this.get("maxColumns", Number.MAX_VALUE), columnCount);
            let columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);
            let prevY = paddingTop;
            let column = 0;
            let maxColumnHeight = 0;
            columnCount = columnWidths.length;
            let prevX = paddingLeft;
            eachChildren(container, (child) => {
                if (child.get("position") == "relative" && child.isVisible()) {
                    const marginTop = child.get("marginTop", 0);
                    const marginBottom = child.get("marginBottom", 0);
                    let bounds = child.adjustedLocalBounds();
                    let marginLeft = child.get("marginLeft", 0);
                    let marginRight = child.get("marginRight", 0);
                    let x = prevX + marginLeft - bounds.left;
                    let y = prevY + marginTop - bounds.top;
                    child.setPrivate("x", x);
                    child.setPrivate("y", y);
                    prevX += columnWidths[column] + marginRight;
                    maxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);
                    column++;
                    if (column >= columnCount) {
                        column = 0;
                        prevX = paddingLeft;
                        prevY += maxColumnHeight;
                    }
                }
            });
        }
        /**
         * @ignore
         */
        getColumnWidths(container, columnCount, maxCellWidth, availableWidth) {
            let totalWidth = 0;
            let columnWidths = [];
            let column = 0;
            eachChildren(container, (child) => {
                let bounds = child.adjustedLocalBounds();
                if (child.get("position") != "absolute" && child.isVisible()) {
                    if (this.get("fixedWidthGrid")) {
                        columnWidths[column] = maxCellWidth;
                    }
                    else {
                        columnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get("marginLeft", 0) + child.get("marginRight", 0));
                    }
                    if (column < container.children.length - 1) {
                        column++;
                        if (column == columnCount) {
                            column = 0;
                        }
                    }
                }
            });
            each$1(columnWidths, (w) => {
                totalWidth += w;
            });
            if (totalWidth > availableWidth) {
                if (columnCount > 2) {
                    columnCount -= 1;
                    return this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);
                }
                else {
                    return [availableWidth];
                }
            }
            return columnWidths;
        }
    }
    Object.defineProperty(GridLayout, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "GridLayout"
    });
    Object.defineProperty(GridLayout, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Layout.classNames.concat([GridLayout.className])
    });

    class TextFormatter {
        /**
         * Replaces brackets with temporary placeholders.
         *
         * @ignore Exclude from docs
         * @param text  Input text
         * @return Escaped text
         */
        static escape(text) {
            return text.
                replace(/\[\[/g, this.prefix + "1").
                replace(/([^\/\]]{1})\]\]/g, "$1" + this.prefix + "2").
                replace(/\]\]/g, this.prefix + "2").
                replace(/\{\{/g, this.prefix + "3").
                replace(/\}\}/g, this.prefix + "4").
                replace(/\'\'/g, this.prefix + "5");
        }
        /**
         * Replaces placeholders back to brackets.
         *
         * @ignore Exclude from docs
         * @param text  Escaped text
         * @return Unescaped text
         */
        static unescape(text) {
            return text.
                replace(new RegExp(this.prefix + "1", "g"), "[[").
                replace(new RegExp(this.prefix + "2", "g"), "]]").
                replace(new RegExp(this.prefix + "3", "g"), "{{").
                replace(new RegExp(this.prefix + "4", "g"), "}}").
                replace(new RegExp(this.prefix + "5", "g"), "''");
        }
        /**
         * Cleans up the text text for leftover double square brackets.
         *
         * @ignore Exclude from docs
         * @param text  Input text
         * @return Cleaned up text
         */
        static cleanUp(text) {
            return text.
                replace(/\[\[/g, "[").
                replace(/\]\]/g, "]").
                replace(/\{\{/g, "{").
                replace(/\}\}/g, "}").
                replace(/\'\'/g, "'");
        }
        /**
         * Splits string into chunks. (style blocks, quoted blocks, regular blocks)
         *
         * If the second parameter `quotedBlocks` is set to `true` this method will
         * also single out text blocks enclosed within single quotes that no
         * formatting should be applied to, and they should be displayed as is.
         *
         * Default for the above is `false`, so that you can use single quote in text
         * without escaping it.
         *
         * If enabled, single quotes can be escaped by doubling it - adding two
         * single quotes, which will be replaced by a one single quote in the final
         * output.
         *
         * @ignore Exclude from docs
         * @param text          Text to chunk
         * @param quotedBlocks  Use quoted blocks
         * @param noFormatting  Formatting blocks will be treated as regular text
         * @return Array of string chunks
         */
        static chunk(text, quotedBlocks = false, noFormatting = false) {
            // Init result
            let res = [];
            // Replace double (escaped) square spaces and quotes with temporary codes
            text = this.escape(text);
            // Deal with style blocks
            let chunks = quotedBlocks ? text.split("'") : [text];
            for (let i = 0; i < chunks.length; i++) {
                let chunk = chunks[i];
                // Empty?
                if (chunk === "") {
                    continue;
                }
                if ((i % 2) === 0) {
                    // Text outside quotes
                    // Parse for style blocks which are "text" chunks, the rest chunks are
                    // "value"
                    chunk = chunk.replace(/\]\[/g, "]" + PLACEHOLDER + "[");
                    chunk = chunk.replace(/\[\]/g, "[ ]");
                    let chunks2 = chunk.split(/[\[\]]+/);
                    for (let i2 = 0; i2 < chunks2.length; i2++) {
                        let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                        // Placeholder?
                        if (chunk2 === PLACEHOLDER) {
                            continue;
                        }
                        // Empty?
                        if (chunk2 === "") {
                            continue;
                        }
                        // Block or value
                        if ((i2 % 2) === 0) {
                            res.push({
                                "type": "value",
                                "text": chunk2
                            });
                        }
                        else {
                            res.push({
                                "type": noFormatting ? "value" : "format",
                                "text": "[" + chunk2 + "]"
                            });
                        }
                    }
                }
                else {
                    // A text within doublequotes
                    // All chunks are "text"
                    let chunks2 = chunk.split(/[\[\]]+/);
                    for (let i2 = 0; i2 < chunks2.length; i2++) {
                        let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                        // Empty?
                        if (chunk2 === "") {
                            continue;
                        }
                        // Block or text
                        if ((i2 % 2) === 0) {
                            res.push({
                                "type": "text",
                                "text": chunk2
                            });
                        }
                        else if (this.isImage(chunk2)) {
                            res.push({
                                "type": "image",
                                "text": "[" + chunk2 + "]"
                            });
                        }
                        else {
                            res.push({
                                "type": "format",
                                "text": "[" + chunk2 + "]"
                            });
                        }
                    }
                }
            }
            return res;
        }
        /**
         * Checks if supplied format contains image information and should be
         * formatted as such.
         * I.e.: `[img: myImage.png]`
         *
         * @ignore
         * @param  text  Format
         * @return true if it is an image
         */
        static isImage(text) {
            return text.match(/img[ ]?:/) ? true : false;
        }
        static getTextStyle(style) {
            // let textStyle: string[] = [];
            // let textFill: string | undefined;
            let format = {};
            if (style == "" || style == "[ ]") {
                return {};
            }
            // Pre-process quoted text
            const q = style.match(/('[^']*')|("[^"]*")/gi);
            if (q) {
                for (let i = 0; i < q.length; i++) {
                    style = style.replace(q[i], q[i].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
                }
            }
            // Get style parts
            let b = style.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w\-]+)|(\/)/gi);
            // Empty?
            if (!b) {
                return {};
            }
            // Check each part
            for (let i = 0; i < b.length; i++) {
                if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {
                    format.fontWeight = b[i];
                }
                else if (b[i].match(/^(underline|line-through)$/i)) {
                    format.textDecoration = b[i];
                }
                else if (b[i] == "/") ;
                else if (!b[i].match(/:/)) {
                    // Color
                    format.fill = Color.fromString(b[i]);
                }
                else {
                    const p = b[i].replace("+", " ").split(/:[ ]*/);
                    format[p[0]] = p[1];
                    //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, ""));
                    //b[i] = b[i].replace(/\+/g, " ");
                }
            }
            return format;
        }
    }
    Object.defineProperty(TextFormatter, "prefix", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "__amcharts__"
    });

    /** @ignore */ /** */
    /**
     * @ignore
     */
    function populateString(target, string) {
        if (string != null) {
            string = "" + string;
            string = TextFormatter.escape(string);
            let tags = string.match(/\{([^}]+)\}/g);
            let i;
            if (tags) {
                for (i = 0; i < tags.length; i++) {
                    let tag = tags[i].replace(/\{([^}]+)\}/, "$1");
                    let value = getTagValue(target, tag);
                    if (value == null) {
                        value = "";
                    }
                    string = string.split(tags[i]).join(value);
                }
            }
            string = TextFormatter.unescape(string);
        }
        else {
            string = "";
        }
        // TODO: apply adapter?
        return string;
    }
    /**
     * @ignore
     */
    function getTagValue(target, tagName, format) {
        let value;
        const dataItem = target.dataItem;
        // Parse parts
        let parts = [];
        let reg = /(format[a-zA-Z]*)\((.*)\)|([^.]+)/g;
        let matches;
        while (true) {
            matches = reg.exec(tagName);
            if (matches === null) {
                break;
            }
            if (matches[3]) {
                // Simple property
                parts.push({
                    prop: matches[3]
                });
                // Check if maybe we should force a formatter on this value
                const dateFields = target.getDateFormatter().get("dateFields", []);
                const numericFields = target.getNumberFormatter().get("numericFields", []);
                const durationFields = target.getDurationFormatter().get("durationFields", []);
                if (dateFields.indexOf(matches[3]) !== -1) {
                    parts.push({
                        method: "formatDate",
                        params: []
                    });
                }
                else if (numericFields.indexOf(matches[3]) !== -1) {
                    parts.push({
                        method: "formatNumber",
                        params: []
                    });
                }
                else if (durationFields.indexOf(matches[3]) !== -1) {
                    parts.push({
                        method: "formatDuration",
                        params: []
                    });
                }
            }
            else {
                // Method
                // Parse parameters
                let params = [];
                if (trim(matches[2]) != "") {
                    let reg2 = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g;
                    let matches2;
                    while (true) {
                        matches2 = reg2.exec(matches[2]);
                        if (matches2 === null) {
                            break;
                        }
                        params.push(matches2[1] || matches2[2] || matches2[3]);
                    }
                }
                parts.push({
                    method: matches[1],
                    params: params
                });
            }
        }
        // Check if we can retrieve the value from data item
        if (dataItem) {
            // Check values
            value = getTagValueFromObject(target, parts, dataItem._settings);
            // Check properties
            if (value == null || isObject(value)) { // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.
                value = getTagValueFromObject(target, parts, dataItem);
            }
            // Check data context
            let dataContext = dataItem.dataContext;
            if (value == null && dataContext) {
                value = getTagValueFromObject(target, parts, dataContext);
                // Maybe it's a literal dot-separated name of the key in dataContext?
                if (value == null) {
                    value = getTagValueFromObject(target, [{
                            prop: tagName
                        }], dataContext);
                }
                // scond data context level sometimes exist (tree map)
                if (value == null && dataContext.dataContext) {
                    value = getTagValueFromObject(target, parts, dataContext.dataContext);
                }
            }
            // Check component's data item
            if (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {
                value = getTagValue(dataItem.component, tagName);
            }
        }
        // Check sprite's properties
        if (value == null) {
            value = getTagValueFromObject(target, parts, target);
        }
        // Finally, check the parent
        if (value == null && target.parent) {
            value = getTagValue(target.parent, tagName);
        }
        return value;
    }
    /**
     * @ignore
     */
    function getCustomDataValue(target, prop) {
        const customData = target.getPrivate("customData");
        if (isObject(customData)) {
            return customData[prop];
        }
    }
    /**
     * @ignore
     */
    function getTagValueFromObject(target, parts, object, format) {
        let current = object;
        let formatApplied = false;
        for (let i = 0, len = parts.length; i < len; i++) {
            let part = parts[i];
            if (part.prop) {
                // Regular property
                if (current instanceof Sprite) {
                    let tmp = current.get(part.prop);
                    if (tmp == null)
                        tmp = current.getPrivate(part.prop);
                    if (tmp == null)
                        tmp = getCustomDataValue(current, part.prop);
                    if (tmp == null)
                        tmp = current[part.prop];
                    current = tmp;
                }
                else if (current.get) {
                    let tmp = current.get(part.prop);
                    if (tmp == null)
                        tmp = current[part.prop];
                    current = tmp;
                }
                else {
                    current = current[part.prop];
                }
                if (current == null) {
                    // Not set, return undefined
                    return;
                }
            }
            else {
                // Method
                switch (part.method) {
                    case "formatNumber":
                        let numberValue = toNumber(current);
                        if (numberValue != null) {
                            current = target.getNumberFormatter().format(numberValue, format || part.params[0] || undefined);
                            formatApplied = true;
                        }
                        break;
                    case "formatDate":
                        let dateValue = toDate(current);
                        if (!isDate(dateValue) || isNaN$1(dateValue.getTime())) {
                            // Was not able to get date out of value, quitting and letting
                            // calling method try another value
                            return;
                        }
                        if (dateValue != null) {
                            current = target.getDateFormatter().format(dateValue, format || part.params[0] || undefined);
                            formatApplied = true;
                        }
                        break;
                    case "formatDuration":
                        let durationValue = toNumber(current);
                        if (durationValue != null) {
                            current = target.getDurationFormatter().format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);
                            formatApplied = true;
                        }
                        break;
                    case "urlEncode":
                    case "encodeURIComponent":
                        current = encodeURIComponent(current);
                        break;
                    default:
                        if (current[part.method]) {
                            current[part.method].apply(object, part.params);
                        }
                        break;
                }
            }
        }
        // Apply default format if it wasn't applied explicitly
        if (!formatApplied) {
            let formatParts = [{
                    method: "",
                    params: format
                }];
            if (format == null) {
                // Format is not set
                // Determine from the type of the value
                if (isNumber(current)) {
                    formatParts[0].method = "formatNumber";
                    formatParts[0].params = "";
                }
                else if (isDate(current)) {
                    formatParts[0].method = "formatDate";
                    formatParts[0].params = "";
                }
            }
            else {
                // Format set
                // Try to determine formatter based on the format
                let formatterType = getFormat(format);
                // format
                if (formatterType === "number") {
                    formatParts[0].method = "formatNumber";
                }
                else if (formatterType === "date") {
                    formatParts[0].method = "formatDate";
                }
                else if (formatterType === "duration") {
                    formatParts[0].method = "formatDuration";
                }
            }
            // Apply format
            if (formatParts[0].method) {
                current = getTagValueFromObject(target, formatParts, current);
            }
        }
        return current;
    }

    /**
     * A basic element that can have child elements, maintain their layout, and
     * have a background.
     *
     * It can have any [[Sprite]] element as a child, from very basic shapes, to
     * full-fledged charts.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info
     * @important
     */
    class Container extends Sprite {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_display", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._root._renderer.makeContainer()
            });
            Object.defineProperty(this, "_childrenDisplay", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._root._renderer.makeContainer()
            });
            /**
             * List of Container's child elements.
             */
            Object.defineProperty(this, "children", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new Children(this)
            });
            Object.defineProperty(this, "_percentageSizeChildren", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_percentagePositionChildren", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_prevWidth", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_prevHeight", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_contentWidth", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_contentHeight", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_contentMask", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_vsbd0", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_vsbd1", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _afterNew() {
            super._afterNew();
            this._display.addChild(this._childrenDisplay);
        }
        _dispose() {
            eachReverse(this.allChildren(), (child) => {
                child.dispose();
            });
            if (this.getPrivate("htmlElement")) {
                this._root._removeHTMLContent(this);
            }
            super._dispose();
        }
        _changed() {
            super._changed();
            if (this.isDirty("interactiveChildren")) {
                this._display.interactiveChildren = this.get("interactiveChildren", false);
            }
            if (this.isDirty("layout")) {
                this._prevWidth = 0;
                this._prevHeight = 0;
                this.markDirtyBounds();
                if (this._prevSettings.layout) {
                    this.children.each((child) => {
                        child.removePrivate("x");
                        child.removePrivate("y");
                    });
                }
            }
            if (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) {
                this.children.each((child) => {
                    child.markDirtyPosition();
                });
            }
            if (this.isDirty("maskContent")) {
                const childrenDisplay = this._childrenDisplay;
                let contentMask = this._contentMask;
                if (this.get("maskContent")) {
                    if (!contentMask) {
                        contentMask = Rectangle.new(this._root, {
                            x: -.5,
                            y: -.5,
                            width: this.width() + 1,
                            height: this.height() + 1
                        });
                        this._contentMask = contentMask;
                        childrenDisplay.addChildAt(contentMask._display, 0);
                        childrenDisplay.mask = contentMask._display;
                    }
                }
                else {
                    if (contentMask) {
                        childrenDisplay.removeChild(contentMask._display);
                        childrenDisplay.mask = null;
                        contentMask.dispose();
                        this._contentMask = undefined;
                    }
                }
            }
        }
        _updateSize() {
            super._updateSize();
            each$1(this._percentageSizeChildren, (child) => {
                child._updateSize();
            });
            each$1(this._percentagePositionChildren, (child) => {
                child.markDirtyPosition();
                child._updateSize();
            });
            this.updateBackground();
        }
        updateBackground() {
            const background = this.get("background");
            let bounds = this._localBounds;
            if (bounds && !this.isHidden()) {
                let x = bounds.left;
                let y = bounds.top;
                let w = bounds.right - x;
                let h = bounds.bottom - y;
                let maxWidth = this.get("maxWidth");
                let maxHeight = this.get("maxHeight");
                if (maxHeight) {
                    if (h > maxHeight) {
                        h = maxHeight;
                    }
                }
                if (maxWidth) {
                    if (w > maxWidth) {
                        w = maxWidth;
                    }
                }
                let width = this.width();
                let height = this.height();
                if (background) {
                    background.setAll({ width: w, height: h, x: x, y: y });
                    if (this._display.interactive) {
                        background._display.interactive = true;
                    }
                }
                const contentMask = this._contentMask;
                if (contentMask) {
                    contentMask.setAll({ width: width + 1, height: height + 1 });
                }
                const verticalScrollbar = this.get("verticalScrollbar");
                if (verticalScrollbar) {
                    verticalScrollbar.set("height", height);
                    verticalScrollbar.set("x", width - verticalScrollbar.width() - verticalScrollbar.get("marginRight", 0));
                    verticalScrollbar.set("end", verticalScrollbar.get("start", 0) + height / this._contentHeight);
                    const bg = verticalScrollbar.get("background");
                    if (bg) {
                        bg.setAll({ width: verticalScrollbar.width(), height: height });
                    }
                    let visible = true;
                    if (this._contentHeight <= height) {
                        visible = false;
                    }
                    verticalScrollbar.setPrivate("visible", visible);
                }
            }
        }
        _applyThemes(force = false) {
            if (super._applyThemes(force)) {
                this.eachChildren((child) => {
                    child._applyThemes(force);
                });
                return true;
            }
            else {
                return false;
            }
        }
        _applyState(name) {
            super._applyState(name);
            if (this.get("setStateOnChildren")) {
                this.eachChildren((child) => {
                    child.states.apply(name);
                });
            }
        }
        _applyStateAnimated(name, duration) {
            super._applyStateAnimated(name, duration);
            if (this.get("setStateOnChildren")) {
                this.eachChildren((child) => {
                    child.states.applyAnimate(name, duration);
                });
            }
        }
        /**
         * Returns container's inner width (width without padding) in pixels.
         *
         * @return Inner width (px)
         */
        innerWidth() {
            return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0);
        }
        /**
         * Returns container's inner height (height without padding) in pixels.
         *
         * @return Inner height (px)
         */
        innerHeight() {
            return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0);
        }
        _getBounds() {
            let width = this.get("width");
            let height = this.get("height");
            let pWidth = this.getPrivate("width");
            let pHeight = this.getPrivate("height");
            let bounds = {
                left: 0,
                top: 0,
                right: this.width(),
                bottom: this.height()
            };
            let layout = this.get("layout");
            let horizontal = false;
            let vertical = false;
            if (layout instanceof HorizontalLayout || layout instanceof GridLayout) {
                horizontal = true;
            }
            if (layout instanceof VerticalLayout) {
                vertical = true;
            }
            if ((width != null || pWidth != null) && (height != null || pHeight != null) && !this.get("verticalScrollbar")) ;
            else {
                let m = Number.MAX_VALUE;
                let l = m;
                let r = -m;
                let t = m;
                let b = -m;
                const paddingLeft = this.get("paddingLeft", 0);
                const paddingTop = this.get("paddingTop", 0);
                const paddingRight = this.get("paddingRight", 0);
                const paddingBottom = this.get("paddingBottom", 0);
                this.children.each((child) => {
                    if (child.get("position") != "absolute" && child.get("isMeasured")) {
                        let childBounds = child.adjustedLocalBounds();
                        let childX = child.x();
                        let childY = child.y();
                        let cl = childX + childBounds.left;
                        let cr = childX + childBounds.right;
                        let ct = childY + childBounds.top;
                        let cb = childY + childBounds.bottom;
                        if (horizontal) {
                            cl -= child.get("marginLeft", 0);
                            cr += child.get("marginRight", 0);
                        }
                        if (vertical) {
                            ct -= child.get("marginTop", 0);
                            cb += child.get("marginBottom", 0);
                        }
                        if (cl < l) {
                            l = cl;
                        }
                        if (cr > r) {
                            r = cr;
                        }
                        if (ct < t) {
                            t = ct;
                        }
                        if (cb > b) {
                            b = cb;
                        }
                    }
                });
                if (l == m) {
                    l = 0;
                }
                if (r == -m) {
                    r = 0;
                }
                if (t == m) {
                    t = 0;
                }
                if (b == -m) {
                    b = 0;
                }
                bounds.left = l - paddingLeft;
                bounds.top = t - paddingTop;
                bounds.right = r + paddingRight;
                bounds.bottom = b + paddingBottom;
                const minWidth = this.get("minWidth");
                if (isNumber(minWidth) && minWidth > 0) {
                    if (bounds.right - bounds.left < minWidth) {
                        if (bounds.right >= minWidth) {
                            bounds.left = bounds.right - minWidth;
                        }
                        else {
                            bounds.right = bounds.left + minWidth;
                        }
                    }
                }
                const minHeight = this.get("minHeight");
                if (isNumber(minHeight) && minHeight > 0) {
                    if (bounds.bottom - bounds.top < minHeight) {
                        if (bounds.bottom >= minHeight) {
                            bounds.top = bounds.bottom - minHeight;
                        }
                        else {
                            bounds.bottom = bounds.top + minHeight;
                        }
                    }
                }
            }
            this._contentWidth = bounds.right - bounds.left;
            this._contentHeight = bounds.bottom - bounds.top;
            if (isNumber(width)) {
                bounds.left = 0;
                bounds.right = width;
            }
            if (isNumber(pWidth)) {
                bounds.left = 0;
                bounds.right = pWidth;
            }
            if (isNumber(height)) {
                bounds.top = 0;
                bounds.bottom = height;
            }
            if (isNumber(pHeight)) {
                bounds.top = 0;
                bounds.bottom = pHeight;
            }
            this._localBounds = bounds;
        }
        _updateBounds() {
            const layout = this.get("layout");
            if (layout) {
                layout.updateContainer(this);
            }
            super._updateBounds();
            this.updateBackground();
        }
        /**
         * @ignore
         */
        markDirty() {
            super.markDirty();
            this._root._addDirtyParent(this);
        }
        _prepareChildren() {
            const innerWidth = this.innerWidth();
            const innerHeight = this.innerHeight();
            if (innerWidth != this._prevWidth || innerHeight != this._prevHeight) {
                let layout = this.get("layout");
                let horizontal = false;
                let vertical = false;
                if (layout) {
                    if (layout instanceof HorizontalLayout || layout instanceof GridLayout) {
                        horizontal = true;
                    }
                    if (layout instanceof VerticalLayout) {
                        vertical = true;
                    }
                }
                each$1(this._percentageSizeChildren, (child) => {
                    if (!horizontal) {
                        let width = child.get("width");
                        if (width instanceof Percent) {
                            child.setPrivate("width", width.value * innerWidth);
                        }
                    }
                    if (!vertical) {
                        let height = child.get("height");
                        if (height instanceof Percent) {
                            child.setPrivate("height", height.value * innerHeight);
                        }
                    }
                });
                each$1(this._percentagePositionChildren, (child) => {
                    child.markDirtyPosition();
                    child.markDirtyBounds();
                });
                this._prevWidth = innerWidth;
                this._prevHeight = innerHeight;
                this._sizeDirty = true;
                this.updateBackground();
            }
            this._handleStates();
        }
        _updateHTMLContent() {
            const html = this.get("html");
            if (html && html !== "") {
                this._root._setHTMLContent(this, populateString(this, this.get("html", "")));
            }
            else {
                this._root._removeHTMLContent(this);
            }
            this._root._positionHTMLElement(this);
        }
        _updateChildren() {
            if (this.isDirty("html")) {
                this._updateHTMLContent();
            }
            if (this.isDirty("verticalScrollbar")) {
                const verticalScrollbar = this.get("verticalScrollbar");
                if (verticalScrollbar) {
                    verticalScrollbar._setParent(this);
                    verticalScrollbar.startGrip.setPrivate("visible", false);
                    verticalScrollbar.endGrip.setPrivate("visible", false);
                    this.set("maskContent", true);
                    this.set("paddingRight", verticalScrollbar.width() + verticalScrollbar.get("marginRight", 0) + verticalScrollbar.get("marginLeft", 0));
                    let background = this.get("background");
                    if (!background) {
                        background = this.set("background", Rectangle.new(this._root, {
                            themeTags: ["background"],
                            fillOpacity: 0,
                            fill: this._root.interfaceColors.get("alternativeBackground")
                        }));
                    }
                    this._vsbd0 = this.events.on("wheel", (event) => {
                        const wheelEvent = event.originalEvent;
                        // Ignore wheel event if it is happening on a non-chart element, e.g. if
                        // some page element is over the chart.
                        if (isLocalEvent(wheelEvent, this)) {
                            wheelEvent.preventDefault();
                        }
                        else {
                            return;
                        }
                        let shiftY = wheelEvent.deltaY / 5000;
                        const start = verticalScrollbar.get("start", 0);
                        const end = verticalScrollbar.get("end", 1);
                        if (start + shiftY <= 0) {
                            shiftY = -start;
                        }
                        if (end + shiftY >= 1) {
                            shiftY = 1 - end;
                        }
                        if (start + shiftY >= 0 && end + shiftY <= 1) {
                            verticalScrollbar.set("start", start + shiftY);
                            verticalScrollbar.set("end", end + shiftY);
                        }
                    });
                    this._disposers.push(this._vsbd0);
                    this._vsbd1 = verticalScrollbar.events.on("rangechanged", () => {
                        let h = this._contentHeight;
                        const childrenDisplay = this._childrenDisplay;
                        const contentMask = this._contentMask;
                        childrenDisplay.y = -verticalScrollbar.get("start", 0) * h;
                        childrenDisplay.markDirtyLayer();
                        if (contentMask) {
                            contentMask._display.y = -childrenDisplay.y;
                            childrenDisplay.mask = contentMask._display;
                        }
                    });
                    this._disposers.push(this._vsbd1);
                    this._display.addChild(verticalScrollbar._display);
                }
                else {
                    const previous = this._prevSettings.verticalScrollbar;
                    if (previous) {
                        this._display.removeChild(previous._display);
                        if (this._vsbd0) {
                            this._vsbd0.dispose();
                        }
                        if (this._vsbd1) {
                            this._vsbd1.dispose();
                        }
                        const childrenDisplay = this._childrenDisplay;
                        childrenDisplay.y = 0;
                        this.setPrivate("height", undefined);
                        this.set("maskContent", false);
                        this.set("paddingRight", undefined);
                    }
                }
            }
            if (this.isDirty("background")) {
                // TODO maybe this should dispose ?
                const previous = this._prevSettings["background"];
                if (previous) {
                    this._display.removeChild(previous._display);
                }
                const background = this.get("background");
                if (background instanceof Sprite) {
                    background.set("isMeasured", false);
                    background._setParent(this);
                    this._display.addChildAt(background._display, 0);
                }
            }
            if (this.isDirty("mask")) {
                const mask = this.get("mask");
                const previous = this._prevSettings["mask"];
                if (previous) {
                    this._display.removeChild(previous._display);
                    if (previous != mask) {
                        previous.dispose();
                    }
                }
                if (mask) {
                    const parent = mask.parent;
                    if (parent) {
                        parent.children.removeValue(mask);
                    }
                    mask._setParent(this);
                    this._display.addChildAt(mask._display, 0);
                    this._childrenDisplay.mask = mask._display;
                }
            }
        }
        _processTemplateField() {
            super._processTemplateField();
            this.children.each((child) => {
                child._processTemplateField();
            });
        }
        /**
         * @ignore
         */
        walkChildren(f) {
            this.children.each((child) => {
                if (child instanceof Container) {
                    child.walkChildren(f);
                }
                f(child);
            });
        }
        eachChildren(f) {
            const background = this.get("background");
            if (background) {
                f(background);
            }
            const verticalScrollbar = this.get("verticalScrollbar");
            if (verticalScrollbar) {
                f(verticalScrollbar);
            }
            const mask = this.get("mask");
            if (mask) {
                f(mask);
            }
            this.children.values.forEach((child) => {
                f(child);
            });
        }
        allChildren() {
            const output = [];
            this.eachChildren((x) => {
                output.push(x);
            });
            return output;
        }
        _setDataItem(dataItem) {
            const updated = (dataItem !== this._dataItem);
            super._setDataItem(dataItem);
            const html = this.get("html", "");
            if (html && html !== "" && updated) {
                this._root._setHTMLContent(this, populateString(this, html));
            }
        }
    }
    Object.defineProperty(Container, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Container"
    });
    Object.defineProperty(Container, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Sprite.classNames.concat([Container.className])
    });

    /**
     * @ignore Text is an internal class. Use Label instead.
     */
    class Text extends Sprite {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "textStyle", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._root._renderer.makeTextStyle()
            });
            Object.defineProperty(this, "_display", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._root._renderer.makeText("", this.textStyle)
            });
            Object.defineProperty(this, "_textStyles", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: [
                    "textAlign",
                    "fontFamily",
                    "fontSize",
                    "fontStyle",
                    "fontWeight",
                    "fontStyle",
                    "fontVariant",
                    "textDecoration",
                    "shadowColor",
                    "shadowBlur",
                    "shadowOffsetX",
                    "shadowOffsetY",
                    "shadowOpacity",
                    // "leading",
                    // "letterSpacing",
                    "lineHeight",
                    "baselineRatio",
                    //"padding",
                    // "stroke",
                    // "strokeThickness",
                    // "trim",
                    // "wordWrap",
                    "direction",
                    "textBaseline",
                    "oversizedBehavior",
                    "breakWords",
                    "ellipsis",
                    "minScale",
                    "maxChars"
                ]
            });
            Object.defineProperty(this, "_originalScale", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _updateBounds() {
            if (!this.get("text")) {
                let newBounds = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                };
                this._adjustedLocalBounds = newBounds;
            }
            else {
                super._updateBounds();
                let fillGradient = this.get("fillGradient");
                if (fillGradient) {
                    this._display.style.fill = fillGradient.getFill(this);
                }
            }
        }
        _changed() {
            super._changed();
            this._display.clear();
            let textStyle = this.textStyle;
            if (this.isDirty("opacity")) {
                let opacity = this.get("opacity", 1);
                this._display.alpha = opacity;
            }
            if (this.isDirty("text") || this.isDirty("populateText")) {
                this._display.text = this._getText();
                this.markDirtyBounds();
                if (this.get("role") == "tooltip") {
                    this._root.updateTooltip(this);
                }
            }
            if (this.isPrivateDirty("tooltipElement")) {
                const tooltipElement = this.getPrivate("tooltipElement");
                if (tooltipElement) {
                    this._disposers.push(new Disposer(() => {
                        this._root._removeTooltipElement(this);
                    }));
                }
            }
            if (this.isDirty("width")) {
                textStyle.wordWrapWidth = this.width();
                this.markDirtyBounds();
            }
            if (this.isDirty("oversizedBehavior")) {
                textStyle.oversizedBehavior = this.get("oversizedBehavior", "none");
                this.markDirtyBounds();
            }
            if (this.isDirty("breakWords")) {
                textStyle.breakWords = this.get("breakWords", false);
                this.markDirtyBounds();
            }
            if (this.isDirty("ellipsis")) {
                textStyle.ellipsis = this.get("ellipsis");
                this.markDirtyBounds();
            }
            if (this.isDirty("ignoreFormatting")) {
                textStyle.ignoreFormatting = this.get("ignoreFormatting", false);
                this.markDirtyBounds();
            }
            if (this.isDirty("minScale")) {
                textStyle.minScale = this.get("minScale", 0);
                this.markDirtyBounds();
            }
            if (this.isDirty("fill") || this.isDirty("fillGradient")) {
                const fill = this.get("fill");
                const fillGradient = this.get("fillGradient");
                const fillOpacity = this.get("fillOpacity");
                if (fillGradient) {
                    if (fill) {
                        const stops = fillGradient.get("stops", []);
                        if (stops.length) {
                            each$1(stops, (stop) => {
                                if ((!stop.color || stop.colorInherited) && fill) {
                                    stop.color = fill;
                                    stop.colorInherited = true;
                                }
                                if (stop.opacity == null || stop.opacityInherited) {
                                    stop.opacity = fillOpacity;
                                    stop.opacityInherited = true;
                                }
                            });
                        }
                    }
                    textStyle.fill = fillGradient.getFill(this);
                }
                else if (fill) {
                    textStyle.fill = fill;
                }
            }
            if (this.isDirty("fillOpacity")) {
                let fillOpacity = this.get("fillOpacity", 1);
                if (fillOpacity) {
                    textStyle.fillOpacity = fillOpacity;
                }
            }
            if (this.isDirty("maxWidth") || this.isPrivateDirty("maxWidth")) {
                textStyle.maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));
                this.markDirtyBounds();
            }
            if (this.isDirty("maxHeight") || this.isPrivateDirty("maxHeight")) {
                textStyle.maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));
                this.markDirtyBounds();
            }
            each$1(this._textStyles, (styleName) => {
                if (this._dirty[styleName]) {
                    textStyle[styleName] = this.get(styleName);
                    this.markDirtyBounds();
                }
            });
            textStyle["fontSize"] = this.get("fontSize");
            textStyle["fontFamily"] = this.get("fontFamily");
            this._display.style = textStyle;
            if (this.isDirty("role") && this.get("role") == "tooltip") {
                this._root.updateTooltip(this);
            }
        }
        _getText() {
            let text = this.get("text", "");
            if (this.get("maxChars")) {
                text = truncateTextWithEllipsis(text, this.get("maxChars", 100000000), this.get("breakWords"), this.get("ellipsis"));
            }
            return this.get("populateText") ? populateString(this, text) : text;
        }
        _getAccessibleText() {
            const ariaLabel = this.get("ariaLabel");
            if (ariaLabel !== undefined) {
                return this.get("populateText") ? populateString(this, ariaLabel) : ariaLabel;
            }
            return this._getText();
        }
        /**
         * Forces the text to be re-evaluated and re-populated.
         */
        markDirtyText() {
            this._display.text = this._getText();
            if (this.get("role") == "tooltip") {
                this._root.updateTooltip(this);
            }
            this.markDirtyBounds();
            this.markDirty();
        }
        _setDataItem(dataItem) {
            super._setDataItem(dataItem);
            if (this.get("populateText")) {
                this.markDirtyText();
            }
        }
        getNumberFormatter() {
            if (this.parent) {
                return this.parent.getNumberFormatter();
            }
            else {
                return super.getNumberFormatter();
            }
        }
        getDateFormatter() {
            if (this.parent) {
                return this.parent.getDateFormatter();
            }
            else {
                return super.getDateFormatter();
            }
        }
        getDurationFormatter() {
            if (this.parent) {
                return this.parent.getDurationFormatter();
            }
            else {
                return super.getDurationFormatter();
            }
        }
    }
    Object.defineProperty(Text, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Text"
    });
    Object.defineProperty(Text, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Sprite.classNames.concat([Text.className])
    });

    /** @ignore */ /** */
    /**
     * @ignore
     */
    class Native {
        constructor() {
            Object.defineProperty(this, "_observer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_targets", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            this._observer = new ResizeObserver((entries) => {
                each$1(entries, (entry) => {
                    each$1(this._targets, (x) => {
                        if (x.target === entry.target) {
                            x.callback();
                        }
                    });
                });
            });
        }
        addTarget(target, callback) {
            this._observer.observe(target, { box: "border-box" });
            this._targets.push({ target, callback });
        }
        removeTarget(target) {
            this._observer.unobserve(target);
            keepIf(this._targets, (x) => {
                return x.target !== target;
            });
        }
    }
    /**
     * @ignore
     */
    class Raf {
        constructor() {
            Object.defineProperty(this, "_timer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: null
            });
            Object.defineProperty(this, "_targets", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
        }
        addTarget(target, callback) {
            if (this._timer === null) {
                let lastTime = null;
                const loop = () => {
                    const currentTime = Date.now();
                    if (lastTime === null || currentTime > (lastTime + Raf.delay)) {
                        lastTime = currentTime;
                        each$1(this._targets, (x) => {
                            let newSize = x.target.getBoundingClientRect();
                            if (newSize.width !== x.size.width || newSize.height !== x.size.height) {
                                x.size = newSize;
                                x.callback();
                            }
                        });
                    }
                    if (this._targets.length === 0) {
                        this._timer = null;
                    }
                    else {
                        this._timer = requestAnimationFrame(loop);
                    }
                };
                this._timer = requestAnimationFrame(loop);
            }
            // We start off with fake bounds so that sensor always kicks in
            let size = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };
            this._targets.push({ target, callback, size });
        }
        removeTarget(target) {
            keepIf(this._targets, (x) => {
                return x.target !== target;
            });
            if (this._targets.length === 0) {
                if (this._timer !== null) {
                    cancelAnimationFrame(this._timer);
                    this._timer = null;
                }
            }
        }
    }
    Object.defineProperty(Raf, "delay", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 200
    });
    /**
     * @ignore
     */
    let observer = null;
    /**
     * @ignore
     */
    function makeSensor() {
        if (observer === null) {
            if (typeof ResizeObserver !== "undefined") {
                observer = new Native();
            }
            else {
                observer = new Raf();
            }
        }
        return observer;
    }
    /**
     * @ignore
     */
    class ResizeSensor {
        constructor(element, callback) {
            Object.defineProperty(this, "_sensor", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_element", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_listener", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_disposed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            this._sensor = makeSensor();
            this._element = element;
            // This is needed because we need to know when the window is zoomed
            this._listener = onZoom(callback);
            this._sensor.addTarget(element, callback);
        }
        isDisposed() {
            return this._disposed;
        }
        dispose() {
            if (!this._disposed) {
                this._disposed = true;
                this._sensor.removeTarget(this._element);
                this._listener.dispose();
            }
        }
        get sensor() {
            return this._sensor;
        }
    }

    /**
     * Presets for common UI elements.
     */
    class InterfaceColors extends Entity {
    }
    Object.defineProperty(InterfaceColors, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InterfaceColors"
    });
    Object.defineProperty(InterfaceColors, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([InterfaceColors.className])
    });

    /**
     * Creates a label with support for in-line styling and data bindings.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/labels/} for more info
     */
    class Label extends Container {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_text", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_textKeys", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: [
                    "text",
                    "fill",
                    "fillGradient",
                    "fillOpacity",
                    "textAlign",
                    "fontFamily",
                    "fontSize",
                    "fontStyle",
                    "fontWeight",
                    "fontStyle",
                    "fontVariant",
                    "textDecoration",
                    "shadowColor",
                    "shadowBlur",
                    "shadowOffsetX",
                    "shadowOffsetY",
                    "shadowOpacity",
                    // "leading",
                    // "letterSpacing",
                    "lineHeight",
                    "baselineRatio",
                    //"padding",
                    // "stroke",
                    // "strokeThickness",
                    // "trim",
                    // "wordWrap",
                    "direction",
                    "textBaseline",
                    "oversizedBehavior",
                    "breakWords",
                    "ellipsis",
                    "minScale",
                    "populateText",
                    "role",
                    "ignoreFormatting",
                    "maxChars",
                    "ariaLabel"
                ]
            });
        }
        /**
         * @ignore Text is not to be used directly
         */
        get text() {
            return this._text;
        }
        _afterNew() {
            super._afterNew();
            this._makeText();
            each$1(this._textKeys, (property) => {
                const propValue = this.get(property);
                if (propValue != undefined) {
                    this._text.set(property, propValue);
                }
            });
            if (this.get("html", "") !== "") {
                this._text.set("text", "");
            }
            this.onPrivate("maxWidth", () => {
                this._setMaxDimentions();
            });
            this.onPrivate("maxHeight", () => {
                this._setMaxDimentions();
            });
        }
        _makeText() {
            this._text = this.children.push(Text.new(this._root, {}));
        }
        _updateChildren() {
            super._updateChildren();
            const text = this._text;
            each$1(this._textKeys, (property) => {
                this._text.set(property, this.get(property));
            });
            if (this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isDirty("rotation")) {
                this._setMaxDimentions();
            }
            // Do not show regular text if HTML is used
            if (this.get("html", "") !== "") {
                text.set("text", "");
            }
            else {
                text.set("text", this.get("text"));
                this._maybeUpdateHTMLColor();
            }
            if (this.isDirty("fill") || this.isDirty("fillGradient")) {
                this._maybeUpdateHTMLColor();
            }
            if (this.isDirty("textAlign") || this.isDirty("width")) {
                const textAlign = this.get("textAlign");
                let x;
                if (this.get("width") != null) {
                    if (textAlign == "right") {
                        x = p100;
                    }
                    else if (textAlign == "center") {
                        x = p50;
                    }
                    else {
                        x = 0;
                    }
                }
                else {
                    if (textAlign == "left" || textAlign == "start") {
                        x = this.get("paddingLeft", 0);
                    }
                    else if (textAlign == "right" || textAlign == "end") {
                        x = -this.get("paddingRight", 0);
                    }
                }
                text.set("x", x);
            }
            const background = this.get("background");
            if (background) {
                background.setPrivate("visible", text._display.textVisible);
            }
        }
        _maybeUpdateHTMLColor() {
            const htmlElement = this.getPrivate("htmlElement");
            if (htmlElement && this.get("fill")) {
                htmlElement.style.color = this.get("fill").toCSSHex();
                //@todo support gradient
            }
        }
        _setMaxDimentions() {
            const rotation = this.get("rotation");
            const vertical = rotation == 90 || rotation == 270 || rotation == -90;
            const text = this._text;
            const maxWidth = this.get("maxWidth", this.getPrivate("maxWidth", Infinity));
            if (isNumber(maxWidth)) {
                text.set(vertical ? "maxHeight" : "maxWidth", maxWidth - this.get("paddingLeft", 0) - this.get("paddingRight", 0));
            }
            else {
                text.set(vertical ? "maxHeight" : "maxWidth", undefined);
            }
            const maxHeight = this.get("maxHeight", this.getPrivate("maxHeight", Infinity));
            if (isNumber(maxHeight)) {
                text.set(vertical ? "maxWidth" : "maxHeight", maxHeight - this.get("paddingTop", 0) - this.get("paddingBottom", 0));
            }
            else {
                text.set(vertical ? "maxWidth" : "maxHeight", undefined);
            }
            this.root.events.once("frameended", () => {
                text.markDirtyBounds();
            });
        }
        _setDataItem(dataItem) {
            super._setDataItem(dataItem);
            this._markDirtyKey("text");
            const text = this._text;
            if (text.get("populateText")) {
                text.markDirtyText();
            }
            const html = this.get("html");
            if (html && html !== "") {
                this._updateHTMLContent();
            }
        }
        /**
         * Returns text with populated placeholders and formatting if `populateText` is
         * set to `true`.
         *
         * @return Populated text
         */
        getText() {
            return this._text._getText();
        }
        /**
         * Returns "aria-label" text with populated placeholders and formatting
         * if `populateText` is set to `true`.
         *
         * @return Populated text
         */
        getAccessibleText() {
            return this._text._getAccessibleText();
        }
    }
    Object.defineProperty(Label, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Label"
    });
    Object.defineProperty(Label, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Label.className])
    });

    /**
     * Draws a rectangle with a pointer.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     * @important
     */
    class PointedRectangle extends Graphics {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear) {
                this.markDirtyBounds();
                let w = this.width();
                let h = this.height();
                if (w > 0 && h > 0) {
                    let cr = this.get("cornerRadius", 8);
                    cr = fitToRange(cr, 0, Math.min(w / 2, h / 2));
                    let x = this.get("pointerX", 0);
                    let y = this.get("pointerY", 0);
                    let bwh = this.get("pointerBaseWidth", 15) / 2;
                    // corner coordinates
                    // top left
                    let xtl = 0;
                    let ytl = 0;
                    // top right
                    let xtr = w;
                    let ytr = 0;
                    // bottom right
                    let xbr = w;
                    let ybr = h;
                    // bottom left
                    let xbl = 0;
                    let ybl = h;
                    // find stem base side: http://$math.stackexchange.com/questions/274712/calculate-on-which-side-of-straign-line-is-dot-located
                    // d=(x−x1)(y2−y1)−(y−y1)(x2−x1)
                    let d1 = (x - xtl) * (ybr - ytl) - (y - ytl) * (xbr - xtl);
                    let d2 = (x - xbl) * (ytr - ybl) - (y - ybl) * (xtr - xbl);
                    const display = this._display;
                    // top
                    display.moveTo(cr, 0);
                    if (d1 > 0 && d2 > 0) {
                        let stemX = Math.round(fitToRange(x, cr + bwh, w - bwh - cr));
                        y = fitToRange(y, -Infinity, 0);
                        display.lineTo(stemX - bwh, 0);
                        display.lineTo(x, y);
                        display.lineTo(stemX + bwh, 0);
                    }
                    display.lineTo(w - cr, 0);
                    display.arcTo(w, 0, w, cr, cr);
                    // right
                    if (d1 > 0 && d2 < 0) {
                        let stemY = Math.round(fitToRange(y, cr + bwh, h - bwh - cr));
                        x = fitToRange(x, w, Infinity);
                        display.lineTo(w, cr);
                        display.lineTo(w, Math.max(stemY - bwh, cr));
                        display.lineTo(x, y);
                        display.lineTo(w, stemY + bwh);
                    }
                    display.lineTo(w, h - cr);
                    display.arcTo(w, h, w - cr, h, cr);
                    // bottom
                    if (d1 < 0 && d2 < 0) {
                        let stemX = Math.round(fitToRange(x, cr + bwh, w - bwh - cr));
                        y = fitToRange(y, h, Infinity);
                        display.lineTo(w - cr, h);
                        display.lineTo(stemX + bwh, h);
                        display.lineTo(x, y);
                        display.lineTo(stemX - bwh, h);
                    }
                    display.lineTo(cr, h);
                    display.arcTo(0, h, 0, h - cr, cr);
                    // left
                    if (d1 < 0 && d2 > 0) {
                        let stemY = Math.round(fitToRange(y, cr + bwh, h - cr - bwh));
                        x = fitToRange(x, -Infinity, 0);
                        display.lineTo(0, h - cr);
                        display.lineTo(0, stemY + bwh);
                        display.lineTo(x, y);
                        display.lineTo(0, Math.max(stemY - bwh, cr));
                    }
                    display.lineTo(0, cr);
                    display.arcTo(0, 0, cr, 0, cr);
                    display.closePath();
                }
            }
        }
    }
    Object.defineProperty(PointedRectangle, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PointedRectangle"
    });
    Object.defineProperty(PointedRectangle, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([PointedRectangle.className])
    });

    /**
     * Creates a tooltip.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info
     * @important
     */
    class Tooltip extends Container {
        constructor(root, settings, isReal, templates = []) {
            super(root, settings, isReal, templates);
            Object.defineProperty(this, "_fx", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_fy", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_label", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_fillDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_strokeDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_labelDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_w", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_h", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_keepHoverDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_htmlContentHovered", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["tooltip"]);
            super._afterNew();
            const background = this._setDefaultFn("background", () => {
                return PointedRectangle.new(this._root, {});
            });
            background.set("themeTags", ["tooltip", "background"]);
            this._label = this.children.push(Label.new(this._root, {}));
            this._disposers.push(this._label.events.on("boundschanged", () => {
                this._updateBackground();
            }));
            this._disposers.push(this.on("bounds", () => {
                this._updateBackground();
            }));
            this._updateTextColor();
            this._root.tooltipContainer.children.push(this);
            this.hide(0);
            this._disposers.push(this.label.onPrivate("htmlElement", (htmlElement) => {
                if (htmlElement) {
                    this._disposers.push(addEventListener(htmlElement, "pointerover", (_ev) => {
                        this._htmlContentHovered = true;
                    }));
                    this._disposers.push(addEventListener(htmlElement, "pointerout", (_ev) => {
                        this._htmlContentHovered = false;
                    }));
                }
            }));
            this.on("visible", (_ev) => {
                this._handleReaderAnnouncement();
            });
            this.label.events.on("dataitemchanged", (_ev) => {
                this._handleReaderAnnouncement();
            });
            this._root._tooltips.push(this);
        }
        _handleReaderAnnouncement() {
            if (this.get("readerAnnounce") && this.isVisibleDeep()) {
                this._root.readerAlert(this.label.getAccessibleText());
            }
        }
        /**
         * A [[Label]] element for the tooltip.
         *
         * @readonly
         * @return Label
         */
        get label() {
            return this._label;
        }
        /**
         * Permanently disposes the tooltip.
         */
        dispose() {
            super.dispose();
            remove(this._root._tooltips, this);
        }
        _updateChildren() {
            super._updateChildren();
            if (this.isDirty("pointerOrientation") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) {
                this.get("background")._markDirtyKey("width");
            }
            const labelText = this.get("labelText");
            if (labelText != null) {
                this.label.set("text", this.get("labelText"));
            }
            const labelHTML = this.get("labelHTML");
            if (labelHTML != null) {
                this.label.set("html", this.get("labelHTML"));
            }
            const labelAriaLabel = this.get("labelAriaLabel");
            if (labelAriaLabel != null) {
                this.label.set("ariaLabel", this.get("labelAriaLabel"));
            }
        }
        _changed() {
            super._changed();
            if (this.isDirty("pointTo") || this.isDirty("pointerOrientation")) {
                // can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)
                this._updateBackground();
            }
            if (this.isDirty("tooltipTarget")) {
                this.updateBackgroundColor();
            }
            if (this.isDirty("keepTargetHover")) {
                const keephover = this.get("keepTargetHover");
                if (keephover) {
                    const bg = this.get("background");
                    this._keepHoverDp = new MultiDisposer([
                        bg.events.on("pointerover", (_ev) => {
                            let target = this.get("tooltipTarget");
                            if (target) {
                                if (target.parent && target.parent.getPrivate("tooltipTarget") == target) {
                                    target = target.parent;
                                }
                                target.hover();
                            }
                        }),
                        bg.events.on("pointerout", (_ev) => {
                            let target = this.get("tooltipTarget");
                            if (target) {
                                if (target.parent && target.parent.getPrivate("tooltipTarget") == target) {
                                    target = target.parent;
                                }
                                if (!this._htmlContentHovered) {
                                    target.unhover();
                                }
                            }
                        })
                    ]);
                    this.label.onPrivate("htmlElement", (htmlElement) => {
                        if (this._keepHoverDp && htmlElement) {
                            this._keepHoverDp.disposers.push(addEventListener(htmlElement, "pointerleave", (ev) => {
                                const outEvent = this.root._renderer.getEvent(ev);
                                bg.events.dispatch("pointerout", {
                                    type: "pointerout",
                                    originalEvent: outEvent.event,
                                    point: outEvent.point,
                                    simulated: false,
                                    target: bg
                                });
                            }));
                        }
                    });
                }
                else {
                    if (this._keepHoverDp) {
                        this._keepHoverDp.dispose();
                        this._keepHoverDp = undefined;
                    }
                }
            }
        }
        _onShow() {
            super._onShow();
            this.updateBackgroundColor();
        }
        updateBackgroundColor() {
            let tooltipTarget = this.get("tooltipTarget");
            const background = this.get("background");
            let fill;
            let stroke;
            if (tooltipTarget && background) {
                fill = tooltipTarget.get("fill");
                stroke = tooltipTarget.get("stroke");
                if (fill == null) {
                    fill = stroke;
                }
                if (this.get("getFillFromSprite")) {
                    if (this._fillDp) {
                        this._fillDp.dispose();
                    }
                    if (fill != null) {
                        background.set("fill", fill);
                    }
                    this._fillDp = tooltipTarget.on("fill", (fill) => {
                        if (fill != null) {
                            background.set("fill", fill);
                            this._updateTextColor(fill);
                        }
                    });
                    this._disposers.push(this._fillDp);
                }
                if (this.get("getStrokeFromSprite")) {
                    if (this._strokeDp) {
                        this._strokeDp.dispose();
                    }
                    if (fill != null) {
                        background.set("stroke", fill);
                    }
                    this._strokeDp = tooltipTarget.on("fill", (fill) => {
                        if (fill != null) {
                            background.set("stroke", fill);
                        }
                    });
                    this._disposers.push(this._strokeDp);
                }
                if (this.get("getLabelFillFromSprite")) {
                    if (this._labelDp) {
                        this._labelDp.dispose();
                    }
                    if (fill != null) {
                        this.label.set("fill", fill);
                    }
                    this._labelDp = tooltipTarget.on("fill", (fill) => {
                        if (fill != null) {
                            this.label.set("fill", fill);
                        }
                    });
                    this._disposers.push(this._labelDp);
                }
            }
            this._updateTextColor(fill);
        }
        _updateTextColor(fill) {
            if (this.get("autoTextColor")) {
                if (fill == null) {
                    fill = this.get("background").get("fill");
                }
                if (fill == null) {
                    fill = this._root.interfaceColors.get("background");
                }
                if (fill instanceof Color) {
                    this.label.set("fill", Color.alternative(fill, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text")));
                }
            }
        }
        _setDataItem(dataItem) {
            super._setDataItem(dataItem);
            this.label._setDataItem(dataItem);
        }
        _updateBackground() {
            super.updateBackground();
            const parent = this._root.container;
            if (parent) {
                let cw = 0.5;
                let ch = 0.5;
                let centerX = this.get("centerX");
                if (centerX instanceof Percent) {
                    cw = centerX.value;
                }
                let centerY = this.get("centerY");
                if (centerY instanceof Percent) {
                    ch = centerY.value;
                }
                let parentW = parent.width();
                let parentH = parent.height();
                let tooltipContainer = this.parent;
                let xx = 0;
                let yy = 0;
                if (tooltipContainer) {
                    xx = tooltipContainer.x();
                    yy = tooltipContainer.y();
                    const layerMargin = tooltipContainer.get("layerMargin");
                    if (layerMargin) {
                        xx += layerMargin.left || 0;
                        yy += layerMargin.top || 0;
                        parentW += (layerMargin.left || 0) + (layerMargin.right || 0);
                        parentH += (layerMargin.top || 0) + (layerMargin.bottom || 0);
                    }
                }
                const bounds = this.get("bounds", { left: -xx, top: -yy, right: parentW - xx, bottom: parentH - yy });
                this._updateBounds();
                let w = this.width();
                let h = this.height();
                // use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens
                if (w === 0) {
                    w = this._w;
                }
                if (h === 0) {
                    h = this._h;
                }
                let pointTo = this.get("pointTo", { x: parentW / 2, y: parentH / 2 });
                let x = pointTo.x;
                let y = pointTo.y;
                let pointerOrientation = this.get("pointerOrientation");
                let background = this.get("background");
                let pointerLength = 0;
                let bgStrokeSizeY = 0;
                let bgStrokeSizeX = 0;
                if (background instanceof PointedRectangle) {
                    pointerLength = background.get("pointerLength", 0);
                    bgStrokeSizeY = background.get("strokeWidth", 0) / 2;
                    bgStrokeSizeX = bgStrokeSizeY;
                    background.set("width", w);
                    background.set("height", h);
                }
                let pointerX = 0;
                let pointerY = 0;
                let boundsW = bounds.right - bounds.left;
                let boundsH = bounds.bottom - bounds.top;
                // horizontal
                if (pointerOrientation == "horizontal" || pointerOrientation == "left" || pointerOrientation == "right") {
                    bgStrokeSizeY = 0;
                    if (pointerOrientation == "horizontal") {
                        if (x > bounds.left + boundsW / 2) {
                            x -= (w * (1 - cw) + pointerLength);
                            bgStrokeSizeX *= -1;
                        }
                        else {
                            x += (w * cw + pointerLength);
                        }
                    }
                    else if (pointerOrientation == "left") {
                        x += (w * (1 - cw) + pointerLength);
                    }
                    else {
                        x -= (w * cw + pointerLength);
                        bgStrokeSizeX *= -1;
                    }
                }
                // vertical pointer
                else {
                    bgStrokeSizeX = 0;
                    if (pointerOrientation == "vertical") {
                        if (y > bounds.top + h / 2 + pointerLength) {
                            y -= (h * (1 - ch) + pointerLength);
                        }
                        else {
                            y += (h * ch + pointerLength);
                            bgStrokeSizeY *= -1;
                        }
                    }
                    else if (pointerOrientation == "down") {
                        y -= (h * (1 - ch) + pointerLength);
                    }
                    else {
                        y += (h * ch + pointerLength);
                        bgStrokeSizeY *= -1;
                    }
                }
                x = fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;
                y = fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;
                pointerX = pointTo.x - x + w * cw + bgStrokeSizeX;
                pointerY = pointTo.y - y + h * ch - bgStrokeSizeY;
                this._fx = x;
                this._fy = y;
                const animationDuration = this.get("animationDuration", 0);
                if (animationDuration > 0 && this.get("visible") && this.get("opacity") > 0.1) {
                    const animationEasing = this.get("animationEasing");
                    this.animate({ key: "x", to: x, duration: animationDuration, easing: animationEasing });
                    this.animate({ key: "y", to: y, duration: animationDuration, easing: animationEasing });
                }
                else {
                    this.set("x", x);
                    this.set("y", y);
                }
                if (background instanceof PointedRectangle) {
                    background.set("pointerX", pointerX);
                    background.set("pointerY", pointerY);
                }
                if (w > 0) {
                    this._w = w;
                }
                if (h > 0) {
                    this._h = h;
                }
            }
        }
    }
    Object.defineProperty(Tooltip, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Tooltip"
    });
    Object.defineProperty(Tooltip, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Tooltip.className])
    });

    /**
     * Number formatter
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info
     * @important
     */
    class NumberFormatter extends Entity {
        _setDefaults() {
            // Defaults
            this._setDefault("negativeBase", 0);
            this._setDefault("numberFormat", "#,###.#####");
            this._setDefault("smallNumberThreshold", 1.00);
            const bns = "_big_number_suffix_";
            const sns = "_small_number_suffix_";
            const bs = "_byte_suffix_";
            this._setDefault("bigNumberPrefixes", [
                { "number": 1e+3, "suffix": this._t(bns + "3") },
                { "number": 1e+6, "suffix": this._t(bns + "6") },
                { "number": 1e+9, "suffix": this._t(bns + "9") },
                { "number": 1e+12, "suffix": this._t(bns + "12") },
                { "number": 1e+15, "suffix": this._t(bns + "15") },
                { "number": 1e+18, "suffix": this._t(bns + "18") },
                { "number": 1e+21, "suffix": this._t(bns + "21") },
                { "number": 1e+24, "suffix": this._t(bns + "24") }
            ]);
            this._setDefault("smallNumberPrefixes", [
                { "number": 1e-24, "suffix": this._t(sns + "24") },
                { "number": 1e-21, "suffix": this._t(sns + "21") },
                { "number": 1e-18, "suffix": this._t(sns + "18") },
                { "number": 1e-15, "suffix": this._t(sns + "15") },
                { "number": 1e-12, "suffix": this._t(sns + "12") },
                { "number": 1e-9, "suffix": this._t(sns + "9") },
                { "number": 1e-6, "suffix": this._t(sns + "6") },
                { "number": 1e-3, "suffix": this._t(sns + "3") }
            ]);
            this._setDefault("bytePrefixes", [
                { "number": 1, suffix: this._t(bs + "B") },
                { "number": 1024, suffix: this._t(bs + "KB") },
                { "number": 1048576, suffix: this._t(bs + "MB") },
                { "number": 1073741824, suffix: this._t(bs + "GB") },
                { "number": 1099511627776, suffix: this._t(bs + "TB") },
                { "number": 1125899906842624, suffix: this._t(bs + "PB") }
            ]);
            super._setDefaults();
        }
        _beforeChanged() {
            super._beforeChanged();
        }
        /**
         * Formats the number according to specific format.
         *
         * @param value   Value to format
         * @param format  Format to apply
         * @return Formatted number
         */
        format(value, format, precision) {
            // no format passed in or "Number"
            if (format == null || (isString(format) && format.toLowerCase() === "number")) {
                format = this.get("numberFormat", "");
            }
            // Init return value
            let formatted;
            // Cast to number just in case
            // TODO: maybe use better casting
            let source = Number(value);
            // Is it a built-in format or Intl.NumberFormatOptions
            if (isObject(format)) {
                try {
                    if (this.get("intlLocales")) {
                        return new Intl.NumberFormat(this.get("intlLocales"), format).format(source);
                    }
                    else {
                        return new Intl.NumberFormat(undefined, format).format(source);
                    }
                }
                catch (e) {
                    return "Invalid";
                }
            }
            else {
                // Clean format
                format = cleanFormat(format);
                // Get format info (it will also deal with parser caching)
                let info = this.parseFormat(format, this._root.language);
                // format and replace the number
                let details;
                if (source > this.get("negativeBase")) {
                    details = info.positive;
                }
                else if (source < this.get("negativeBase")) {
                    details = info.negative;
                }
                else {
                    details = info.zero;
                }
                // Adjust precision
                if (precision != null && !details.mod) {
                    details = copy$1(details);
                    details.decimals.active = source == 0 ? 0 : precision;
                }
                // Format
                formatted = details.template.split(PLACEHOLDER).join(this.applyFormat(source, details));
            }
            if (this.get("forceLTR") === true) {
                formatted = "‎" + formatted;
            }
            return formatted;
        }
        /**
         * Parses supplied format into structured object which can be used to format
         * the number.
         *
         * @param format Format string, i.e. "#,###.00"
         * @param language Language
         * @ignore
         */
        parseFormat(format, language) {
            // Check cache
            // TODO
            // let cached = this.getCache(format);
            // if (cached != null) {
            // 	return cached;
            // }
            const thousandSeparator = language.translateEmpty("_thousandSeparator");
            const decimalSeparator = language.translateEmpty("_decimalSeparator");
            // init format parse info holder
            let info = {
                "positive": {
                    "thousands": {
                        "active": -1,
                        "passive": -1,
                        "interval": -1,
                        "separator": thousandSeparator
                    },
                    "decimals": {
                        "active": -1,
                        "passive": -1,
                        "separator": decimalSeparator
                    },
                    "template": "",
                    "source": "",
                    "parsed": false
                },
                "negative": {
                    "thousands": {
                        "active": -1,
                        "passive": -1,
                        "interval": -1,
                        "separator": thousandSeparator
                    },
                    "decimals": {
                        "active": -1,
                        "passive": -1,
                        "separator": decimalSeparator
                    },
                    "template": "",
                    "source": "",
                    "parsed": false
                },
                "zero": {
                    "thousands": {
                        "active": -1,
                        "passive": -1,
                        "interval": -1,
                        "separator": thousandSeparator
                    },
                    "decimals": {
                        "active": -1,
                        "passive": -1,
                        "separator": decimalSeparator
                    },
                    "template": "",
                    "source": "",
                    "parsed": false
                }
            };
            // Escape double vertical bars (that mean display one vertical bar)
            format = format.replace("||", PLACEHOLDER2);
            // Split it up and deal with different formats
            let parts = format.split("|");
            info.positive.source = parts[0];
            if (typeof parts[2] === "undefined") {
                info.zero = info.positive;
            }
            else {
                info.zero.source = parts[2];
            }
            if (typeof parts[1] === "undefined") {
                info.negative = info.positive;
            }
            else {
                info.negative.source = parts[1];
            }
            // Parse each
            each(info, (_part, item) => {
                // Already parsed
                if (item.parsed) {
                    return;
                }
                // Check cached
                // TODO
                // if (typeof this.getCache(item.source) !== "undefined") {
                // 	info[part] = this.getCache(item.source);
                // 	return;
                // }
                // Begin parsing
                let partFormat = item.source;
                // Just "Number"?
                if (partFormat.toLowerCase() === "number") {
                    partFormat = this.get("numberFormat", "#,###.#####");
                }
                // Let TextFormatter split into chunks
                let chunks = TextFormatter.chunk(partFormat, true);
                for (let i = 0; i < chunks.length; i++) {
                    let chunk = chunks[i];
                    // replace back double vertical bar
                    chunk.text = chunk.text.replace(PLACEHOLDER2, "|");
                    if (chunk.type === "value") {
                        // Parse format
                        // Look for codes
                        let matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);
                        if (matches) {
                            if (matches === null || matches[0] === "") {
                                // no codes here - assume string
                                // nothing to do here
                                item.template += chunk.text;
                            }
                            else {
                                // look for the format modifiers at the end
                                let mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);
                                if (mods) {
                                    item.mod = mods[0].toLowerCase();
                                    item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;
                                }
                                // break the format up
                                let a = matches[0].split(".");
                                // Deal with thousands
                                if (a[0] === "") ;
                                else {
                                    // Counts
                                    item.thousands.active = (a[0].match(/0/g) || []).length;
                                    item.thousands.passive = (a[0].match(/\#/g) || []).length + item.thousands.active;
                                    // Separator interval
                                    let b = a[0].split(",");
                                    if (b.length === 1) ;
                                    else {
                                        // Use length fo the last chunk as thousands length
                                        item.thousands.interval = (b.pop() || "").length;
                                        if (item.thousands.interval === 0) {
                                            item.thousands.interval = -1;
                                        }
                                    }
                                }
                                // Deal with decimals
                                if (typeof (a[1]) === "undefined") ;
                                else {
                                    // Counts
                                    item.decimals.active = (a[1].match(/0/g) || []).length;
                                    item.decimals.passive = (a[1].match(/\#/g) || []).length + item.decimals.active;
                                }
                                // Add special code to template
                                item.template += chunk.text.split(matches[0]).join(PLACEHOLDER);
                            }
                        }
                    }
                    else {
                        // Quoted string - take it as it is
                        item.template += chunk.text;
                    }
                }
                // Apply style formatting
                //item.template = getTextFormatter().format(item.template, this.outputFormat);
                // Save cache
                // TODO
                //this.setCache(item.source, item);
                // Mark this as parsed
                item.parsed = true;
            });
            // Save cache (the whole thing)
            // TODO
            //this.setCache(format, info);
            return info;
        }
        /**
         * Applies parsed format to a numeric value.
         *
         * @param value    Value
         * @param details  Parsed format as returned by parseFormat()
         * @return Formatted number
         * @ignore
         */
        applyFormat(value, details) {
            // Use absolute values
            let negative = value < 0;
            value = Math.abs(value);
            // Recalculate according to modifier
            let prefix = "", suffix = "";
            let mods = details.mod ? details.mod.split("") : [];
            if (mods.indexOf("b") !== -1) {
                let a = this.applyPrefix(value, this.get("bytePrefixes"), mods.indexOf("!") !== -1);
                value = a[0];
                prefix = a[1];
                suffix = a[2];
                if (details.modSpacing) {
                    suffix = " " + suffix;
                }
            }
            else if (mods.indexOf("a") !== -1) {
                let a = this.applyPrefix(value, value < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), mods.indexOf("!") !== -1);
                value = a[0];
                prefix = a[1];
                suffix = a[2];
                if (details.modSpacing) {
                    suffix = " " + suffix;
                }
            }
            else if (mods.indexOf("p") !== -1) {
                let ol = Math.min(value.toString().length + 2, 21);
                //value *= 100;
                value = parseFloat(value.toPrecision(ol));
                prefix = this._root.language.translate("_percentPrefix");
                suffix = this._root.language.translate("_percentSuffix");
                if (prefix == "" && suffix == "") {
                    suffix = "%";
                }
            }
            else if (mods.indexOf("%") !== -1) {
                let ol = Math.min(value.toString().length + 2, 21);
                value *= 100;
                value = parseFloat(value.toPrecision(ol));
                suffix = "%";
            }
            else if (mods.indexOf("‰") !== -1) {
                let ol = Math.min(value.toString().length + 3, 21);
                value *= 1000;
                value = parseFloat(value.toPrecision(ol));
                suffix = "‰";
            }
            // Round to passive
            if (mods.indexOf("e") !== -1) {
                // convert the value to exponential
                let exp;
                if (details.decimals.passive >= 0) {
                    exp = value.toExponential(details.decimals.passive).split("e");
                }
                else {
                    exp = value.toExponential().split("e");
                }
                value = Number(exp[0]);
                suffix = "e" + exp[1];
                if (details.modSpacing) {
                    suffix = " " + suffix;
                }
            }
            else if (details.decimals.passive === 0) {
                value = Math.round(value);
            }
            else if (details.decimals.passive > 0) {
                const decimals = decimalPlaces(value);
                if (decimals > 0) {
                    const d = Math.pow(10, details.decimals.passive);
                    value = Math.round(parseFloat((value * d).toFixed(decimals))) / d;
                }
            }
            // Init return value
            let res = "";
            // Calc integer and decimal parts
            let a = numberToString(value).split(".");
            // Format integers
            let ints = a[0];
            // Pad integers to active length
            if (ints.length < details.thousands.active) {
                ints = Array(details.thousands.active - ints.length + 1).join("0") + ints;
            }
            // Insert thousands separators
            if (details.thousands.interval > 0) {
                let ip = [];
                let intsr = ints.split("").reverse().join("");
                for (let i = 0, len = ints.length; i <= len; i += details.thousands.interval) {
                    let c = intsr.substr(i, details.thousands.interval).split("").reverse().join("");
                    if (c !== "") {
                        ip.unshift(c);
                    }
                }
                ints = ip.join(details.thousands.separator);
            }
            // Add integers
            res += ints;
            // Add decimals
            if (a.length === 1) {
                a.push("");
            }
            let decs = a[1];
            // Fill zeros?
            if (decs.length < details.decimals.active) {
                decs += Array(details.decimals.active - decs.length + 1).join("0");
            }
            if (decs !== "") {
                res += details.decimals.separator + decs;
            }
            // Can't have empty return value
            if (res === "") {
                res = "0";
            }
            // Add minus sign back
            if (value !== 0 && negative && (mods.indexOf("s") === -1)) {
                res = "-" + res;
            }
            // Add suffixes/prefixes
            if (prefix) {
                res = prefix + res;
            }
            if (suffix) {
                res += suffix;
            }
            return res;
        }
        applyPrefix(value, prefixes, force = false) {
            let newvalue = value;
            let prefix = "";
            let suffix = "";
            let applied = false;
            let k = 1;
            for (let i = 0, len = prefixes.length; i < len; i++) {
                if (prefixes[i].number <= value) {
                    if (prefixes[i].number === 0) {
                        newvalue = 0;
                    }
                    else {
                        newvalue = value / prefixes[i].number;
                        k = prefixes[i].number;
                    }
                    prefix = prefixes[i].prefix;
                    suffix = prefixes[i].suffix;
                    applied = true;
                }
            }
            if (!applied && force && prefixes.length && value != 0) {
                // Prefix was not applied. Use the first prefix.
                newvalue = value / prefixes[0].number;
                prefix = prefixes[0].prefix;
                suffix = prefixes[0].suffix;
                applied = true;
            }
            if (applied) {
                newvalue = parseFloat(newvalue.toPrecision(Math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, "").length, 21)));
            }
            return [newvalue, prefix, suffix];
        }
        /**
         * Replaces brackets with temporary placeholders.
         *
         * @ignore Exclude from docs
         * @param text  Input text
         * @return Escaped text
         */
        escape(text) {
            return text.replace("||", PLACEHOLDER2);
        }
        /**
         * Replaces placeholders back to brackets.
         *
         * @ignore Exclude from docs
         * @param text  Escaped text
         * @return Unescaped text
         */
        unescape(text) {
            return text.replace(PLACEHOLDER2, "|");
        }
    }

    function parseDate(timezone, date) {
        let year = 0;
        let month = 0;
        let day = 1;
        let hour = 0;
        let minute = 0;
        let second = 0;
        let millisecond = 0;
        let weekday = 0;
        timezone.formatToParts(date).forEach((x) => {
            switch (x.type) {
                case "year":
                    year = +x.value;
                    break;
                case "month":
                    month = (+x.value) - 1;
                    break;
                case "day":
                    day = +x.value;
                    break;
                case "hour":
                    hour = +x.value;
                    break;
                case "minute":
                    minute = +x.value;
                    break;
                case "second":
                    second = +x.value;
                    break;
                case "fractionalSecond":
                    millisecond = +x.value;
                    break;
                case "weekday":
                    switch (x.value) {
                        case "Sun":
                            weekday = 0;
                            break;
                        case "Mon":
                            weekday = 1;
                            break;
                        case "Tue":
                            weekday = 2;
                            break;
                        case "Wed":
                            weekday = 3;
                            break;
                        case "Thu":
                            weekday = 4;
                            break;
                        case "Fri":
                            weekday = 5;
                            break;
                        case "Sat":
                            weekday = 6;
                            break;
                    }
            }
        });
        if (hour === 24) {
            hour = 0;
        }
        return { year, month, day, hour, minute, second, millisecond, weekday };
    }
    function toUTCDate(timezone, date) {
        const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
        return Date.UTC(year, month, day, hour, minute, second, millisecond);
    }
    class Timezone {
        constructor(timezone, isReal) {
            Object.defineProperty(this, "_utc", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_dtf", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            if (!isReal) {
                throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
            }
            this.name = timezone;
            this._utc = new Intl.DateTimeFormat("UTC", {
                hour12: false,
                timeZone: "UTC",
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                weekday: "short",
                fractionalSecondDigits: 3,
            });
            this._dtf = new Intl.DateTimeFormat("UTC", {
                hour12: false,
                timeZone: timezone,
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                weekday: "short",
                fractionalSecondDigits: 3,
            });
        }
        /**
         * Use this method to create an instance of this class.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
         * @param   timezone  IANA timezone
         * @return            Instantiated object
         */
        static new(timezone) {
            return (new this(timezone, true));
        }
        convertLocal(date) {
            const offset = this.offsetUTC(date);
            const userOffset = date.getTimezoneOffset();
            const output = new Date(date);
            output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
            const newUserOffset = output.getTimezoneOffset();
            if (userOffset != newUserOffset) {
                output.setUTCMinutes(output.getUTCMinutes() + newUserOffset - userOffset);
            }
            return output;
        }
        offsetUTC(date) {
            const utc = toUTCDate(this._utc, date);
            const dtf = toUTCDate(this._dtf, date);
            return (utc - dtf) / 60000;
        }
        parseDate(date) {
            return parseDate(this._dtf, date);
        }
    }

    /**
     * Date formatter class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info
     * @important
     */
    class DateFormatter extends Entity {
        _setDefaults() {
            // Defaults
            this._setDefault("capitalize", true);
            this._setDefault("dateFormat", "yyyy-MM-dd");
            super._setDefaults();
        }
        _beforeChanged() {
            super._beforeChanged();
        }
        /**
         * Formats a source `Date` object into string format
         * @param   source          inpout date
         * @param   format          Output format
         * @param   ignoreTimezone  Ignore timezone?
         * @return                  Formatted date
         */
        format(source, format, ignoreTimezone = false) {
            // Locale?
            // TODO
            // No format passed in or it's empty
            if (typeof format === "undefined" || format === "") {
                format = this.get("dateFormat", "yyyy-MM-dd");
            }
            // Init return value
            let formatted;
            // Cast?
            // TODO: decide if we need to cast
            let date = source;
            // Is it a built-in format or Intl.DateTimeFormat
            if (isObject(format)) {
                try {
                    const locales = this.get("intlLocales");
                    if (locales) {
                        return new Intl.DateTimeFormat(locales, format).format(date);
                    }
                    else {
                        return new Intl.DateTimeFormat(undefined, format).format(date);
                    }
                }
                catch (e) {
                    return "Invalid";
                }
            }
            // get format info (it will also deal with parser caching)
            let info = this.parseFormat(format);
            // Should we apply custom time zone?
            const timezone = this._root.timezone;
            if (timezone && !this._root.utc && !ignoreTimezone) {
                date = timezone.convertLocal(date);
            }
            // Check if it's a valid date
            if (!isNumber(date.getTime())) {
                // TODO translation
                //return this._t("Invalid date");
                return "Invalid date";
            }
            // Apply format
            formatted = this.applyFormat(date, info, ignoreTimezone);
            // Capitalize
            if (this.get("capitalize")) {
                formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());
            }
            // We're done
            return formatted;
        }
        /**
         * Applies format to Date.
         *
         * @param date      Date object
         * @param info      Parsed format information
         * @return Formatted date string
         */
        applyFormat(date, info, ignoreTimezone = false) {
            // Init return value
            let res = info.template;
            // Get values
            let fullYear, month, weekday, day, hours, minutes, seconds, milliseconds, timestamp = date.getTime();
            if (this._root.utc && !ignoreTimezone) {
                fullYear = date.getUTCFullYear();
                month = date.getUTCMonth();
                weekday = date.getUTCDay();
                day = date.getUTCDate();
                hours = date.getUTCHours();
                minutes = date.getUTCMinutes();
                seconds = date.getUTCSeconds();
                milliseconds = date.getUTCMilliseconds();
            }
            else {
                fullYear = date.getFullYear();
                month = date.getMonth();
                weekday = date.getDay();
                day = date.getDate();
                hours = date.getHours();
                minutes = date.getMinutes();
                seconds = date.getSeconds();
                milliseconds = date.getMilliseconds();
            }
            // Go through each part and format/replace it in template
            for (let i = 0, len = info.parts.length; i < len; i++) {
                let value = "";
                switch (info.parts[i]) {
                    case "G":
                        value = this._t(fullYear < 0
                            ? "_era_bc"
                            : "_era_ad");
                        break;
                    case "yyyy":
                        value = Math.abs(fullYear).toString();
                        if (fullYear < 0) {
                            value += this._t("_era_bc");
                        }
                        break;
                    case "yyy":
                    case "yy":
                    case "y":
                        value = Math.abs(fullYear).toString().substr(-info.parts[i].length);
                        if (fullYear < 0) {
                            value += this._t("_era_bc");
                        }
                        break;
                    case "YYYY":
                    case "YYY":
                    case "YY":
                    case "Y":
                        let year = getWeekYear(date, this._root.utc);
                        if (info.parts[i] == "YYYY") {
                            value = Math.abs(year).toString();
                        }
                        else {
                            value = Math.abs(year).toString().substr(-info.parts[i].length);
                        }
                        if (year < 0) {
                            value += this._t("_era_bc");
                        }
                        break;
                    case "u":
                        // @todo
                        break;
                    case "q":
                        value = "" + Math.ceil((date.getMonth() + 1) / 3);
                        break;
                    case "MMMMM":
                        value = this._t(this._getMonth(month)).substr(0, 1);
                        break;
                    case "MMMM":
                        value = this._t(this._getMonth(month));
                        break;
                    case "MMM":
                        value = this._t(this._getShortMonth(month));
                        break;
                    case "MM":
                        value = padString(month + 1, 2, "0");
                        break;
                    case "M":
                        value = (month + 1).toString();
                        break;
                    case "ww":
                        value = padString(getWeek(date, this._root.utc), 2, "0");
                        break;
                    case "w":
                        value = getWeek(date, this._root.utc).toString();
                        break;
                    case "W":
                        value = getMonthWeek(date, this._root.utc).toString();
                        break;
                    case "dd":
                        value = padString(day, 2, "0");
                        break;
                    case "d":
                        value = day.toString();
                        break;
                    case "DD":
                    case "DDD":
                        value = padString(getYearDay(date, this._root.utc).toString(), info.parts[i].length, "0");
                        break;
                    case "D":
                        value = getYearDay(date, this._root.utc).toString();
                        break;
                    case "F":
                        // @todo
                        break;
                    case "g":
                        // @todo
                        break;
                    case "t":
                        value = this._root.language.translateFunc("_dateOrd").call(this, day);
                        break;
                    case "E":
                        value = (weekday || 7).toString();
                        break;
                    case "EE":
                        value = padString((weekday || 7).toString(), 2, "0");
                        break;
                    case "EEE":
                    case "eee":
                        value = this._t(this._getShortWeekday(weekday));
                        break;
                    case "EEEE":
                    case "eeee":
                        value = this._t(this._getWeekday(weekday));
                        break;
                    case "EEEEE":
                    case "eeeee":
                        value = this._t(this._getShortWeekday(weekday)).substr(0, 1);
                        break;
                    case "e":
                    case "ee":
                        value = (weekday - (this._root.locale.firstDayOfWeek || 1) + 1).toString();
                        if (info.parts[i] == "ee") {
                            value = padString(value, 2, "0");
                        }
                        break;
                    case "a":
                        if (hours >= 12) {
                            value = this._t("PM");
                        }
                        else {
                            value = this._t("AM");
                        }
                        break;
                    case "aa":
                        if (hours >= 12) {
                            value = this._t("P.M.");
                        }
                        else {
                            value = this._t("A.M.");
                        }
                        break;
                    case "aaa":
                        if (hours >= 12) {
                            value = this._t("P");
                        }
                        else {
                            value = this._t("A");
                        }
                        break;
                    case "h":
                        value = get12Hours(hours).toString();
                        break;
                    case "hh":
                        value = padString(get12Hours(hours), 2, "0");
                        break;
                    case "H":
                        value = hours.toString();
                        break;
                    case "HH":
                        value = padString(hours, 2, "0");
                        break;
                    case "K":
                        value = get12Hours(hours, 0).toString();
                        break;
                    case "KK":
                        value = padString(get12Hours(hours, 0), 2, "0");
                        break;
                    case "k":
                        value = (hours + 1).toString();
                        break;
                    case "kk":
                        value = padString(hours + 1, 2, "0");
                        break;
                    case "m":
                        value = minutes.toString();
                        break;
                    case "mm":
                        value = padString(minutes, 2, "0");
                        break;
                    case "s":
                        value = seconds.toString();
                        break;
                    case "ss":
                        value = padString(seconds, 2, "0");
                        break;
                    case "S":
                    case "SS":
                    case "SSS":
                        value = Math.round((milliseconds / 1000) * Math.pow(10, info.parts[i].length)).toString();
                        break;
                    case "x":
                        value = timestamp.toString();
                        break;
                    case "n":
                    case "nn":
                    case "nnn":
                        value = padString(milliseconds, info.parts[i].length, "0");
                        break;
                    case "z":
                        value = getTimeZone(date, false, false, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined).replace(/[+-]+[0-9]+$/, "");
                        break;
                    case "zz":
                        value = getTimeZone(date, true, false, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined);
                        break;
                    case "zzz":
                        value = getTimeZone(date, false, true, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined).replace(/[+-]+[0-9]+$/, "");
                        break;
                    case "zzzz":
                        value = getTimeZone(date, true, true, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined);
                        break;
                    case "Z":
                    case "ZZ":
                        let timezone = this._root.utc ? "UTC" : this._root.timezone;
                        if (timezone instanceof Timezone) {
                            timezone = timezone.name;
                        }
                        const offset = timezone ? getTimezoneOffset(timezone) : date.getTimezoneOffset();
                        let tz = Math.abs(offset) / 60;
                        let tzh = Math.floor(tz);
                        let tzm = tz * 60 - tzh * 60;
                        if (this._root.utc) {
                            tzh = 0;
                            tzm = 0;
                        }
                        if (info.parts[i] == "Z") {
                            value = "GMT";
                            value += offset > 0 ? "-" : "+";
                            value += padString(tzh, 2) + ":" + padString(tzm, 2);
                        }
                        else {
                            value = offset > 0 ? "-" : "+";
                            value += padString(tzh, 2) + padString(tzm, 2);
                        }
                        break;
                    case "i":
                        value = date.toISOString();
                        break;
                    case "I":
                        value = date.toUTCString();
                        break;
                }
                res = res.replace(PLACEHOLDER, value);
            }
            return res;
        }
        /**
         * Parses format into structured infromation.
         *
         * @param format Format template
         */
        parseFormat(format) {
            // Check cache
            // TODO: implement caching of the parsed format
            // Init format parse info holder
            let info = {
                "template": "",
                "parts": []
            };
            // Let TextFormatter split into chunks
            let chunks = TextFormatter.chunk(format, true);
            for (let i = 0; i < chunks.length; i++) {
                let chunk = chunks[i];
                if (chunk.type === "value") {
                    // Just "Date"?
                    if (chunk.text.match(/^date$/i)) {
                        let dateFormat = this.get("dateFormat", "yyyy-MM-dd");
                        if (!isString(dateFormat)) {
                            dateFormat = "yyyy-MM-dd";
                        }
                        chunk.text = dateFormat;
                    }
                    // Find all possible parts
                    let matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
                    // Found?
                    if (matches) {
                        // Populate template
                        for (let x = 0; x < matches.length; x++) {
                            info.parts.push(matches[x]);
                            chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);
                        }
                    }
                }
                // Apply to template
                info.template += chunk.text;
            }
            // Save cache
            // TODO
            return info;
        }
        _months() {
            return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        }
        _getMonth(index) {
            return this._months()[index];
        }
        _shortMonths() {
            return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        }
        _getShortMonth(index) {
            return this._shortMonths()[index];
        }
        _weekdays() {
            return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        }
        _getWeekday(index) {
            return this._weekdays()[index];
        }
        _shortWeekdays() {
            return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        }
        _getShortWeekday(index) {
            return this._shortWeekdays()[index];
        }
        parse(source, format) {
            // Is it already a Date
            if (source instanceof Date) {
                return source;
            }
            // Is it a numeric timestamp
            if (isNumber(source)) {
                return new Date(source);
            }
            // Are we parsing a timestamp?
            if (format == "x") {
                return new Date(parseInt(source));
            }
            // No? Let's check if it's string, and try converting to it if nec
            if (!isString(source)) {
                source = source.toString();
            }
            // Init return value
            let res;
            // Init RegEx for parsing
            let reg = "";
            // Clean format
            format = cleanFormat(format);
            // Clip format to length of the source string
            format = format.substr(0, source.length);
            // Parse format
            let info = this.parseFormat(format);
            // Init parsed items holder
            let parsedIndexes = {
                "year": -1,
                "year3": -1,
                "year2": -1,
                "year1": -1,
                "month": -1,
                "monthShort": -1,
                "monthLong": -1,
                "weekdayShort": -1,
                "weekdayLong": -1,
                "day": -1,
                "yearDay": -1,
                "week": -1,
                "hourBase0": -1,
                "hour12Base0": -1,
                "hourBase1": -1,
                "hour12Base1": -1,
                "minute": -1,
                "second": -1,
                "millisecond": -1,
                "millisecondDigits": -1,
                "am": -1,
                "zone": -1,
                "timestamp": -1,
                "iso": -1
            };
            // Init values
            let resValues = {
                "year": 1970,
                "month": 0,
                "day": 1,
                "hour": 0,
                "minute": 0,
                "second": 0,
                "millisecond": 0,
                "timestamp": null,
                "offset": 0,
                "utc": this._root.utc
            };
            // Index adjuster
            let indexAdjust = 0;
            let index = 0;
            // Iterate through all of the parts
            for (let i = 0; i < info.parts.length; i++) {
                // Set current match index
                index = i + indexAdjust + 1;
                switch (info.parts[i]) {
                    case "yyyy":
                    case "YYYY":
                        reg += "([0-9]{4})";
                        parsedIndexes.year = index;
                        break;
                    case "yyy":
                    case "YYY":
                        reg += "([0-9]{3})";
                        parsedIndexes.year3 = index;
                        break;
                    case "yy":
                    case "YY":
                        reg += "([0-9]{2})";
                        parsedIndexes.year2 = index;
                        break;
                    case "y":
                    case "Y":
                        reg += "([0-9]{1})";
                        parsedIndexes.year1 = index;
                        break;
                    case "MMMM":
                        reg += "(" + this.getStringList(this._months()).join("|") + ")";
                        parsedIndexes.monthLong = index;
                        break;
                    case "MMM":
                        reg += "(" + this.getStringList(this._shortMonths()).join("|") + ")";
                        parsedIndexes.monthShort = index;
                        break;
                    case "MM":
                    case "M":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.month = index;
                        break;
                    case "ww":
                    case "w":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.week = index;
                        break;
                    case "dd":
                    case "d":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.day = index;
                        break;
                    case "DDD":
                    case "DD":
                    case "D":
                        reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                        parsedIndexes.yearDay = index;
                        break;
                    case "dddd":
                        reg += "(" + this.getStringList(this._weekdays()).join("|") + ")";
                        parsedIndexes.weekdayLong = index;
                        break;
                    case "ddd":
                        reg += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")";
                        parsedIndexes.weekdayShort = index;
                        break;
                    case "aaa":
                    case "aa":
                    case "a":
                        // TODO: fix (escape regex)
                        reg += "(" + this.getStringList(["AM", "PM", "A\.M\.", "P\.M\.", "A", "P"]).join("|") + ")";
                        parsedIndexes.am = index;
                        break;
                    case "hh":
                    case "h":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.hour12Base1 = index;
                        break;
                    case "HH":
                    case "H":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.hourBase0 = index;
                        break;
                    case "KK":
                    case "K":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.hour12Base0 = index;
                        break;
                    case "kk":
                    case "k":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.hourBase1 = index;
                        break;
                    case "mm":
                    case "m":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.minute = index;
                        break;
                    case "ss":
                    case "s":
                        reg += "([0-9]{2}|[0-9]{1})";
                        parsedIndexes.second = index;
                        break;
                    case "SSS":
                    case "SS":
                    case "S":
                        reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                        parsedIndexes.millisecond = index;
                        parsedIndexes.millisecondDigits = info.parts[i].length;
                        break;
                    case "nnn":
                    case "nn":
                    case "n":
                        reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                        parsedIndexes.millisecond = index;
                        break;
                    case "x":
                        reg += "([0-9]{1,})";
                        parsedIndexes.timestamp = index;
                        break;
                    case "Z":
                        reg += "GMT([-+]+[0-9]{2}:[0-9]{2})";
                        parsedIndexes.zone = index;
                        break;
                    case "ZZ":
                        reg += "([\\-+]+[0-9]{2}[0-9]{2})";
                        parsedIndexes.zone = index;
                        break;
                    case "i":
                        reg += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\.?([0-9]{0,3})([zZ]|[+\\-][0-9]{2}:?[0-9]{2}|$)";
                        parsedIndexes.iso = index;
                        indexAdjust += 7;
                        break;
                    case "G":
                    case "YYYY":
                    case "YYY":
                    case "YY":
                    case "Y":
                    case "MMMMM":
                    case "W":
                    case "EEEEE":
                    case "EEEE":
                    case "EEE":
                    case "EE":
                    case "E":
                    case "eeeee":
                    case "eeee":
                    case "eee":
                    case "ee":
                    case "e":
                    case "zzzz":
                    case "zzz":
                    case "zz":
                    case "z":
                    case "t":
                        // Ignore
                        indexAdjust--;
                        break;
                }
                reg += "[^0-9]*";
            }
            // Try matching
            let regex = new RegExp(reg);
            let matches = source.match(regex);
            if (matches) {
                // Populate the date object
                // Full year
                if (parsedIndexes.year > -1) {
                    resValues.year = parseInt(matches[parsedIndexes.year]);
                }
                // 3-digit year
                if (parsedIndexes.year3 > -1) {
                    let val = parseInt(matches[parsedIndexes.year3]);
                    val += 1000;
                    resValues.year = val;
                }
                // 2-digit year
                if (parsedIndexes.year2 > -1) {
                    let val = parseInt(matches[parsedIndexes.year2]);
                    if (val > 50) {
                        val += 1000;
                    }
                    else {
                        val += 2000;
                    }
                    resValues.year = val;
                }
                // 1-digit year
                if (parsedIndexes.year1 > -1) {
                    let val = parseInt(matches[parsedIndexes.year1]);
                    val = Math.floor((new Date().getFullYear()) / 10) * 10 + val;
                    resValues.year = val;
                }
                // Full month
                if (parsedIndexes.monthLong > -1) {
                    resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);
                }
                // Short month
                if (parsedIndexes.monthShort > -1) {
                    resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);
                }
                // Numeric month
                if (parsedIndexes.month > -1) {
                    resValues.month = parseInt(matches[parsedIndexes.month]) - 1;
                }
                // Weekday
                // @todo
                // Week
                if ((parsedIndexes.week > -1) && (parsedIndexes.day === -1)) {
                    // We parse weeks ONLY if day is not explicitly set
                    // TODO: this needs work
                    // (but maybe later - I can hardly imagine anyone passing their dates in weeks)
                    resValues.month = 0;
                    resValues.day = getDayFromWeek(parseInt(matches[parsedIndexes.week]), resValues.year, 1, this._root.utc);
                }
                // Day
                if (parsedIndexes.day > -1) {
                    resValues.day = parseInt(matches[parsedIndexes.day]);
                }
                // Year day
                if (parsedIndexes.yearDay > -1) {
                    resValues.month = 0;
                    resValues.day = parseInt(matches[parsedIndexes.yearDay]);
                }
                // 24 Hour (0-23)
                if (parsedIndexes.hourBase0 > -1) {
                    resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);
                }
                // 24 Hour (1-24)
                if (parsedIndexes.hourBase1 > -1) {
                    resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;
                }
                // 12 Hour (0-11)
                if (parsedIndexes.hour12Base0 > -1) {
                    let val = parseInt(matches[parsedIndexes.hour12Base0]);
                    if (val == 11) {
                        val = 0;
                    }
                    if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                        val += 12;
                    }
                    resValues.hour = val;
                }
                // 12 Hour (1-12)
                if (parsedIndexes.hour12Base1 > -1) {
                    let val = parseInt(matches[parsedIndexes.hour12Base1]);
                    if (val == 12) {
                        val = 0;
                    }
                    if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                        val += 12;
                    }
                    resValues.hour = val;
                }
                // Minute
                if (parsedIndexes.minute > -1) {
                    resValues.minute = parseInt(matches[parsedIndexes.minute]);
                }
                // Second
                if (parsedIndexes.second > -1) {
                    resValues.second = parseInt(matches[parsedIndexes.second]);
                }
                // Millisecond
                if (parsedIndexes.millisecond > -1) {
                    let val = parseInt(matches[parsedIndexes.millisecond]);
                    if (parsedIndexes.millisecondDigits == 2) {
                        val *= 10;
                    }
                    else if (parsedIndexes.millisecondDigits == 1) {
                        val *= 100;
                    }
                    resValues.millisecond = val;
                }
                // Timestamp
                if (parsedIndexes.timestamp > -1) {
                    resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);
                    const ts = new Date(resValues.timestamp);
                    resValues.year = ts.getUTCFullYear();
                    resValues.month = ts.getUTCMonth();
                    resValues.day = ts.getUTCDate();
                    resValues.hour = ts.getUTCHours();
                    resValues.minute = ts.getUTCMinutes();
                    resValues.second = ts.getUTCSeconds();
                    resValues.millisecond = ts.getUTCMilliseconds();
                }
                // Adjust time zone
                if (parsedIndexes.zone > -1) {
                    resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.zone]);
                }
                // ISO
                if (parsedIndexes.iso > -1) {
                    resValues.year = toNumber(matches[parsedIndexes.iso + 0]);
                    resValues.month = toNumber(matches[parsedIndexes.iso + 1]) - 1;
                    resValues.day = toNumber(matches[parsedIndexes.iso + 2]);
                    resValues.hour = toNumber(matches[parsedIndexes.iso + 3]);
                    resValues.minute = toNumber(matches[parsedIndexes.iso + 4]);
                    resValues.second = toNumber(matches[parsedIndexes.iso + 5]);
                    resValues.millisecond = toNumber(matches[parsedIndexes.iso + 6]);
                    if (matches[parsedIndexes.iso + 7] == "Z" || matches[parsedIndexes.iso + 7] == "z") {
                        resValues.utc = true;
                    }
                    else if (matches[parsedIndexes.iso + 7] != "") {
                        resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.iso + 7]);
                    }
                }
                // Create Date object
                if (resValues.utc) {
                    res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));
                }
                else {
                    res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute + resValues.offset, resValues.second, resValues.millisecond);
                }
            }
            else {
                // Didn't match anything
                // Let's try dropping it into Date constructor and hope for the best
                res = new Date(source);
            }
            return res;
        }
        resolveTimezoneOffset(date, zone) {
            let value = zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/);
            if (value) {
                let match = zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/);
                let dir = match[1];
                let hour = match[2];
                let minute = match[3];
                let offset = parseInt(hour) * 60 + parseInt(minute);
                // Adjust offset
                // Making it negative does not seem to make sense, but it's right
                // because of how JavaScript calculates GMT offsets
                if (dir == "+") {
                    offset *= -1;
                }
                // Check the difference in offset
                let originalOffset = (date || new Date()).getTimezoneOffset();
                let diff = offset - originalOffset;
                return diff;
            }
            return 0;
        }
        /**
         * Resolves month name (i.e. "December") into a month number (11).
         *
         * @param value  Month name
         * @return Month number
         */
        resolveMonth(value) {
            // Let's try English first
            let month = this._months().indexOf(value);
            if (month > -1) {
                return month;
            }
            // Try the translation
            if (!this._root.language.isDefault()) {
                month = this._root.language.translateAll(this._months()).indexOf(value);
                if (month > -1) {
                    return month;
                }
            }
            return 0;
        }
        /**
         * Resolves short month name (i.e. "Dec") into a month number.
         *
         * @param value  Short month name
         * @return Month number
         */
        resolveShortMonth(value) {
            // Let's try English first
            let month = this._shortMonths().indexOf(value);
            if (month > -1) {
                return month;
            }
            // Maybe long month (workaround for May)
            month = this._months().indexOf(value);
            if (month > -1) {
                return month;
            }
            // Try the translation
            if (this._root.language && !this._root.language.isDefault()) {
                month = this._root.language.translateAll(this._shortMonths()).indexOf(value);
                if (month > -1) {
                    return month;
                }
            }
            return 0;
        }
        /**
         * Checks if passed in string represents AM/PM notation in many of its
         * versions.
         *
         * @param value  Source string
         * @return Is it AM/PM?
         */
        isAm(value) {
            let list = this.getStringList(["AM", "A.M.", "A"]);
            return list.indexOf(value.toUpperCase()) > -1;
        }
        /**
         * Translates list of strings.
         *
         * @param list  Source strings
         * @return Translated strings
         */
        getStringList(list) {
            let res = [];
            for (let i = 0; i < list.length; i++) {
                // translate?
                if (this._root.language) {
                    res.push(escapeForRgex(this._t(list[i])));
                }
                else {
                    res.push(escapeForRgex(list[i]));
                }
            }
            return res;
        }
    }

    /**
     * A class used to format numberic values as time duration.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/} for more info
     */
    class DurationFormatter extends Entity {
        constructor() {
            super(...arguments);
            /**
             * Collection of aliases for units.
             */
            Object.defineProperty(this, "_unitAliases", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {
                    "Y": "y",
                    "D": "d",
                    "H": "h",
                    "K": "h",
                    "k": "h",
                    "n": "S"
                }
            });
        }
        _setDefaults() {
            const dmillisecond = "_duration_millisecond";
            const dsecond = "_duration_second";
            const dminute = "_duration_minute";
            const dhour = "_duration_hour";
            const dday = "_duration_day";
            const dweek = "_duration_week";
            const dmonth = "_duration_month";
            const dyear = "_duration_year";
            const asecond = "_second";
            const aminute = "_minute";
            const ahour = "_hour";
            const aday = "_day";
            const aweek = "_week";
            const amonth = "_week";
            const ayear = "_year";
            // Defaults
            this._setDefault("negativeBase", 0);
            this._setDefault("baseUnit", "second");
            this._setDefault("durationFormats", {
                "millisecond": {
                    "millisecond": this._t(dmillisecond),
                    "second": this._t((dmillisecond + asecond)),
                    "minute": this._t((dmillisecond + aminute)),
                    "hour": this._t((dmillisecond + ahour)),
                    "day": this._t((dmillisecond + aday)),
                    "week": this._t((dmillisecond + aweek)),
                    "month": this._t((dmillisecond + amonth)),
                    "year": this._t((dmillisecond + ayear))
                },
                "second": {
                    "second": this._t((dsecond)),
                    "minute": this._t((dsecond + aminute)),
                    "hour": this._t((dsecond + ahour)),
                    "day": this._t((dsecond + aday)),
                    "week": this._t((dsecond + aweek)),
                    "month": this._t((dsecond + amonth)),
                    "year": this._t((dsecond + ayear))
                },
                "minute": {
                    "minute": this._t((dminute)),
                    "hour": this._t((dminute + ahour)),
                    "day": this._t((dminute + aday)),
                    "week": this._t((dminute + aweek)),
                    "month": this._t((dminute + amonth)),
                    "year": this._t((dminute + ayear))
                },
                "hour": {
                    "hour": this._t((dhour)),
                    "day": this._t((dhour + aday)),
                    "week": this._t((dhour + aweek)),
                    "month": this._t((dhour + amonth)),
                    "year": this._t((dhour + ayear))
                },
                "day": {
                    "day": this._t((dday)),
                    "week": this._t((dday + aweek)),
                    "month": this._t((dday + amonth)),
                    "year": this._t((dday + ayear))
                },
                "week": {
                    "week": this._t((dweek)),
                    "month": this._t((dweek + amonth)),
                    "year": this._t((dweek + ayear))
                },
                "month": {
                    "month": this._t((dmonth)),
                    "year": this._t((dmonth + ayear))
                },
                "year": {
                    "year": this._t(dyear)
                }
            });
            super._setDefaults();
        }
        _beforeChanged() {
            super._beforeChanged();
        }
        /**
         * Formats the number as duration.
         *
         * For example `1000` (base unit seconds) would be converted to `16:40` as in
         * 16 minutes and 40 seconds.
         *
         * @param value   Value to format
         * @param format  Format to apply
         * @param base    Override base unit
         * @return Formatted number
         */
        format(value, format, base) {
            // no base unit?
            let baseUnit = base || this.get("baseUnit");
            // no format passed in or empty
            if (typeof format === "undefined" || format === "") {
                if (this.get("durationFormat") != null) {
                    format = this.get("durationFormat");
                }
                else {
                    format = this.getFormat(toNumber(value), undefined, baseUnit);
                }
            }
            // Clean format
            format = cleanFormat(format);
            // get format info (it will also deal with parser caching)
            let info = this.parseFormat(format, baseUnit);
            // cast to number just in case
            // TODO: maybe use better casting
            let source = Number(value);
            // format and replace the number
            let details;
            if (source > this.get("negativeBase")) {
                details = info.positive;
            }
            else if (source < this.get("negativeBase")) {
                details = info.negative;
            }
            else {
                details = info.zero;
            }
            // Format
            let formatted = this.applyFormat(source, details);
            // Apply color?
            if (details.color !== "") {
                formatted = "[" + details.color + "]" + formatted + "[/]";
            }
            return formatted;
        }
        /**
         * Parses supplied format into structured object which can be used to format
         * the number.
         *
         * @param format  Format string, i.e. "#,###.00"
         * @param base    Override base unit
         * @return Parsed information
         */
        parseFormat(format, base) {
            // Check cache
            // TODO
            // let cached = this.getCache(format);
            // if (cached != null) {
            // 	return cached;
            // }
            // no base unit?
            let baseUnit = base || this.get("baseUnit");
            // Initialize duration parsing info
            let info = {
                "positive": {
                    "color": "",
                    "template": "",
                    "parts": [],
                    "source": "",
                    "baseUnit": baseUnit,
                    "parsed": false,
                    "absolute": false
                },
                "negative": {
                    "color": "",
                    "template": "",
                    "parts": [],
                    "source": "",
                    "baseUnit": baseUnit,
                    "parsed": false,
                    "absolute": false
                },
                "zero": {
                    "color": "",
                    "template": "",
                    "parts": [],
                    "source": "",
                    "baseUnit": baseUnit,
                    "parsed": false,
                    "absolute": false
                }
            };
            // Escape double vertical bars (that mean display one vertical bar)
            format = format.replace("||", PLACEHOLDER2);
            // Split it up and deal with different formats
            let parts = format.split("|");
            info.positive.source = parts[0];
            if (typeof parts[2] === "undefined") {
                info.zero = info.positive;
            }
            else {
                info.zero.source = parts[2];
            }
            if (typeof parts[1] === "undefined") {
                info.negative = info.positive;
            }
            else {
                info.negative.source = parts[1];
            }
            // Parse each
            each(info, (_part, item) => {
                // Already parsed
                if (item.parsed) {
                    return;
                }
                // Check cached
                // TODO
                // if (typeof this.getCache(item.source) !== "undefined") {
                // 	info[part] = this.getCache(item.source);
                // 	return;
                // }
                // Begin parsing
                let partFormat = item.source;
                // Check for [] directives
                let dirs = [];
                dirs = item.source.match(/^\[([^\]]*)\]/);
                if (dirs && dirs.length && dirs[0] !== "") {
                    partFormat = item.source.substr(dirs[0].length);
                    item.color = dirs[1];
                }
                // Let TextFormatter split into chunks
                let chunks = TextFormatter.chunk(partFormat, true);
                for (let i = 0; i < chunks.length; i++) {
                    let chunk = chunks[i];
                    // replace back double vertical bar
                    chunk.text = chunk.text.replace(PLACEHOLDER2, "|");
                    if (chunk.type === "value") {
                        // Just "Duration"?
                        // if (chunk.text.toLowerCase() === "duration") {
                        // 	chunk.text = durationFormat;
                        // }
                        // Check for "a" (absolute) modifier
                        if (chunk.text.match(/[yYMdDwhHKkmsSn]+a/)) {
                            item.absolute = true;
                            chunk.text = chunk.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1");
                        }
                        // Find all possible parts
                        let matches = chunk.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
                        if (matches) {
                            // Populate template
                            for (let x = 0; x < matches.length; x++) {
                                // Is it an alias?
                                if (matches[x] == null) {
                                    matches[x] = this._unitAliases[matches[x]];
                                }
                                item.parts.push(matches[x]);
                                chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);
                            }
                        }
                    }
                    // Apply to template
                    item.template += chunk.text;
                }
                // Apply style formatting
                //item.template = TextFormatter.format(item.template, this.outputFormat);
                // Save cache
                // TODO
                //this.setCache(item.source, item);
                // Mark this as parsed
                item.parsed = true;
            });
            // Save cache (the whole thing)
            // TODO
            //this.setCache(format, info);
            return info;
        }
        /**
         * Applies parsed format to a numeric value.
         *
         * @param value    Value
         * @param details  Parsed format as returned by {parseFormat}
         * @return Formatted duration
         */
        applyFormat(value, details) {
            // Use absolute values
            let negative = !details.absolute && (value < this.get("negativeBase"));
            value = Math.abs(value);
            // Recalculate to milliseconds
            let tstamp = this.toTimeStamp(value, details.baseUnit);
            // Init return value
            let res = details.template;
            // Iterate through duration parts
            for (let i = 0, len = details.parts.length; i < len; i++) {
                // Gather the part
                let part = details.parts[i];
                let unit = this._toTimeUnit(part.substr(0, 1));
                let digits = part.length;
                // Calculate current unit value
                let ints;
                const unitValue = this._getUnitValue(unit);
                if (i < (len - 1)) {
                    ints = Math.floor(tstamp / unitValue);
                }
                else {
                    ints = Math.round(tstamp / unitValue);
                }
                res = res.replace(PLACEHOLDER, padString(ints, digits, "0"));
                // Reduce timestamp
                tstamp -= ints * unitValue;
            }
            // Reapply negative sign
            if (negative) {
                res = "-" + res;
            }
            return res;
        }
        /**
         * Converts numeric value to timestamp in milliseconds.
         *
         * @param value     A source value
         * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"
         * @return Value representation as a timestamp in milliseconds
         */
        toTimeStamp(value, baseUnit) {
            return value * this._getUnitValue(baseUnit);
        }
        _toTimeUnit(code) {
            switch (code) {
                case "S":
                    return "millisecond";
                case "s":
                    return "second";
                case "m":
                    return "minute";
                case "h":
                    return "hour";
                case "d":
                    return "day";
                case "w":
                    return "week";
                case "M":
                    return "month";
                case "y":
                    return "year";
            }
        }
        /**
         * Returns appropriate default format for the value.
         *
         * If `maxValue` is sepcified, it will use that value to determine the time
         * unit for the format.
         *
         * For example if your `baseUnit` is `"second"` and you pass in `10`, you
         * will get `"10"`.
         *
         * However, you might want it to be formatted in the context of bigger scale,
         * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all
         * values, including small ones will use format with minutes, e.g.:
         * `00:10`, `00:50`, `12: 30`, etc.
         *
         * @param value     Value to format
         * @param maxValue  Maximum value to be used to determine format
         * @param baseUnit  Base unit of the value
         * @return Format
         */
        getFormat(value, maxValue, baseUnit) {
            // Is format override set?
            if (this.get("durationFormat") != null) {
                return this.get("durationFormat");
            }
            // Get base unit
            if (!baseUnit) {
                baseUnit = this.get("baseUnit");
            }
            if (maxValue != null && value != maxValue) {
                value = Math.abs(value);
                maxValue = Math.abs(maxValue);
                let maxUnit = this.getValueUnit(Math.max(value, maxValue), baseUnit);
                return this.get("durationFormats")[baseUnit][maxUnit];
            }
            else {
                let unit = this.getValueUnit(value, baseUnit);
                return this.get("durationFormats")[baseUnit][unit];
            }
        }
        /**
         * Returns value's closest denominator time unit, e.g 100 seconds is
         * `"minute"`, while 59 seconds would still be `second`.
         *
         * @param value     Source duration value
         * @param baseUnit  Base unit
         * @return Denominator
         */
        getValueUnit(value, baseUnit) {
            // Get base unit
            if (!baseUnit) {
                baseUnit = this.get("baseUnit");
            }
            // Convert to milliseconds
            let currentUnit;
            let ms = this.getMilliseconds(value, baseUnit);
            eachContinue(this._getUnitValues(), (key, val) => {
                if (key == baseUnit || currentUnit) {
                    let num = ms / val;
                    if (num <= 1) {
                        if (!currentUnit) {
                            currentUnit = key;
                        }
                        return false;
                    }
                    currentUnit = key;
                }
                return true;
            });
            return currentUnit;
        }
        /**
         * Converts value to milliseconds according to `baseUnit`.
         *
         * @param value     Source duration value
         * @param baseUnit  Base unit
         * @return Value in milliseconds
         */
        getMilliseconds(value, baseUnit) {
            // Get base unit
            if (!baseUnit) {
                baseUnit = this.get("baseUnit");
            }
            return value * this._getUnitValue(baseUnit);
        }
        _getUnitValue(timeUnit) {
            return this._getUnitValues()[timeUnit];
        }
        _getUnitValues() {
            return {
                "millisecond": 1,
                "second": 1000,
                "minute": 60000,
                "hour": 3600000,
                "day": 86400000,
                "week": 604800000,
                "month": 2592000000,
                "year": 31536000000,
            };
        }
    }

    /**
     * amCharts 5 locale
     *
     * Locale: en
     * Language: International English
     * Author: Martynas Majeris
     *
     * Follow instructions in [on this page](https://www.amcharts.com/docs/v5/tutorials/creating-translations/) to make corrections or add new translations.
     *
     * ---
     * Edit but leave the header section above this line. You can remove any
     * subsequent comment sections.
     * ---
     *
     * Use this file as a template to create translations. Leave the key part in
     * English intact. Fill the value with a translation.
     *
     * Empty string means no translation, so default "International English"
     * will be used.
     *
     * If you need the translation to literally be an empty string, use `null`
     * instead.
     *
     * IMPORTANT:
     * When translating make good effort to keep the translation length
     * at least the same chartcount as the English, especially for short prompts.
     *
     * Having significantly longer prompts may distort the actual charts.
     *
     * NOTE:
     * Some prompts - like months or weekdays - come in two versions: full and
     * shortened.
     *
     * If there's no official shortened version of these in your language, and it
     * would not be possible to invent such short versions that don't seem weird
     * to native speakers of that language, fill those with the same as full
     * version.
     *
     * PLACEHOLDERS:
     * Some prompts have placeholders like "%1". Those will be replaced by actual
     * values during translation and should be retained in the translated prompts.
     *
     * Placeholder positions may be changed to better suit structure of the
     * sentence.
     *
     * For example "From %1 to %2", when actually used will replace "%1" with an
     * actual value representing range start, and "%2" will be replaced by end
     * value.
     *
     * E.g. in a Scrollbar for Value axis "From %1 to %2" will become
     * "From 100 to 200". You may translate "From" and "to", as well as re-arrange
     * the order of the prompt itself, but make sure the "%1" and "%2" remain, in
     * places where they will make sense.
     *
     * Save the file as language_LOCALE, i.e. `en_GB.ts`, `fr_FR.ts`, etc.
     */
    var en = {
        "firstDayOfWeek": 1,
        // Number formatting options.
        // 
        // Please check with the local standards which separator is accepted to be
        // used for separating decimals, and which for thousands.
        "_decimalSeparator": ".",
        "_thousandSeparator": ",",
        // Position of the percent sign in numbers
        "_percentPrefix": null,
        "_percentSuffix": "%",
        // Suffixes for numbers
        // When formatting numbers, big or small numers might be reformatted to
        // shorter version, by applying a suffix.
        // 
        // For example, 1000000 might become "1m".
        // Or 1024 might become "1KB" if we're formatting byte numbers.
        // 
        // This section defines such suffixes for all such cases.
        "_big_number_suffix_3": "k",
        "_big_number_suffix_6": "M",
        "_big_number_suffix_9": "G",
        "_big_number_suffix_12": "T",
        "_big_number_suffix_15": "P",
        "_big_number_suffix_18": "E",
        "_big_number_suffix_21": "Z",
        "_big_number_suffix_24": "Y",
        "_small_number_suffix_3": "m",
        "_small_number_suffix_6": "μ",
        "_small_number_suffix_9": "n",
        "_small_number_suffix_12": "p",
        "_small_number_suffix_15": "f",
        "_small_number_suffix_18": "a",
        "_small_number_suffix_21": "z",
        "_small_number_suffix_24": "y",
        "_byte_suffix_B": "B",
        "_byte_suffix_KB": "KB",
        "_byte_suffix_MB": "MB",
        "_byte_suffix_GB": "GB",
        "_byte_suffix_TB": "TB",
        "_byte_suffix_PB": "PB",
        // Default date formats for various periods.
        // 
        // This should reflect official or de facto formatting universally accepted
        // in the country translation is being made for
        // Available format codes here:
        // https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#Format_codes
        // 
        // This will be used when formatting date/time for particular granularity,
        // e.g. "_date_hour" will be shown whenever we need to show time as hours.
        // 
        // "date" is used as in default date format when showing standalone dates.
        "_date": "yyyy-MM-dd",
        "_date_millisecond": "mm:ss SSS",
        "_date_millisecond_full": "HH:mm:ss SSS",
        "_date_second": "HH:mm:ss",
        "_date_second_full": "HH:mm:ss",
        "_date_minute": "HH:mm",
        "_date_minute_full": "HH:mm - MMM dd, yyyy",
        "_date_hour": "HH:mm",
        "_date_hour_full": "HH:mm - MMM dd, yyyy",
        "_date_day": "MMM dd",
        "_date_day_full": "MMM dd, yyyy",
        "_date_week": "ww",
        "_date_week_full": "MMM dd, yyyy",
        "_date_month": "MMM",
        "_date_month_full": "MMM, yyyy",
        "_date_year": "yyyy",
        // Default duration formats for various base units.
        // 
        // This will be used by DurationFormatter to format numeric values into
        // duration.
        // 
        // Notice how each duration unit comes in several versions. This is to ensure
        // that each base unit is shown correctly.
        // 
        // For example, if we have baseUnit set to "second", meaning our duration is
        // in seconds.
        // 
        // If we pass in `50` to formatter, it will know that we have just 50 seconds
        // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
        // and the formatted result will be in like `"50"`.
        // 
        // If we pass in `70`, which is more than a minute, the formatter will switch
        // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
        // text.
        // 
        // Available codes here:
        // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
        "_duration_millisecond": "SSS",
        "_duration_millisecond_second": "ss.SSS",
        "_duration_millisecond_minute": "mm:ss SSS",
        "_duration_millisecond_hour": "hh:mm:ss SSS",
        "_duration_millisecond_day": "d'd' mm:ss SSS",
        "_duration_millisecond_week": "d'd' mm:ss SSS",
        "_duration_millisecond_month": "M'm' dd'd' mm:ss SSS",
        "_duration_millisecond_year": "y'y' MM'm' dd'd' mm:ss SSS",
        "_duration_second": "ss",
        "_duration_second_minute": "mm:ss",
        "_duration_second_hour": "hh:mm:ss",
        "_duration_second_day": "d'd' hh:mm:ss",
        "_duration_second_week": "d'd' hh:mm:ss",
        "_duration_second_month": "M'm' dd'd' hh:mm:ss",
        "_duration_second_year": "y'y' MM'm' dd'd' hh:mm:ss",
        "_duration_minute": "mm",
        "_duration_minute_hour": "hh:mm",
        "_duration_minute_day": "d'd' hh:mm",
        "_duration_minute_week": "d'd' hh:mm",
        "_duration_minute_month": "M'm' dd'd' hh:mm",
        "_duration_minute_year": "y'y' MM'm' dd'd' hh:mm",
        "_duration_hour": "hh'h'",
        "_duration_hour_day": "d'd' hh'h'",
        "_duration_hour_week": "d'd' hh'h'",
        "_duration_hour_month": "M'm' dd'd' hh'h'",
        "_duration_hour_year": "y'y' MM'm' dd'd' hh'h'",
        "_duration_day": "d'd'",
        "_duration_day_week": "d'd'",
        "_duration_day_month": "M'm' dd'd'",
        "_duration_day_year": "y'y' MM'm' dd'd'",
        "_duration_week": "w'w'",
        "_duration_week_month": "w'w'",
        "_duration_week_year": "w'w'",
        "_duration_month": "M'm'",
        "_duration_month_year": "y'y' MM'm'",
        "_duration_year": "y'y'",
        // Era translations
        "_era_ad": "AD",
        "_era_bc": "BC",
        // Day part, used in 12-hour formats, e.g. 5 P.M.
        // Please note that these come in 3 variants:
        // * one letter (e.g. "A")
        // * two letters (e.g. "AM")
        // * two letters with dots (e.g. "A.M.")
        // 
        // All three need to to be translated even if they are all the same. Some
        // users might use one, some the other.
        "A": "",
        "P": "",
        "AM": "",
        "PM": "",
        "A.M.": "",
        "P.M.": "",
        // Date-related stuff.
        // 
        // When translating months, if there's a difference, use the form which is
        // best for a full date, e.g. as you would use it in "2018 January 1".
        // 
        // Note that May is listed twice. This is because in English May is the same
        // in both long and short forms, while in other languages it may not be the
        // case. Translate "May" to full word, while "May(short)" to shortened
        // version.
        // 
        // Should month names and weekdays be capitalized or not?
        // 
        // Rule of thumb is this: if the names should always be capitalized,
        // regardless of name position within date ("January", "21st January 2018",
        // etc.) use capitalized names. Otherwise enter all lowercase.
        // 
        // The date formatter will automatically capitalize names if they are the
        // first (or only) word in resulting date.
        "January": "",
        "February": "",
        "March": "",
        "April": "",
        "May": "",
        "June": "",
        "July": "",
        "August": "",
        "September": "",
        "October": "",
        "November": "",
        "December": "",
        "Jan": "",
        "Feb": "",
        "Mar": "",
        "Apr": "",
        "May(short)": "May",
        "Jun": "",
        "Jul": "",
        "Aug": "",
        "Sep": "",
        "Oct": "",
        "Nov": "",
        "Dec": "",
        // Weekdays.
        "Sunday": "",
        "Monday": "",
        "Tuesday": "",
        "Wednesday": "",
        "Thursday": "",
        "Friday": "",
        "Saturday": "",
        "Sun": "",
        "Mon": "",
        "Tue": "",
        "Wed": "",
        "Thu": "",
        "Fri": "",
        "Sat": "",
        // Date ordinal function.
        // 
        // This is used when adding number ordinal when formatting days in dates.
        // 
        // E.g. "January 1st", "February 2nd".
        // 
        // The function accepts day number, and returns a string to be added to the
        // day, like in default English translation, if we pass in 2, we will receive
        // "nd" back.
        "_dateOrd": function (day) {
            let res = "th";
            if ((day < 11) || (day > 13)) {
                switch (day % 10) {
                    case 1:
                        res = "st";
                        break;
                    case 2:
                        res = "nd";
                        break;
                    case 3:
                        res = "rd";
                        break;
                }
            }
            return res;
        },
        // Various chart controls.
        // Shown as a tooltip on zoom out button.
        "Zoom Out": "",
        // Timeline buttons
        "Play": "",
        "Stop": "",
        // Chart's Legend screen reader title.
        "Legend": "",
        // Legend's item screen reader indicator.
        "Press ENTER to toggle": "",
        // Shown when the chart is busy loading something.
        "Loading": "",
        // Shown as the first button in the breadcrumb navigation, e.g.:
        // Home > First level > ...
        "Home": "",
        // Chart types.
        // Those are used as default screen reader titles for the main chart element
        // unless developer has set some more descriptive title.
        "Chart": "",
        "Serial chart": "",
        "X/Y chart": "",
        "Pie chart": "",
        "Gauge chart": "",
        "Radar chart": "",
        "Sankey diagram": "",
        "Flow diagram": "",
        "Chord diagram": "",
        "TreeMap chart": "",
        "Force directed tree": "",
        "Sliced chart": "",
        // Series types.
        // Used to name series by type for screen readers if they do not have their
        // name set.
        "Series": "",
        "Candlestick Series": "",
        "OHLC Series": "",
        "Column Series": "",
        "Line Series": "",
        "Pie Slice Series": "",
        "Funnel Series": "",
        "Pyramid Series": "",
        "X/Y Series": "",
        // Map-related stuff.
        "Map": "",
        "Press ENTER to zoom in": "",
        "Press ENTER to zoom out": "",
        "Use arrow keys to zoom in and out": "",
        "Use plus and minus keys on your keyboard to zoom in and out": "",
        // Export-related stuff.
        // These prompts are used in Export menu labels.
        // 
        // "Export" is the top-level menu item.
        // 
        // "Image", "Data", "Print" as second-level indicating type of export
        // operation.
        // 
        // Leave actual format untranslated, unless you absolutely know that they
        // would convey more meaning in some other way.
        "Export": "",
        "Image": "",
        "Data": "",
        "Print": "",
        "Press ENTER or use arrow keys to navigate": "",
        "Press ENTER to open": "",
        "Press ENTER to print.": "",
        "Press ENTER to export as %1.": "",
        "(Press ESC to close this message)": "",
        "Image Export Complete": "",
        "Export operation took longer than expected. Something might have gone wrong.": "",
        "Saved from": "",
        "PNG": "",
        "JPG": "",
        "GIF": "",
        "SVG": "",
        "PDF": "",
        "JSON": "",
        "CSV": "",
        "XLSX": "",
        "HTML": "",
        // Scrollbar-related stuff.
        // 
        // Scrollbar is a control which can zoom and pan the axes on the chart.
        // 
        // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
        // upper and lower (for vertical one).
        // 
        // Prompts change in relation to whether Scrollbar is vertical or horizontal.
        // 
        // The final section is used to indicate the current range of selection.
        "Use TAB to select grip buttons or left and right arrows to change selection": "",
        "Use left and right arrows to move selection": "",
        "Use left and right arrows to move left selection": "",
        "Use left and right arrows to move right selection": "",
        "Use TAB select grip buttons or up and down arrows to change selection": "",
        "Use up and down arrows to move selection": "",
        "Use up and down arrows to move lower selection": "",
        "Use up and down arrows to move upper selection": "",
        "From %1 to %2": "",
        "From %1": "",
        "To %1": "",
        // Data loader-related.
        "No parser available for file: %1": "",
        "Error parsing file: %1": "",
        "Unable to load file: %1": "",
        "Invalid date": "",
        // Common actions
        "Close": "",
        "Minimize": ""
    };

    /**
     * Add localization functionality.
     */
    class Language extends Entity {
        _setDefaults() {
            this.setPrivate("defaultLocale", en);
            super._setDefaults();
        }
        /**
         * Returns a prompt translation.
         *
         * @param   prompt   Prompt to translate
         * @param   locale   Target locale
         * @param   ...rest  Parameters
         * @return           Translation
         */
        translate(prompt, locale, ...rest) {
            // Get langauge
            if (!locale) {
                locale = this._root.locale || this.getPrivate("defaultLocale");
            }
            // Init translation
            let translation = prompt;
            let value = locale[prompt];
            // Try to look for the translation
            if (value === null) {
                translation = "";
            }
            else if (value != null) {
                // It might be an empty string
                if (value) {
                    translation = value;
                }
            }
            else if (locale !== this.getPrivate("defaultLocale")) {
                // Try to look in default language
                return this.translate(prompt, this.getPrivate("defaultLocale"), ...rest);
            }
            // Replace %1, %2, etc params
            if (rest.length) {
                for (let len = rest.length, i = 0; i < len; ++i) {
                    translation = translation.split("%" + (i + 1)).join(rest[i]);
                }
            }
            // Return the translation
            return translation;
        }
        /**
         * Returns a prompt translation, including custom prompts.
         *
         * @param   prompt   Prompt to translate
         * @param   locale   Target locale
         * @param   ...rest  Parameters
         * @return           Translation
         */
        translateAny(prompt, locale, ...rest) {
            return this.translate(prompt, locale, ...rest);
        }
        /**
         * Add a custom prompt to locale.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
         * @param  prompt       Source prompt
         * @param  translation  Tanslation
         * @param  locale       Target locale
         */
        setTranslationAny(prompt, translation, locale) {
            const localeTarget = locale || this._root.locale;
            localeTarget[prompt] = translation;
        }
        /**
         * Add a batch of custom prompts.
         *
         * @since 5.3.3
         * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
         * @param  translations  Translations
         * @param  locale        Target locale
         */
        setTranslationsAny(translations, locale) {
            each(translations, (key, val) => {
                this.setTranslationAny(key, val, locale);
            });
        }
        translateEmpty(prompt, locale, ...rest) {
            let translation = this.translate(prompt, locale, ...rest);
            return translation == prompt ? "" : translation;
        }
        translateFunc(prompt, locale) {
            if (this._root.locale[prompt]) {
                return this._root.locale[prompt];
            }
            // Try to look in default language
            if (locale !== this.getPrivate("defaultLocale")) {
                return this.translateFunc(prompt, this.getPrivate("defaultLocale"));
            }
            // Fail - return empty function
            return () => {
                return "";
            };
        }
        /**
         * Translates a btach of prompts.
         *
         * @param  list    Array of prompts to translate
         * @param  locale  Target locale
         * @return         Array of translations
         */
        translateAll(list, locale) {
            // Translate all items in the list
            if (!this.isDefault()) {
                return map(list, (x) => this.translate(x, locale));
            }
            else {
                return list;
            }
        }
        /**
         * Returns `true` if the currently selected locale is a default locale.
         *
         * @return `true` if locale is default; `false` if it is not.
         */
        isDefault() {
            return this.getPrivate("defaultLocale") === this._root.locale;
        }
    }

    /**
     * A base class for an amCharts theme.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
     * @important
     */
    class Theme {
        constructor(root, isReal) {
            Object.defineProperty(this, "_root", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_rules", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            this._root = root;
            if (!isReal) {
                throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
            }
        }
        /**
         * Use this method to create an instance of this class.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
         * @param   root      Root element
         * @param   settings  Settings
         * @param   template  Template
         * @return            Instantiated object
         */
        static new(root) {
            const x = (new this(root, true));
            x.setupDefaultRules();
            return x;
        }
        setupDefaultRules() { }
        /**
         * Looks up the rules for a specific theme class.
         *
         * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
         * @param   themeClass Theme class
         * @return             Array<IRule<A>>
         */
        _lookupRules(themeClass) {
            return this._rules[themeClass];
        }
        /**
         * Creates a [[Template]] for specific theme class and tags.
         *
         * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any
         * type checks.
         *
         * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
         * @param   themeClass Theme class
         * @param   themeTags  Theme tags
         * @return             Template
         */
        ruleRaw(themeClass, themeTags = []) {
            let rules = this._rules[themeClass];
            if (!rules) {
                rules = this._rules[themeClass] = [];
            }
            themeTags.sort(compare);
            const { index, found } = getSortedIndex(rules, (x) => {
                const order = compare(x.tags.length, themeTags.length);
                if (order === 0) {
                    return compareArray(x.tags, themeTags, compare);
                }
                else {
                    return order;
                }
            });
            if (found) {
                return rules[index].template;
            }
            else {
                const template = Template.new({});
                rules.splice(index, 0, {
                    tags: themeTags,
                    template,
                });
                return template;
            }
        }
        /**
         * Creates a [[Template]] for specific theme class and tags.
         *
         * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
         * @param   themeClass Theme class
         * @param   themeTags  Theme tags
         * @return             Template
         */
        rule(themeClass, themeTags = []) {
            return this.ruleRaw(themeClass, themeTags);
        }
    }

    /**
     * @ignore
     */
    function setColor(rule, key, ic, name) {
        // TODO this shouldn't use get, figure out a better way
        rule.set(key, ic.get(name));
        ic.on(name, (value) => {
            rule.set(key, value);
        });
    }
    /**
     * @ignore
     */
    class DefaultTheme extends Theme {
        setupDefaultRules() {
            super.setupDefaultRules();
            const language = this._root.language;
            const ic = this._root.interfaceColors;
            const horizontalLayout = this._root.horizontalLayout;
            const verticalLayout = this._root.verticalLayout;
            const r = this.rule.bind(this);
            /**
             * ========================================================================
             * core
             * ========================================================================
             */
            r("InterfaceColors").setAll({
                stroke: Color.fromHex(0xe5e5e5),
                fill: Color.fromHex(0xf3f3f3),
                primaryButton: Color.fromHex(0x6794dc),
                primaryButtonHover: Color.fromHex(0x6771dc),
                primaryButtonDown: Color.fromHex(0x68dc76),
                primaryButtonActive: Color.fromHex(0x68dc76),
                primaryButtonDisabled: Color.fromHex(0xdadada),
                primaryButtonTextDisabled: Color.fromHex(0xffffff),
                primaryButtonText: Color.fromHex(0xffffff),
                primaryButtonStroke: Color.fromHex(0xffffff),
                secondaryButton: Color.fromHex(0xd9d9d9),
                secondaryButtonHover: Color.fromHex(0xa3a3a3),
                secondaryButtonDown: Color.fromHex(0x8d8d8d),
                secondaryButtonActive: Color.fromHex(0xe6e6e6),
                secondaryButtonText: Color.fromHex(0x000000),
                secondaryButtonStroke: Color.fromHex(0xffffff),
                grid: Color.fromHex(0x000000),
                background: Color.fromHex(0xffffff),
                alternativeBackground: Color.fromHex(0x000000),
                text: Color.fromHex(0x000000),
                alternativeText: Color.fromHex(0xffffff),
                disabled: Color.fromHex(0xadadad),
                positive: Color.fromHex(0x50b300),
                negative: Color.fromHex(0xb30000)
            });
            {
                const rule = r("ColorSet");
                rule.setAll({
                    passOptions: {
                        hue: 0.05,
                        saturation: 0,
                        lightness: 0
                    },
                    colors: [
                        Color.fromHex(0x67b7dc)
                    ],
                    step: 1,
                    //baseColor: Color.fromRGB(103, 183, 220),
                    //count: 20,
                    reuse: false,
                    startIndex: 0
                });
                rule.setPrivate("currentStep", 0);
                rule.setPrivate("currentPass", 0);
            }
            r("Entity").setAll({
                stateAnimationDuration: 0,
                stateAnimationEasing: out(cubic)
            });
            r("Component").setAll({
                interpolationDuration: 0,
                interpolationEasing: out(cubic)
            });
            r("Sprite").setAll({
                visible: true,
                scale: 1,
                opacity: 1,
                rotation: 0,
                position: "relative",
                tooltipX: p50,
                tooltipY: p50,
                tooltipPosition: "fixed",
                isMeasured: true
            });
            r("Sprite").states.create("default", { "visible": true, opacity: 1 });
            r("Container").setAll({
                interactiveChildren: true,
                setStateOnChildren: false
            });
            r("Graphics").setAll({
                strokeWidth: 1
            });
            r("Chart").setAll({
                width: p100,
                height: p100,
                interactiveChildren: false
            });
            r("ZoomableContainer").setAll({
                width: p100,
                height: p100,
                wheelable: true,
                pinchZoom: true,
                maxZoomLevel: 32,
                minZoomLevel: 1,
                zoomStep: 2,
                animationEasing: out(cubic),
                animationDuration: 600
            });
            /**
             * ------------------------------------------------------------------------
             * core: alignment
             * ------------------------------------------------------------------------
             */
            r("Sprite", ["horizontal", "center"]).setAll({
                centerX: p50,
                x: p50
            });
            r("Sprite", ["vertical", "center"]).setAll({
                centerY: p50,
                y: p50
            });
            r("Container", ["horizontal", "layout"]).setAll({
                layout: horizontalLayout
            });
            r("Container", ["vertical", "layout"]).setAll({
                layout: verticalLayout
            });
            /**
             * ------------------------------------------------------------------------
             * core: patterns
             * ------------------------------------------------------------------------
             */
            r("Pattern").setAll({
                repetition: "repeat",
                width: 50,
                height: 50,
                rotation: 0,
                fillOpacity: 1
            });
            r("LinePattern").setAll({
                gap: 6,
                colorOpacity: 1,
                width: 49,
                height: 49
            });
            r("RectanglePattern").setAll({
                gap: 6,
                checkered: false,
                centered: true,
                maxWidth: 5,
                maxHeight: 5,
                width: 48,
                height: 48,
                strokeWidth: 0
            });
            r("CirclePattern").setAll({
                gap: 5,
                checkered: false,
                centered: false,
                radius: 3,
                strokeWidth: 0,
                width: 45,
                height: 45
            });
            r("GrainPattern").setAll({
                width: 200,
                height: 200,
                colors: [Color.fromHex(0x000000)],
                size: 1,
                horizontalGap: 0,
                verticalGap: 0,
                density: 1,
                minOpacity: 0,
                maxOpacity: 0.2
            });
            {
                const rule = r("PatternSet");
                rule.setAll({
                    step: 1
                });
                setColor(rule, "color", ic, "stroke");
            }
            /**
             * ------------------------------------------------------------------------
             * core: gradients
             * ------------------------------------------------------------------------
             */
            r("LinearGradient").setAll({
                rotation: 90
            });
            /**
             * ------------------------------------------------------------------------
             * core: Legend
             * ------------------------------------------------------------------------
             */
            r("Legend").setAll({
                fillField: "fill",
                strokeField: "stroke",
                nameField: "name",
                layout: GridLayout.new(this._root, {}),
                layer: 30,
                clickTarget: "itemContainer"
            });
            // Class: Container
            r("Container", ["legend", "item", "itemcontainer"]).setAll({
                paddingLeft: 5,
                paddingRight: 5,
                paddingBottom: 5,
                paddingTop: 5,
                layout: horizontalLayout,
                setStateOnChildren: true,
                interactiveChildren: false,
                ariaChecked: true,
                focusable: true,
                ariaLabel: language.translate("Press ENTER to toggle"),
                role: "checkbox"
            });
            {
                const rule = r("Rectangle", ["legend", "item", "background"]);
                rule.setAll({
                    fillOpacity: 0,
                });
                setColor(rule, "fill", ic, "background");
            }
            r("Container", ["legend", "marker"]).setAll({
                setStateOnChildren: true,
                centerY: p50,
                paddingLeft: 0,
                paddingRight: 0,
                paddingBottom: 0,
                paddingTop: 0,
                width: 18,
                height: 18
            });
            r("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({
                width: p100,
                height: p100,
                cornerRadiusBL: 3,
                cornerRadiusTL: 3,
                cornerRadiusBR: 3,
                cornerRadiusTR: 3
            });
            {
                const rule = r("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {});
                setColor(rule, "fill", ic, "disabled");
                setColor(rule, "stroke", ic, "disabled");
            }
            r("Label", ["legend", "label"]).setAll({
                centerY: p50,
                marginLeft: 5,
                paddingRight: 0,
                paddingLeft: 0,
                paddingTop: 0,
                paddingBottom: 0,
                populateText: true
            });
            {
                const rule = r("Label", ["legend", "label"]).states.create("disabled", {});
                setColor(rule, "fill", ic, "disabled");
            }
            r("Label", ["legend", "value", "label"]).setAll({
                centerY: p50,
                marginLeft: 5,
                paddingRight: 0,
                paddingLeft: 0,
                paddingTop: 0,
                paddingBottom: 0,
                width: 50,
                centerX: p100,
                populateText: true
            });
            {
                const rule = r("Label", ["legend", "value", "label"]).states.create("disabled", {});
                setColor(rule, "fill", ic, "disabled");
            }
            /**
             * ------------------------------------------------------------------------
             * core: HeatLegend
             * ------------------------------------------------------------------------
             */
            r("HeatLegend").setAll({
                stepCount: 1
            });
            r("RoundedRectangle", ["heatlegend", "marker"]).setAll({
                cornerRadiusTR: 0,
                cornerRadiusBR: 0,
                cornerRadiusTL: 0,
                cornerRadiusBL: 0
            });
            r("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({
                height: p100,
                width: 15
            });
            r("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({
                width: p100,
                height: 15
            });
            r("HeatLegend", ["vertical"]).setAll({
                height: p100
            });
            r("HeatLegend", ["horizontal"]).setAll({
                width: p100
            });
            r("Label", ["heatlegend", "start"]).setAll({
                paddingLeft: 5,
                paddingRight: 5,
                paddingTop: 5,
                paddingBottom: 5
            });
            r("Label", ["heatlegend", "end"]).setAll({
                paddingLeft: 5,
                paddingRight: 5,
                paddingTop: 5,
                paddingBottom: 5
            });
            /**
             * ------------------------------------------------------------------------
             * core: Labels
             * ------------------------------------------------------------------------
             */
            {
                const rule = r("Label");
                rule.setAll({
                    paddingTop: 8,
                    paddingBottom: 8,
                    paddingLeft: 10,
                    paddingRight: 10,
                    fontFamily: "-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"",
                    fontSize: "1em",
                    populateText: false
                });
                setColor(rule, "fill", ic, "text");
            }
            r("RadialLabel").setAll({
                textType: "regular",
                centerY: p50,
                centerX: p50,
                inside: false,
                radius: 0,
                baseRadius: p100,
                orientation: "auto",
                textAlign: "center"
            });
            r("EditableLabel").setAll({
                editOn: "click",
                //setStateOnChildren: true,
                themeTags: ["editablelabel"],
                multiLine: true
            });
            r("RoundedRectangle", ["editablelabel", "background"]).setAll({
                fillOpacity: 0,
                fill: Color.fromHex(0x000000),
                cornerRadiusBL: 3,
                cornerRadiusBR: 3,
                cornerRadiusTL: 3,
                cornerRadiusTR: 3,
                strokeOpacity: 0,
                stroke: Color.fromHex(0x000000)
            });
            {
                r("RoundedRectangle", ["editablelabel", "background"]).states.create("active", {
                    strokeOpacity: 0.2,
                });
            }
            /**
             * ------------------------------------------------------------------------
             * core: Elements and shapes
             * ------------------------------------------------------------------------
             */
            r("RoundedRectangle").setAll({
                cornerRadiusTL: 8,
                cornerRadiusBL: 8,
                cornerRadiusTR: 8,
                cornerRadiusBR: 8
            });
            r("PointedRectangle").setAll({
                pointerBaseWidth: 15,
                pointerLength: 10,
                cornerRadius: 8
            });
            r("Slice").setAll({
                shiftRadius: 0,
                dRadius: 0,
                dInnerRadius: 0
            });
            {
                const rule = r("Tick");
                rule.setAll({
                    strokeOpacity: .15,
                    isMeasured: false,
                    length: 4.5,
                    position: "absolute",
                    crisp: true
                });
                setColor(rule, "stroke", ic, "grid");
            }
            r("Bullet").setAll({
                locationX: 0.5,
                locationY: 0.5
            });
            /**
             * ------------------------------------------------------------------------
             * core: Tooltip
             * ------------------------------------------------------------------------
             */
            r("Tooltip").setAll({
                position: "absolute",
                getFillFromSprite: true,
                getStrokeFromSprite: false,
                autoTextColor: true,
                paddingTop: 9,
                paddingBottom: 8,
                paddingLeft: 10,
                paddingRight: 10,
                marginBottom: 5,
                pointerOrientation: "vertical",
                centerX: p50,
                centerY: p50,
                animationEasing: out(cubic),
                exportable: false
                //layer: 100
            });
            r("Polygon").setAll({
                animationEasing: out(cubic),
            });
            {
                const rule = r("PointedRectangle", ["tooltip", "background"]);
                rule.setAll({
                    strokeOpacity: 0.9,
                    cornerRadius: 4,
                    pointerLength: 4,
                    pointerBaseWidth: 8,
                    fillOpacity: 0.9,
                    stroke: Color.fromHex(0xffffff)
                });
            }
            {
                const rule = r("Label", ["tooltip"]);
                rule.setAll({
                    role: "tooltip",
                    populateText: true,
                    paddingRight: 0,
                    paddingTop: 0,
                    paddingLeft: 0,
                    paddingBottom: 0
                });
                setColor(rule, "fill", ic, "alternativeText");
            }
            /**
             * ------------------------------------------------------------------------
             * core: Button
             * ------------------------------------------------------------------------
             */
            r("Button").setAll({
                paddingTop: 8,
                paddingBottom: 8,
                paddingLeft: 10,
                paddingRight: 10,
                interactive: true,
                layout: horizontalLayout,
                interactiveChildren: false,
                setStateOnChildren: true,
                focusable: true
            });
            r("Button").states.create("hover", {});
            r("Button").states.create("down", { stateAnimationDuration: 0 });
            r("Button").states.create("active", {});
            r("Button").states.create("disabled", {
                forceInactive: true
            });
            {
                const rule = r("RoundedRectangle", ["button", "background"]);
                setColor(rule, "fill", ic, "primaryButton");
                setColor(rule, "stroke", ic, "primaryButtonStroke");
            }
            {
                const rule = r("RoundedRectangle", ["button", "background"]).states.create("hover", {});
                setColor(rule, "fill", ic, "primaryButtonHover");
            }
            {
                const rule = r("RoundedRectangle", ["button", "background"]).states.create("down", { stateAnimationDuration: 0 });
                setColor(rule, "fill", ic, "primaryButtonDown");
            }
            {
                const rule = r("RoundedRectangle", ["button", "background"]).states.create("active", {});
                setColor(rule, "fill", ic, "primaryButtonActive");
            }
            {
                const rule = r("RoundedRectangle", ["button", "background"]).states.create("disabled", {});
                setColor(rule, "fill", ic, "primaryButtonDisabled");
            }
            {
                const rule = r("Graphics", ["button", "icon"]).states.create("disabled", {});
                setColor(rule, "fill", ic, "primaryButtonTextDisabled");
            }
            {
                const rule = r("Label", ["button"]).states.create("disabled", {});
                setColor(rule, "fill", ic, "primaryButtonTextDisabled");
            }
            {
                const rule = r("Graphics", ["button", "icon"]);
                rule.setAll({
                    forceInactive: true
                });
                setColor(rule, "stroke", ic, "primaryButtonText");
            }
            {
                const rule = r("Label", ["button"]);
                setColor(rule, "fill", ic, "primaryButtonText");
            }
            /**
             * ------------------------------------------------------------------------
             * charts/xy: ZoomOutButton
             * ------------------------------------------------------------------------
             */
            r("Button", ["zoom"]).setAll({
                paddingTop: 18,
                paddingBottom: 18,
                paddingLeft: 12,
                paddingRight: 12,
                centerX: 46,
                centerY: -10,
                y: 0,
                x: p100,
                role: "button",
                ariaLabel: language.translate("Zoom Out"),
                layer: 30
            });
            {
                const rule = r("RoundedRectangle", ["background", "button", "zoom"]);
                rule.setAll({
                    cornerRadiusBL: 40,
                    cornerRadiusBR: 40,
                    cornerRadiusTL: 40,
                    cornerRadiusTR: 40
                });
                setColor(rule, "fill", ic, "primaryButton");
            }
            {
                const rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {});
                setColor(rule, "fill", ic, "primaryButtonHover");
            }
            {
                const rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", { stateAnimationDuration: 0 });
                setColor(rule, "fill", ic, "primaryButtonDown");
            }
            {
                const rule = r("Graphics", ["icon", "button", "zoom"]);
                rule.setAll({
                    crisp: true,
                    strokeOpacity: 0.7,
                    draw: (display) => {
                        display.moveTo(0, 0);
                        display.lineTo(12, 0);
                    }
                });
                setColor(rule, "stroke", ic, "primaryButtonText");
            }
            /**
             * ------------------------------------------------------------------------
             * core: ResizeButton
             * ------------------------------------------------------------------------
             */
            r("Button", ["resize"]).setAll({
                paddingTop: 9,
                paddingBottom: 9,
                paddingLeft: 13,
                paddingRight: 13,
                draggable: true,
                centerX: p50,
                centerY: p50,
                position: "absolute",
                role: "slider",
                ariaValueMin: "0",
                ariaValueMax: "100",
                ariaLabel: language.translate("Use up and down arrows to move selection")
            });
            {
                const rule = r("RoundedRectangle", ["background", "resize", "button"]);
                rule.setAll({
                    cornerRadiusBL: 40,
                    cornerRadiusBR: 40,
                    cornerRadiusTL: 40,
                    cornerRadiusTR: 40
                });
                setColor(rule, "fill", ic, "secondaryButton");
                setColor(rule, "stroke", ic, "secondaryButtonStroke");
            }
            {
                const rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {});
                setColor(rule, "fill", ic, "secondaryButtonHover");
            }
            {
                const rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("down", { stateAnimationDuration: 0 });
                setColor(rule, "fill", ic, "secondaryButtonDown");
            }
            {
                const rule = r("Graphics", ["resize", "button", "icon"]);
                rule.setAll({
                    interactive: false,
                    crisp: true,
                    strokeOpacity: 0.5,
                    draw: (display) => {
                        display.moveTo(0, 0.5);
                        display.lineTo(0, 12.5);
                        display.moveTo(4, 0.5);
                        display.lineTo(4, 12.5);
                    }
                });
                setColor(rule, "stroke", ic, "secondaryButtonText");
            }
            r("Button", ["resize", "vertical"]).setAll({
                rotation: 90,
                cursorOverStyle: "ns-resize"
            });
            r("Button", ["resize", "horizontal"]).setAll({
                cursorOverStyle: "ew-resize"
            });
            /**
             * ------------------------------------------------------------------------
             * core: PlayButton
             * ------------------------------------------------------------------------
             */
            r("Button", ["play"]).setAll({
                paddingTop: 13,
                paddingBottom: 13,
                paddingLeft: 14,
                paddingRight: 14,
                ariaLabel: language.translate("Play"),
                toggleKey: "active"
            });
            {
                const rule = r("RoundedRectangle", ["play", "background"]);
                rule.setAll({
                    strokeOpacity: 0.5,
                    cornerRadiusBL: 100,
                    cornerRadiusBR: 100,
                    cornerRadiusTL: 100,
                    cornerRadiusTR: 100
                });
                setColor(rule, "fill", ic, "primaryButton");
            }
            {
                const rule = r("Graphics", ["play", "icon"]);
                rule.setAll({
                    stateAnimationDuration: 0,
                    dx: 1,
                    draw: (display) => {
                        display.moveTo(0, -5);
                        display.lineTo(8, 0);
                        display.lineTo(0, 5);
                        display.lineTo(0, -5);
                    }
                });
                setColor(rule, "fill", ic, "primaryButtonText");
            }
            r("Graphics", ["play", "icon"]).states.create("default", {
                stateAnimationDuration: 0
            });
            r("Graphics", ["play", "icon"]).states.create("active", {
                stateAnimationDuration: 0,
                draw: (display) => {
                    display.moveTo(-4, -5);
                    display.lineTo(-1, -5);
                    display.lineTo(-1, 5);
                    display.lineTo(-4, 5);
                    display.lineTo(-4, -5);
                    display.moveTo(4, -5);
                    display.lineTo(1, -5);
                    display.lineTo(1, 5);
                    display.lineTo(4, 5);
                    display.lineTo(4, -5);
                }
            });
            /**
             * ------------------------------------------------------------------------
             * core: SwitchButton
             * ------------------------------------------------------------------------
             */
            r("Button", ["switch"]).setAll({
                paddingTop: 4,
                paddingBottom: 4,
                paddingLeft: 4,
                paddingRight: 4,
                ariaLabel: language.translate("Press ENTER to toggle"),
                toggleKey: "active",
                width: 40,
                height: 24,
                layout: null
            });
            {
                const rule = r("RoundedRectangle", ["switch", "background"]);
                rule.setAll({
                    strokeOpacity: 0.5,
                    cornerRadiusBL: 100,
                    cornerRadiusBR: 100,
                    cornerRadiusTL: 100,
                    cornerRadiusTR: 100
                });
                setColor(rule, "fill", ic, "primaryButton");
            }
            {
                const rule = r("Circle", ["switch", "icon"]);
                rule.setAll({
                    radius: 8,
                    centerY: 0,
                    centerX: 0,
                    dx: 0
                });
                setColor(rule, "fill", ic, "primaryButtonText");
            }
            r("Graphics", ["switch", "icon"]).states.create("active", {
                dx: 16
            });
            /**
             * ------------------------------------------------------------------------
             * core: Scrollbar
             * ------------------------------------------------------------------------
             */
            r("Scrollbar").setAll({
                start: 0,
                end: 1,
                layer: 30,
                animationEasing: out(cubic)
            });
            r("Scrollbar", ["vertical"]).setAll({
                marginRight: 13,
                marginLeft: 13,
                minWidth: 12,
                height: p100
            });
            r("Scrollbar", ["horizontal"]).setAll({
                marginTop: 13,
                marginBottom: 13,
                minHeight: 12,
                width: p100
            });
            this.rule("Button", ["scrollbar"]).setAll({
                exportable: false
            });
            {
                const rule = r("RoundedRectangle", ["scrollbar", "main", "background"]);
                rule.setAll({
                    cornerRadiusTL: 8,
                    cornerRadiusBL: 8,
                    cornerRadiusTR: 8,
                    cornerRadiusBR: 8,
                    fillOpacity: 0.8,
                });
                setColor(rule, "fill", ic, "fill");
            }
            {
                const rule = r("RoundedRectangle", ["scrollbar", "thumb"]);
                rule.setAll({
                    role: "slider",
                    ariaLive: "polite",
                    position: "absolute",
                    draggable: true
                });
                setColor(rule, "fill", ic, "secondaryButton");
            }
            {
                const rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {});
                setColor(rule, "fill", ic, "secondaryButtonHover");
            }
            {
                const rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", { stateAnimationDuration: 0 });
                setColor(rule, "fill", ic, "secondaryButtonDown");
            }
            r("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({
                x: p50,
                width: p100,
                centerX: p50,
                ariaLabel: language.translate("Use up and down arrows to move selection")
            });
            r("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({
                y: p50,
                centerY: p50,
                height: p100,
                ariaLabel: language.translate("Use left and right arrows to move selection")
            });
            // @todo: is this needed? used to be "ContentScrollbar"
            // r("Scrollbar", ["content?"]).setAll({
            // 	marginRight: 0,
            // 	marginLeft: 5,
            // 	layer: 5
            // });
            /**
             * ========================================================================
             * charts/xy
             * ========================================================================
             *
             * This needs to be in DefaultTheme because it's the only theme that is
             * automatically applied to Root, and tooltips different ancestors
             * than actual charts using them.
             */
            {
                const rule = r("PointedRectangle", ["axis", "tooltip", "background"]);
                rule.setAll({
                    cornerRadius: 0
                });
                setColor(rule, "fill", ic, "alternativeBackground");
            }
            r("Label", ["axis", "tooltip"]).setAll({
                role: undefined
            });
            r("Label", ["axis", "tooltip", "y"]).setAll({
                textAlign: "right"
            });
            r("Label", ["axis", "tooltip", "y", "opposite"]).setAll({
                textAlign: "left"
            });
            r("Label", ["axis", "tooltip", "x"]).setAll({
                textAlign: "center"
            });
            r("Tooltip", ["categoryaxis"]).setAll({
                labelText: "{category}"
            });
            /**
             * ------------------------------------------------------------------------
             * Shapes
             * ------------------------------------------------------------------------
             */
            // Class: Graphics
            r("Star").setAll({
                spikes: 5,
                innerRadius: 5,
                radius: 10
            });
            // STOCK
            r("Tooltip", ["stock"]).setAll({
                paddingTop: 6,
                paddingBottom: 5,
                paddingLeft: 7,
                paddingRight: 7
            });
            r("PointedRectangle", ["tooltip", "stock", "axis"]).setAll({
                pointerLength: 0,
                pointerBaseWidth: 0,
                cornerRadius: 3
            });
            r("Label", ["tooltip", "stock"]).setAll({
                fontSize: "0.8em"
            });
            // resizer
            r("SpriteResizer").setAll({
                rotationStep: 10,
                isMeasured: false
            });
            {
                const rule = r("Container", ["resizer", "grip"]);
                rule.states.create("hover", {});
            }
            {
                const rule = r("RoundedRectangle", ["resizer", "grip"]);
                rule.setAll({
                    strokeOpacity: 0.7,
                    strokeWidth: 1,
                    fillOpacity: 1,
                    width: 12,
                    height: 12
                });
                setColor(rule, "fill", ic, "background");
                setColor(rule, "stroke", ic, "alternativeBackground");
            }
            {
                const rule = r("RoundedRectangle", ["resizer", "grip", "outline"]);
                rule.setAll({
                    strokeOpacity: 0,
                    fillOpacity: 0,
                    width: 20,
                    height: 20
                });
                rule.states.create("hover", {
                    fillOpacity: 0.3
                });
                setColor(rule, "fill", ic, "alternativeBackground");
            }
            r("RoundedRectangle", ["resizer", "grip", "left"]).setAll({
                cornerRadiusBL: 0,
                cornerRadiusBR: 0,
                cornerRadiusTL: 0,
                cornerRadiusTR: 0
            });
            r("RoundedRectangle", ["resizer", "grip", "right"]).setAll({
                cornerRadiusBL: 0,
                cornerRadiusBR: 0,
                cornerRadiusTL: 0,
                cornerRadiusTR: 0
            });
            {
                const rule = r("Rectangle", ["resizer", "rectangle"]);
                rule.setAll({
                    strokeDasharray: [2, 2],
                    strokeOpacity: 0.5,
                    strokeWidth: 1
                });
                setColor(rule, "stroke", ic, "alternativeBackground");
            }
            r("Graphics", ["button", "plus", "icon"]).setAll({
                x: p50,
                y: p50,
                draw: (display) => {
                    display.moveTo(-4, 0);
                    display.lineTo(4, 0);
                    display.moveTo(0, -4);
                    display.lineTo(0, 4);
                }
            });
            r("Graphics", ["button", "minus", "icon"]).setAll({
                x: p50,
                y: p50,
                draw: (display) => {
                    display.moveTo(-4, 0);
                    display.lineTo(4, 0);
                }
            });
            r("Graphics", ["button", "home", "icon"]).setAll({
                x: p50,
                y: p50,
                svgPath: "M 8 -1 L 6 -1 L 6 7 L 2 7 L 2 1 L -2 1 L -2 7 L -6 7 L -6 -1 L -8 -1 L 0 -9 L 8 -1 Z M 8 -1"
            });
            r("Button", ["zoomtools"]).setAll({
                marginTop: 1,
                marginBottom: 2
            });
            r("ZoomTools").setAll({
                x: p100,
                centerX: p100,
                y: p100,
                centerY: p100,
                paddingRight: 10,
                paddingBottom: 10
            });
        }
    }

    /**
     * Modified from Pixi:
     *
     * The MIT License
     *
     * Copyright (c) 2013-2017 Mathew Groves, Chad Engler
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @ignore
     */
    class Matrix {
        constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
            Object.defineProperty(this, "a", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "b", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "c", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "d", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "tx", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "ty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
        }
        /**
         * Sets the matrix based on all the available properties
         */
        setTransform(x, y, pivotX, pivotY, rotation, scale = 1) {
            this.a = Math.cos(rotation) * scale;
            this.b = Math.sin(rotation) * scale;
            this.c = -Math.sin(rotation) * scale;
            this.d = Math.cos(rotation) * scale;
            this.tx = x - ((pivotX * this.a) + (pivotY * this.c));
            this.ty = y - ((pivotX * this.b) + (pivotY * this.d));
        }
        /**
         * Get a new position with the current transformation applied.
         * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
         */
        apply(origin) {
            return {
                x: (this.a * origin.x) + (this.c * origin.y) + this.tx,
                y: (this.b * origin.x) + (this.d * origin.y) + this.ty
            };
        }
        /**
         * Get a new position with the inverse of the current transformation applied.
         * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
         */
        applyInverse(origin) {
            const id = 1 / ((this.a * this.d) + (this.c * -this.b));
            return {
                x: (this.d * id * origin.x) + (-this.c * id * origin.y) + (((this.ty * this.c) - (this.tx * this.d)) * id),
                y: (this.a * id * origin.y) + (-this.b * id * origin.x) + (((-this.ty * this.a) + (this.tx * this.b)) * id)
            };
        }
        /**
         * Appends the given Matrix to this Matrix.
         */
        append(matrix) {
            const a1 = this.a;
            const b1 = this.b;
            const c1 = this.c;
            const d1 = this.d;
            this.a = (matrix.a * a1) + (matrix.b * c1);
            this.b = (matrix.a * b1) + (matrix.b * d1);
            this.c = (matrix.c * a1) + (matrix.d * c1);
            this.d = (matrix.c * b1) + (matrix.d * d1);
            this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;
            this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;
        }
        /**
         * Prepends the given Matrix to this Matrix.
         */
        prepend(matrix) {
            const tx1 = this.tx;
            if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
                const a1 = this.a;
                const c1 = this.c;
                this.a = (a1 * matrix.a) + (this.b * matrix.c);
                this.b = (a1 * matrix.b) + (this.b * matrix.d);
                this.c = (c1 * matrix.a) + (this.d * matrix.c);
                this.d = (c1 * matrix.b) + (this.d * matrix.d);
            }
            this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;
            this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;
        }
        /**
         * Copies the other matrix's properties into this matrix
         */
        copyFrom(matrix) {
            this.a = matrix.a;
            this.b = matrix.b;
            this.c = matrix.c;
            this.d = matrix.d;
            this.tx = matrix.tx;
            this.ty = matrix.ty;
        }
    }

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var TAU = Math.PI * 2;

    var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
      var x = _ref.x,
          y = _ref.y;

      x *= rx;
      y *= ry;

      var xp = cosphi * x - sinphi * y;
      var yp = sinphi * x + cosphi * y;

      return {
        x: xp + centerx,
        y: yp + centery
      };
    };

    var approxUnitArc = function approxUnitArc(ang1, ang2) {
      // If 90 degree circular arc, use a constant
      // as derived from http://spencermortensen.com/articles/bezier-circle
      var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);

      var x1 = Math.cos(ang1);
      var y1 = Math.sin(ang1);
      var x2 = Math.cos(ang1 + ang2);
      var y2 = Math.sin(ang1 + ang2);

      return [{
        x: x1 - y1 * a,
        y: y1 + x1 * a
      }, {
        x: x2 + y2 * a,
        y: y2 - x2 * a
      }, {
        x: x2,
        y: y2
      }];
    };

    var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
      var sign = ux * vy - uy * vx < 0 ? -1 : 1;

      var dot = ux * vx + uy * vy;

      if (dot > 1) {
        dot = 1;
      }

      if (dot < -1) {
        dot = -1;
      }

      return sign * Math.acos(dot);
    };

    var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
      var rxsq = Math.pow(rx, 2);
      var rysq = Math.pow(ry, 2);
      var pxpsq = Math.pow(pxp, 2);
      var pypsq = Math.pow(pyp, 2);

      var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

      if (radicant < 0) {
        radicant = 0;
      }

      radicant /= rxsq * pypsq + rysq * pxpsq;
      radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

      var centerxp = radicant * rx / ry * pyp;
      var centeryp = radicant * -ry / rx * pxp;

      var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
      var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

      var vx1 = (pxp - centerxp) / rx;
      var vy1 = (pyp - centeryp) / ry;
      var vx2 = (-pxp - centerxp) / rx;
      var vy2 = (-pyp - centeryp) / ry;

      var ang1 = vectorAngle(1, 0, vx1, vy1);
      var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

      if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
      }

      if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
      }

      return [centerx, centery, ang1, ang2];
    };

    var arcToBezier = function arcToBezier(_ref2) {
      var px = _ref2.px,
          py = _ref2.py,
          cx = _ref2.cx,
          cy = _ref2.cy,
          rx = _ref2.rx,
          ry = _ref2.ry,
          _ref2$xAxisRotation = _ref2.xAxisRotation,
          xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,
          _ref2$largeArcFlag = _ref2.largeArcFlag,
          largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,
          _ref2$sweepFlag = _ref2.sweepFlag,
          sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

      var curves = [];

      if (rx === 0 || ry === 0) {
        return [];
      }

      var sinphi = Math.sin(xAxisRotation * TAU / 360);
      var cosphi = Math.cos(xAxisRotation * TAU / 360);

      var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
      var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

      if (pxp === 0 && pyp === 0) {
        return [];
      }

      rx = Math.abs(rx);
      ry = Math.abs(ry);

      var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

      if (lambda > 1) {
        rx *= Math.sqrt(lambda);
        ry *= Math.sqrt(lambda);
      }

      var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),
          _getArcCenter2 = _slicedToArray(_getArcCenter, 4),
          centerx = _getArcCenter2[0],
          centery = _getArcCenter2[1],
          ang1 = _getArcCenter2[2],
          ang2 = _getArcCenter2[3];

      // If 'ang2' == 90.0000000001, then `ratio` will evaluate to
      // 1.0000000001. This causes `segments` to be greater than one, which is an
      // unecessary split, and adds extra points to the bezier curve. To alleviate
      // this issue, we round to 1.0 when the ratio is close to 1.0.


      var ratio = Math.abs(ang2) / (TAU / 4);
      if (Math.abs(1.0 - ratio) < 0.0000001) {
        ratio = 1.0;
      }

      var segments = Math.max(Math.ceil(ratio), 1);

      ang2 /= segments;

      for (var i = 0; i < segments; i++) {
        curves.push(approxUnitArc(ang1, ang2));
        ang1 += ang2;
      }

      return curves.map(function (curve) {
        var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),
            x1 = _mapToEllipse.x,
            y1 = _mapToEllipse.y;

        var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),
            x2 = _mapToEllipse2.x,
            y2 = _mapToEllipse2.y;

        var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),
            x = _mapToEllipse3.x,
            y = _mapToEllipse3.y;

        return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
      });
    };

    /** @ignore */ /** */
    /**
     * @ignore
     */
    function checkArgs(name, actual, expected) {
        if (actual !== expected) {
            throw new Error("Required " + expected + " arguments for " + name + " but got " + actual);
        }
    }
    /**
     * @ignore
     */
    function checkMinArgs(name, actual, expected) {
        if (actual < expected) {
            throw new Error("Required at least " + expected + " arguments for " + name + " but got " + actual);
        }
    }
    /**
     * @ignore
     */
    function checkEvenArgs(name, actual, expected) {
        checkMinArgs(name, actual, expected);
        if ((actual % expected) !== 0) {
            throw new Error("Arguments for " + name + " must be in pairs of " + expected);
        }
    }
    /**
     * @ignore
     * This splits the flag so that way 0017 will be processed as 0 0 17
     *
     * This is important for weird paths like `M17 5A1 1 0 0017 30 1 1 0 0017 5`
     */
    function splitArcFlags(args) {
        for (let i = 0; i < args.length; i += 7) {
            let index = i + 3;
            let flag = args[index];
            if (flag.length > 1) {
                const a = /^([01])([01])(.*)$/.exec(flag);
                if (a !== null) {
                    args.splice(index, 0, a[1]);
                    ++index;
                    args.splice(index, 0, a[2]);
                    ++index;
                    if (a[3].length > 0) {
                        args[index] = a[3];
                    }
                    else {
                        args.splice(index, 1);
                    }
                }
            }
            ++index;
            flag = args[index];
            if (flag.length > 1) {
                const a = /^([01])(.+)$/.exec(flag);
                if (a !== null) {
                    args.splice(index, 0, a[1]);
                    ++index;
                    args[index] = a[2];
                }
            }
        }
    }
    /**
     * @ignore
     */
    function assertBinary(value) {
        if (value === 0 || value === 1) {
            return value;
        }
        else {
            throw new Error("Flag must be 0 or 1");
        }
    }
    //  1 -> 0xffffff * (2 / 2)
    //  2 -> 0xffffff * (1 / 2)
    //
    //  3 -> 0xffffff * (3 / 4)
    //  4 -> 0xffffff * (1 / 4)
    //
    //  5 -> 0xffffff * (7 / 8)
    //  6 -> 0xffffff * (5 / 8)
    //  7 -> 0xffffff * (3 / 8)
    //  8 -> 0xffffff * (1 / 8)
    //
    //  9 -> 0xffffff * (15 / 16)
    // 10 -> 0xffffff * (13 / 16)
    // 11 -> 0xffffff * (11 / 16)
    // 12 -> 0xffffff *  (9 / 16)
    // 13 -> 0xffffff *  (7 / 16)
    // 14 -> 0xffffff *  (5 / 16)
    // 15 -> 0xffffff *  (3 / 16)
    // 16 -> 0xffffff *  (1 / 16)
    // @todo remove this old color distribution algo if the new one pans out
    /*function distributeId(id: number): number {
        if (id === 1) {
            return 0x000001;

        } else {
            // Finds the closest power of 2
            const base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));

            // Translates the id into an odd fraction index
            const index = ((base - id) * 2) + 1;

            // TODO is Math.round correct ?
            return Math.round(0xffffff * (index / base));
        }
    }*/
    /**
     * Function by smeans:
     * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/
     * @ignore
     */
    function distributeId(id) {
        const rgb = [0, 0, 0];
        for (let i = 0; i < 24; i++) {
            rgb[i % 3] <<= 1;
            rgb[i % 3] |= id & 0x01;
            id >>= 1;
        }
        return (rgb[0] | 0) + (rgb[1] << 8) + (rgb[2] << 16);
    }
    /**
     * @ignore
     */
    function eachTargets(hitTarget, f) {
        for (;;) {
            if (hitTarget.interactive) {
                if (!f(hitTarget)) {
                    break;
                }
            }
            if (hitTarget._parent) {
                hitTarget = hitTarget._parent;
            }
            else {
                break;
            }
        }
    }
    // TODO feature detection for mouse/touch/pointer
    /**
     * @ignore
     */
    function onPointerEvent(element, name, f) {
        return addEventListener(element, getRendererEvent(name), (event) => {
            const target = getEventTarget(event);
            let touches = event.touches;
            if (touches) {
                if (touches.length == 0) {
                    touches = event.changedTouches;
                }
                f(copy$2(touches), target);
            }
            else {
                f([event], target);
            }
        });
    }
    /**
     * @ignore
     */
    function isTainted(image) {
        const canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const context = canvas.getContext("2d", { willReadFrequently: true });
        context.drawImage(image, 0, 0, 1, 1);
        try {
            context.getImageData(0, 0, 1, 1);
            return false;
        }
        catch (err) {
            console.warn("Image \"" + image.src + "\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors");
            return true;
        }
    }
    /**
     * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.
     *
     * @ignore
     */
    function clearCanvas(view) {
        view.width = 0;
        view.height = 0;
        view.style.width = "0px";
        view.style.height = "0px";
    }
    /**
     * Aligns the coordinate to the pixel, so it renders crisp
     *
     * @ignore
     */
    function crisp(x) {
        return Math.floor(x) + .5;
    }
    /**
     * @ignore
     */
    class CanvasPivot {
        constructor() {
            Object.defineProperty(this, "_x", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_y", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
        }
        get x() {
            return this._x;
        }
        get y() {
            return this._y;
        }
        set x(value) {
            this._x = value;
        }
        set y(value) {
            this._y = value;
        }
    }
    /**
     * @ignore
     */
    class CanvasDisplayObject extends DisposerClass {
        constructor(renderer) {
            super();
            Object.defineProperty(this, "_layer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "mask", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: null
            });
            Object.defineProperty(this, "visible", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "exportable", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "interactive", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "inactive", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: null
            });
            Object.defineProperty(this, "wheelable", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "cancelTouch", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "isMeasured", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "buttonMode", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "alpha", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "compoundAlpha", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "angle", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "scale", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "x", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "y", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "crisp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "pivot", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new CanvasPivot()
            });
            Object.defineProperty(this, "filter", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "cursorOverStyle", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_replacedCursorStyle", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_localMatrix", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new Matrix()
            });
            Object.defineProperty(this, "_matrix", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new Matrix()
            });
            // TODO can this be replaced with _localMatrix ?
            Object.defineProperty(this, "_uMatrix", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new Matrix()
            });
            Object.defineProperty(this, "_renderer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_parent", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_localBounds", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_bounds", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_colorId", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._renderer = renderer;
        }
        subStatus(status) {
            return {
                inactive: (this.inactive == null ? status.inactive : this.inactive),
                layer: this._layer || status.layer,
            };
        }
        _dispose() {
            this._renderer._removeObject(this);
            this.getLayer().dirty = true;
        }
        getCanvas() {
            return this.getLayer().view;
        }
        getLayer() {
            let self = this;
            for (;;) {
                if (self._layer) {
                    return self._layer;
                }
                else if (self._parent) {
                    self = self._parent;
                }
                else {
                    return this._renderer.defaultLayer;
                }
            }
        }
        setLayer(order, margin) {
            if (order == null) {
                this._layer = undefined;
            }
            else {
                const visible = true;
                this._layer = this._renderer.getLayer(order, visible);
                this._layer.visible = visible;
                this._layer.margin = margin;
                if (margin) {
                    setInteractive(this._layer.view, false);
                }
                this._renderer._ghostLayer.setMargin(this._renderer.layers);
                if (this._parent) {
                    this._parent.registerChildLayer(this._layer);
                }
                this._layer.dirty = true;
                this._renderer.resizeLayer(this._layer);
                this._renderer.resizeGhost();
            }
        }
        markDirtyLayer() {
            this.getLayer().dirty = true;
        }
        clear() {
            this.invalidateBounds();
        }
        invalidateBounds() {
            this._localBounds = undefined;
        }
        _addBounds(_bounds) { }
        _getColorId() {
            if (this._colorId === undefined) {
                this._colorId = this._renderer.paintId(this);
            }
            return this._colorId;
        }
        _isInteractive(status) {
            return !status.inactive && (this.interactive || this._renderer._forceInteractive > 0);
        }
        _isInteractiveMask(status) {
            return this._isInteractive(status);
        }
        contains(child) {
            for (;;) {
                if (child === this) {
                    return true;
                }
                else if (child._parent) {
                    child = child._parent;
                }
                else {
                    return false;
                }
            }
        }
        toGlobal(point) {
            return this._matrix.apply(point);
        }
        toLocal(point) {
            return this._matrix.applyInverse(point);
        }
        getLocalMatrix() {
            this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);
            return this._uMatrix;
        }
        getLocalBounds() {
            if (!this._localBounds) {
                const bn = 10000000;
                this._localBounds = {
                    left: bn,
                    top: bn,
                    right: -bn,
                    bottom: -bn
                };
                this._addBounds(this._localBounds);
            }
            return this._localBounds;
        }
        getAdjustedBounds(bounds) {
            this._setMatrix();
            const matrix = this.getLocalMatrix();
            const p0 = matrix.apply({ x: bounds.left, y: bounds.top });
            const p1 = matrix.apply({ x: bounds.right, y: bounds.top });
            const p2 = matrix.apply({ x: bounds.right, y: bounds.bottom });
            const p3 = matrix.apply({ x: bounds.left, y: bounds.bottom });
            return {
                left: Math.min(p0.x, p1.x, p2.x, p3.x),
                top: Math.min(p0.y, p1.y, p2.y, p3.y),
                right: Math.max(p0.x, p1.x, p2.x, p3.x),
                bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
            };
        }
        on(key, callback, context) {
            if (this.interactive) {
                return this._renderer._addEvent(this, key, callback, context);
            }
            else {
                return new Disposer(() => { });
            }
        }
        _setMatrix() {
            // TODO only calculate this if it has actually changed
            this._localMatrix.setTransform(this.x, this.y, this.pivot.x, this.pivot.y, 
            // Converts degrees to radians
            this.angle * Math.PI / 180, this.scale);
            this._matrix.copyFrom(this._localMatrix);
            if (this._parent) {
                // TODO only calculate this if it has actually changed
                this._matrix.prepend(this._parent._matrix);
            }
        }
        _transform(context, resolution) {
            const m = this._matrix;
            let tx = m.tx * resolution;
            let ty = m.ty * resolution;
            if (this.crisp) {
                tx = crisp(tx);
                ty = crisp(ty);
            }
            context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, tx, ty);
        }
        _transformMargin(context, resolution, margin) {
            const m = this._matrix;
            context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, (m.tx + margin.left) * resolution, (m.ty + margin.top) * resolution);
        }
        _transformLayer(context, resolution, layer) {
            if (layer.margin) {
                this._transformMargin(context, layer.scale || resolution, layer.margin);
            }
            else {
                this._transform(context, layer.scale || resolution);
            }
        }
        render(status) {
            if (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {
                this._setMatrix();
                const subStatus = this.subStatus(status);
                const resolution = this._renderer.resolution;
                const layers = this._renderer.layers;
                const ghostLayer = this._renderer._ghostLayer;
                const ghostContext = ghostLayer.context;
                const mask = this.mask;
                if (mask) {
                    mask._setMatrix();
                }
                // TODO improve this
                each$1(layers, (layer) => {
                    if (layer) {
                        const context = layer.context;
                        context.save();
                        // We must apply the mask before we transform the element
                        if (mask) {
                            mask._transformLayer(context, resolution, layer);
                            mask._runPath(context);
                            context.clip();
                        }
                        context.globalAlpha = this.compoundAlpha * this.alpha;
                        this._transformLayer(context, resolution, layer);
                        if (this.filter) {
                            context.filter = this.filter;
                        }
                    }
                });
                ghostContext.save();
                // We must apply the mask before we transform the element
                if (mask && this._isInteractiveMask(subStatus)) {
                    mask._transformMargin(ghostContext, resolution, ghostLayer.margin);
                    mask._runPath(ghostContext);
                    ghostContext.clip();
                }
                this._transformMargin(ghostContext, resolution, ghostLayer.margin);
                this._render(subStatus);
                ghostContext.restore();
                each$1(layers, (layer) => {
                    if (layer) {
                        layer.context.restore();
                    }
                });
            }
        }
        _render(status) {
            if (this.exportable === false) {
                status.layer.tainted = true;
            }
        }
        hovering() {
            return this._renderer._hovering.has(this);
        }
        dragging() {
            return this._renderer._dragging.some((x) => x.value === this);
        }
        shouldCancelTouch() {
            const renderer = this._renderer;
            if (renderer.tapToActivate && !renderer._touchActive) {
                return false;
            }
            if (this.cancelTouch) {
                return true;
            }
            else if (this._parent) {
                return this._parent.shouldCancelTouch();
            }
            return false;
        }
    }
    /**
     * @ignore
     */
    class CanvasContainer extends CanvasDisplayObject {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "interactiveChildren", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "_childLayers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_children", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
        }
        _isInteractiveMask(status) {
            return this.interactiveChildren || super._isInteractiveMask(status);
        }
        addChild(child) {
            child._parent = this;
            this._children.push(child);
            if (child._layer) {
                this.registerChildLayer(child._layer);
            }
        }
        addChildAt(child, index) {
            child._parent = this;
            this._children.splice(index, 0, child);
            if (child._layer) {
                this.registerChildLayer(child._layer);
            }
        }
        removeChild(child) {
            child._parent = undefined;
            removeFirst(this._children, child);
        }
        _render(status) {
            super._render(status);
            const renderer = this._renderer;
            if (this.interactive && this.interactiveChildren) {
                ++renderer._forceInteractive;
            }
            each$1(this._children, (child) => {
                child.compoundAlpha = this.compoundAlpha * this.alpha;
                child.render(status);
            });
            if (this.interactive && this.interactiveChildren) {
                --renderer._forceInteractive;
            }
        }
        registerChildLayer(layer) {
            if (!this._childLayers) {
                this._childLayers = [];
            }
            pushOne(this._childLayers, layer);
            if (this._parent) {
                this._parent.registerChildLayer(layer);
            }
        }
        markDirtyLayer(deep = false) {
            super.markDirtyLayer();
            if (deep && this._childLayers) {
                each$1(this._childLayers, (layer) => layer.dirty = true);
            }
        }
        _dispose() {
            super._dispose();
            if (this._childLayers) {
                each$1(this._childLayers, (layer) => {
                    layer.dirty = true;
                });
            }
        }
    }
    /**
     * @ignore
     */
    function setPoint(bounds, point) {
        bounds.left = Math.min(bounds.left, point.x);
        bounds.top = Math.min(bounds.top, point.y);
        bounds.right = Math.max(bounds.right, point.x);
        bounds.bottom = Math.max(bounds.bottom, point.y);
    }
    /**
     * @ignore
     */
    class Op {
        colorize(_context, _forceColor) { }
        colorizeGhost(context, forceColor) {
            this.colorize(context, forceColor);
        }
        path(_context) { }
        pathGhost(context) {
            this.path(context);
        }
        addBounds(_bounds) { }
    }
    /**
     * @ignore
     */
    class BeginPath extends Op {
        colorize(context, _forceColor) {
            context.beginPath();
        }
    }
    /**
     * @ignore
     */
    class BeginFill extends Op {
        constructor(color) {
            super();
            Object.defineProperty(this, "color", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: color
            });
        }
        colorize(context, forceColor) {
            if (forceColor !== undefined) {
                context.fillStyle = forceColor;
            }
            else {
                context.fillStyle = this.color;
            }
        }
    }
    /**
     * @ignore
     */
    class EndFill extends Op {
        constructor(clearShadow) {
            super();
            Object.defineProperty(this, "clearShadow", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: clearShadow
            });
        }
        colorize(context, _forceColor) {
            context.fill();
            if (this.clearShadow) {
                context.shadowColor = "";
                context.shadowBlur = 0;
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 0;
            }
        }
    }
    /**
     * @ignore
     */
    class EndStroke extends Op {
        colorize(context, _forceColor) {
            context.stroke();
        }
    }
    /**
     * @ignore
     */
    class LineStyle extends Op {
        constructor(width, color, lineJoin) {
            super();
            Object.defineProperty(this, "width", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: width
            });
            Object.defineProperty(this, "color", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: color
            });
            Object.defineProperty(this, "lineJoin", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: lineJoin
            });
        }
        colorize(context, forceColor) {
            if (forceColor !== undefined) {
                context.strokeStyle = forceColor;
            }
            else {
                context.strokeStyle = this.color;
            }
            context.lineWidth = this.width;
            if (this.lineJoin) {
                context.lineJoin = this.lineJoin;
            }
        }
    }
    /**
     * @ignore
     */
    class LineDash extends Op {
        constructor(dash) {
            super();
            Object.defineProperty(this, "dash", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: dash
            });
        }
        colorize(context, _forceColor) {
            context.setLineDash(this.dash);
        }
    }
    /**
     * @ignore
     */
    class LineDashOffset extends Op {
        constructor(dashOffset) {
            super();
            Object.defineProperty(this, "dashOffset", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: dashOffset
            });
        }
        colorize(context, _forceColor) {
            context.lineDashOffset = this.dashOffset;
        }
    }
    /**
     * @ignore
     */
    class DrawRect extends Op {
        constructor(x, y, width, height) {
            super();
            Object.defineProperty(this, "x", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: x
            });
            Object.defineProperty(this, "y", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: y
            });
            Object.defineProperty(this, "width", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: width
            });
            Object.defineProperty(this, "height", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: height
            });
        }
        path(context) {
            context.rect(this.x, this.y, this.width, this.height);
        }
        addBounds(bounds) {
            const l = this.x;
            const t = this.y;
            const r = l + this.width;
            const b = t + this.height;
            setPoint(bounds, { x: l, y: t });
            setPoint(bounds, { x: r, y: t });
            setPoint(bounds, { x: l, y: b });
            setPoint(bounds, { x: r, y: b });
        }
    }
    /**
     * @ignore
     */
    class DrawCircle extends Op {
        constructor(x, y, radius) {
            super();
            Object.defineProperty(this, "x", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: x
            });
            Object.defineProperty(this, "y", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: y
            });
            Object.defineProperty(this, "radius", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: radius
            });
        }
        path(context) {
            context.moveTo(this.x + this.radius, this.y);
            context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        }
        // TODO handle skewing and rotation
        addBounds(bounds) {
            setPoint(bounds, { x: this.x - this.radius, y: this.y - this.radius });
            setPoint(bounds, { x: this.x + this.radius, y: this.y + this.radius });
        }
    }
    /**
     * @ignore
     */
    class DrawEllipse extends Op {
        constructor(x, y, radiusX, radiusY) {
            super();
            Object.defineProperty(this, "x", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: x
            });
            Object.defineProperty(this, "y", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: y
            });
            Object.defineProperty(this, "radiusX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: radiusX
            });
            Object.defineProperty(this, "radiusY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: radiusY
            });
        }
        path(context) {
            context.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);
        }
        // TODO handle skewing and rotation
        addBounds(bounds) {
            setPoint(bounds, { x: this.x - this.radiusX, y: this.y - this.radiusY });
            setPoint(bounds, { x: this.x + this.radiusX, y: this.y + this.radiusY });
        }
    }
    /**
     * @ignore
     */
    class Arc extends Op {
        constructor(cx, cy, radius, startAngle, endAngle, anticlockwise) {
            super();
            Object.defineProperty(this, "cx", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: cx
            });
            Object.defineProperty(this, "cy", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: cy
            });
            Object.defineProperty(this, "radius", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: radius
            });
            Object.defineProperty(this, "startAngle", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: startAngle
            });
            Object.defineProperty(this, "endAngle", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: endAngle
            });
            Object.defineProperty(this, "anticlockwise", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: anticlockwise
            });
        }
        path(context) {
            if (this.radius > 0) {
                context.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
            }
        }
        addBounds(bounds) {
            let arcBounds = getArcBounds(this.cx, this.cy, this.startAngle * DEGREES, this.endAngle * DEGREES, this.radius);
            setPoint(bounds, { x: arcBounds.left, y: arcBounds.top });
            setPoint(bounds, { x: arcBounds.right, y: arcBounds.bottom });
        }
    }
    /**
     * @ignore
     */
    class ArcTo extends Op {
        constructor(x1, y1, x2, y2, radius) {
            super();
            Object.defineProperty(this, "x1", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: x1
            });
            Object.defineProperty(this, "y1", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: y1
            });
            Object.defineProperty(this, "x2", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: x2
            });
            Object.defineProperty(this, "y2", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: y2
            });
            Object.defineProperty(this, "radius", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: radius
            });
        }
        path(context) {
            if (this.radius > 0) {
                context.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);
            }
        }
        // TODO: add points
        addBounds(_bounds) {
            /*
            // not finished
            https://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically

            if (prevPoint) {
                let x1 = prevPoint.x;
                let y1 = prevPoint.y;
                let x2 = this.x2;
                let y2 = this.y2;
                let r = this.radius;

                let xa = (x2 - x1) / 2;
                let ya = (y2 - y1) / 2;

                let x0 = x1 + xa;
                let y0 = y1 + ya;

                let a = Math.hypot(xa, ya);
                let b = Math.sqrt(r * r - a * a);

                let cx = x0 + b * ya / a;
                let cy = y0 - b * xa / a;

                console.log(cx, cy);
            }*/
        }
    }
    /**
     * @ignore
     */
    class LineTo extends Op {
        constructor(x, y) {
            super();
            Object.defineProperty(this, "x", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: x
            });
            Object.defineProperty(this, "y", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: y
            });
        }
        path(context) {
            context.lineTo(this.x, this.y);
        }
        addBounds(bounds) {
            setPoint(bounds, { x: this.x, y: this.y });
        }
    }
    /**
     * @ignore
     */
    class MoveTo extends Op {
        constructor(x, y) {
            super();
            Object.defineProperty(this, "x", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: x
            });
            Object.defineProperty(this, "y", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: y
            });
        }
        path(context) {
            context.moveTo(this.x, this.y);
        }
        addBounds(bounds) {
            setPoint(bounds, { x: this.x, y: this.y });
        }
    }
    /**
     * @ignore
     */
    class ClosePath extends Op {
        path(context) {
            context.closePath();
        }
    }
    /**
     * @ignore
     */
    class BezierCurveTo extends Op {
        constructor(cpX, cpY, cpX2, cpY2, toX, toY) {
            super();
            Object.defineProperty(this, "cpX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: cpX
            });
            Object.defineProperty(this, "cpY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: cpY
            });
            Object.defineProperty(this, "cpX2", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: cpX2
            });
            Object.defineProperty(this, "cpY2", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: cpY2
            });
            Object.defineProperty(this, "toX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: toX
            });
            Object.defineProperty(this, "toY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: toY
            });
        }
        path(context) {
            context.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);
        }
        // TODO: OK?
        addBounds(bounds) {
            setPoint(bounds, { x: this.cpX, y: this.cpY });
            setPoint(bounds, { x: this.cpX2, y: this.cpY2 });
            setPoint(bounds, { x: this.toX, y: this.toY });
        }
    }
    /**
     * @ignore
     */
    class QuadraticCurveTo extends Op {
        constructor(cpX, cpY, toX, toY) {
            super();
            Object.defineProperty(this, "cpX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: cpX
            });
            Object.defineProperty(this, "cpY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: cpY
            });
            Object.defineProperty(this, "toX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: toX
            });
            Object.defineProperty(this, "toY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: toY
            });
        }
        path(context) {
            context.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);
        }
        // TODO: OK?
        addBounds(bounds) {
            setPoint(bounds, { x: this.cpX, y: this.cpY });
            setPoint(bounds, { x: this.toX, y: this.toY });
        }
    }
    /**
     * @ignore
     */
    class Shadow extends Op {
        constructor(color, blur, offsetX, offsetY, opacity) {
            super();
            Object.defineProperty(this, "color", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: color
            });
            Object.defineProperty(this, "blur", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: blur
            });
            Object.defineProperty(this, "offsetX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: offsetX
            });
            Object.defineProperty(this, "offsetY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: offsetY
            });
            Object.defineProperty(this, "opacity", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: opacity
            });
        }
        colorize(context, _forceColor) {
            if (this.opacity) {
                context.fillStyle = this.color;
            }
            context.shadowColor = this.color;
            context.shadowBlur = this.blur;
            context.shadowOffsetX = this.offsetX;
            context.shadowOffsetY = this.offsetY;
        }
        colorizeGhost(_context, _forceColor) { }
    }
    /**
     * @ignore
     */
    class GraphicsImage extends Op {
        constructor(image, width, height, x, y) {
            super();
            Object.defineProperty(this, "image", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: image
            });
            Object.defineProperty(this, "width", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: width
            });
            Object.defineProperty(this, "height", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: height
            });
            Object.defineProperty(this, "x", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: x
            });
            Object.defineProperty(this, "y", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: y
            });
        }
        path(context) {
            context.drawImage(this.image, this.x, this.y, this.width, this.height);
        }
        // TODO: OK?
        addBounds(bounds) {
            setPoint(bounds, { x: this.x, y: this.y });
            setPoint(bounds, { x: this.width, y: this.height });
        }
    }
    /**
     * @ignore
     */
    class CanvasGraphics extends CanvasDisplayObject {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_operations", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "blendMode", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: BlendMode.NORMAL
            });
            Object.defineProperty(this, "_hasShadows", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_fillAlpha", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_strokeAlpha", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        clear() {
            super.clear();
            this._operations.length = 0;
        }
        _pushOp(op) {
            this._operations.push(op);
        }
        beginFill(color, alpha = 1) {
            this._fillAlpha = alpha;
            if (color) {
                if (color instanceof Color) {
                    this._pushOp(new BeginFill(color.toCSS(alpha)));
                }
                else {
                    this.isMeasured = true;
                    this._pushOp(new BeginFill(color));
                }
            }
            else {
                this._pushOp(new BeginFill("rgba(0, 0, 0, " + alpha + ")"));
            }
        }
        endFill() {
            this._pushOp(new EndFill(this._hasShadows));
        }
        endStroke() {
            this._pushOp(new EndStroke());
        }
        beginPath() {
            this._pushOp(new BeginPath());
        }
        lineStyle(width = 0, color, alpha = 1, lineJoin) {
            this._strokeAlpha = alpha;
            if (color) {
                if (color instanceof Color) {
                    this._pushOp(new LineStyle(width, color.toCSS(alpha), lineJoin));
                }
                else {
                    this._pushOp(new LineStyle(width, color, lineJoin));
                }
            }
            else {
                this._pushOp(new LineStyle(width, "rgba(0, 0, 0, " + alpha + ")", lineJoin));
            }
        }
        setLineDash(dash) {
            this._pushOp(new LineDash(dash ? dash : []));
        }
        setLineDashOffset(dashOffset = 0) {
            this._pushOp(new LineDashOffset(dashOffset));
        }
        drawRect(x, y, width, height) {
            this._pushOp(new DrawRect(x, y, width, height));
        }
        drawCircle(x, y, radius) {
            this._pushOp(new DrawCircle(x, y, radius));
        }
        drawEllipse(x, y, radiusX, radiusY) {
            this._pushOp(new DrawEllipse(x, y, radiusX, radiusY));
        }
        arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
            this._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));
        }
        arcTo(x1, y1, x2, y2, radius) {
            this._pushOp(new ArcTo(x1, y1, x2, y2, radius));
        }
        lineTo(x, y) {
            this._pushOp(new LineTo(x, y));
        }
        moveTo(x, y) {
            this._pushOp(new MoveTo(x, y));
        }
        bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
            this._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));
        }
        quadraticCurveTo(cpX, cpY, toX, toY) {
            this._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));
        }
        closePath() {
            this._pushOp(new ClosePath());
        }
        shadow(color, blur = 0, offsetX = 0, offsetY = 0, opacity) {
            this._hasShadows = true;
            this._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));
        }
        image(image, width, height, x, y) {
            this._pushOp(new GraphicsImage(image, width, height, x, y));
        }
        // https://svgwg.org/svg2-draft/paths.html#DProperty
        // TODO better error checking
        svgPath(path) {
            let x = 0;
            let y = 0;
            let cpx = null;
            let cpy = null;
            let qcpx = null;
            let qcpy = null;
            const SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;
            const ARGS_REGEXP = /[\u0009\u0020\u000A\u000C\u000D]*([\+\-]?[0-9]*\.?[0-9]+(?:[eE][\+\-]?[0-9]+)?)[\u0009\u0020\u000A\u000C\u000D]*,?/g;
            let match;
            while ((match = SEGMENTS_REGEXP.exec(path)) !== null) {
                const name = match[1];
                const rest = match[2];
                const args = [];
                while ((match = ARGS_REGEXP.exec(rest)) !== null) {
                    args.push(match[1]);
                }
                // Reset control point
                if (name !== "S" && name !== "s" && name !== "C" && name !== "c") {
                    cpx = null;
                    cpy = null;
                }
                // Reset control point
                if (name !== "Q" && name !== "q" && name !== "T" && name !== "t") {
                    qcpx = null;
                    qcpy = null;
                }
                switch (name) {
                    case "M":
                        checkEvenArgs(name, args.length, 2);
                        x = +args[0];
                        y = +args[1];
                        this.moveTo(x, y);
                        for (let i = 2; i < args.length; i += 2) {
                            x = +args[i];
                            y = +args[i + 1];
                            this.lineTo(x, y);
                        }
                        break;
                    case "m":
                        checkEvenArgs(name, args.length, 2);
                        x += +args[0];
                        y += +args[1];
                        this.moveTo(x, y);
                        for (let i = 2; i < args.length; i += 2) {
                            x += +args[i];
                            y += +args[i + 1];
                            this.lineTo(x, y);
                        }
                        break;
                    case "L":
                        checkEvenArgs(name, args.length, 2);
                        for (let i = 0; i < args.length; i += 2) {
                            x = +args[i];
                            y = +args[i + 1];
                            this.lineTo(x, y);
                        }
                        break;
                    case "l":
                        checkEvenArgs(name, args.length, 2);
                        for (let i = 0; i < args.length; i += 2) {
                            x += +args[i];
                            y += +args[i + 1];
                            this.lineTo(x, y);
                        }
                        break;
                    case "H":
                        checkMinArgs(name, args.length, 1);
                        for (let i = 0; i < args.length; ++i) {
                            x = +args[i];
                            this.lineTo(x, y);
                        }
                        break;
                    case "h":
                        checkMinArgs(name, args.length, 1);
                        for (let i = 0; i < args.length; ++i) {
                            x += +args[i];
                            this.lineTo(x, y);
                        }
                        break;
                    case "V":
                        checkMinArgs(name, args.length, 1);
                        for (let i = 0; i < args.length; ++i) {
                            y = +args[i];
                            this.lineTo(x, y);
                        }
                        break;
                    case "v":
                        checkMinArgs(name, args.length, 1);
                        for (let i = 0; i < args.length; ++i) {
                            y += +args[i];
                            this.lineTo(x, y);
                        }
                        break;
                    case "C":
                        checkEvenArgs(name, args.length, 6);
                        for (let i = 0; i < args.length; i += 6) {
                            const x1 = +args[i];
                            const y1 = +args[i + 1];
                            cpx = +args[i + 2];
                            cpy = +args[i + 3];
                            x = +args[i + 4];
                            y = +args[i + 5];
                            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                        }
                        break;
                    case "c":
                        checkEvenArgs(name, args.length, 6);
                        for (let i = 0; i < args.length; i += 6) {
                            const x1 = +args[i] + x;
                            const y1 = +args[i + 1] + y;
                            cpx = +args[i + 2] + x;
                            cpy = +args[i + 3] + y;
                            x += +args[i + 4];
                            y += +args[i + 5];
                            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                        }
                        break;
                    case "S":
                        checkEvenArgs(name, args.length, 4);
                        if (cpx === null || cpy === null) {
                            cpx = x;
                            cpy = y;
                        }
                        for (let i = 0; i < args.length; i += 4) {
                            const x1 = 2 * x - cpx;
                            const y1 = 2 * y - cpy;
                            cpx = +args[i];
                            cpy = +args[i + 1];
                            x = +args[i + 2];
                            y = +args[i + 3];
                            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                        }
                        break;
                    case "s":
                        checkEvenArgs(name, args.length, 4);
                        if (cpx === null || cpy === null) {
                            cpx = x;
                            cpy = y;
                        }
                        for (let i = 0; i < args.length; i += 4) {
                            const x1 = 2 * x - cpx;
                            const y1 = 2 * y - cpy;
                            cpx = +args[i] + x;
                            cpy = +args[i + 1] + y;
                            x += +args[i + 2];
                            y += +args[i + 3];
                            this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                        }
                        break;
                    case "Q":
                        checkEvenArgs(name, args.length, 4);
                        for (let i = 0; i < args.length; i += 4) {
                            qcpx = +args[i];
                            qcpy = +args[i + 1];
                            x = +args[i + 2];
                            y = +args[i + 3];
                            this.quadraticCurveTo(qcpx, qcpy, x, y);
                        }
                        break;
                    case "q":
                        checkEvenArgs(name, args.length, 4);
                        for (let i = 0; i < args.length; i += 4) {
                            qcpx = +args[i] + x;
                            qcpy = +args[i + 1] + y;
                            x += +args[i + 2];
                            y += +args[i + 3];
                            this.quadraticCurveTo(qcpx, qcpy, x, y);
                        }
                        break;
                    case "T":
                        checkEvenArgs(name, args.length, 2);
                        if (qcpx === null || qcpy === null) {
                            qcpx = x;
                            qcpy = y;
                        }
                        for (let i = 0; i < args.length; i += 2) {
                            qcpx = 2 * x - qcpx;
                            qcpy = 2 * y - qcpy;
                            x = +args[i];
                            y = +args[i + 1];
                            this.quadraticCurveTo(qcpx, qcpy, x, y);
                        }
                        break;
                    case "t":
                        checkEvenArgs(name, args.length, 2);
                        if (qcpx === null || qcpy === null) {
                            qcpx = x;
                            qcpy = y;
                        }
                        for (let i = 0; i < args.length; i += 2) {
                            qcpx = 2 * x - qcpx;
                            qcpy = 2 * y - qcpy;
                            x += +args[i];
                            y += +args[i + 1];
                            this.quadraticCurveTo(qcpx, qcpy, x, y);
                        }
                        break;
                    case "A":
                    case "a":
                        const relative = (name === "a");
                        splitArcFlags(args);
                        checkEvenArgs(name, args.length, 7);
                        for (let i = 0; i < args.length; i += 7) {
                            let cx = +args[i + 5];
                            let cy = +args[i + 6];
                            if (relative) {
                                cx += x;
                                cy += y;
                            }
                            const bs = arcToBezier({
                                px: x,
                                py: y,
                                rx: +args[i],
                                ry: +args[i + 1],
                                xAxisRotation: +args[i + 2],
                                largeArcFlag: assertBinary(+args[i + 3]),
                                sweepFlag: assertBinary(+args[i + 4]),
                                cx,
                                cy,
                            });
                            each$1(bs, (b) => {
                                this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);
                                x = b.x;
                                y = b.y;
                            });
                        }
                        break;
                    case "Z":
                    case "z":
                        checkArgs(name, args.length, 0);
                        this.closePath();
                        break;
                }
            }
        }
        _runPath(context) {
            context.beginPath();
            each$1(this._operations, (op) => {
                op.path(context);
            });
        }
        _render(status) {
            super._render(status);
            const layerDirty = status.layer.dirty;
            const interactive = this._isInteractive(status);
            if (layerDirty || interactive) {
                const context = status.layer.context;
                const ghostContext = this._renderer._ghostLayer.context;
                if (layerDirty) {
                    context.globalCompositeOperation = this.blendMode;
                    context.beginPath();
                }
                let color;
                if (interactive) {
                    ghostContext.beginPath();
                    color = this._getColorId();
                }
                each$1(this._operations, (op) => {
                    if (layerDirty) {
                        op.path(context);
                        op.colorize(context, undefined);
                    }
                    if (interactive) {
                        op.pathGhost(ghostContext);
                        op.colorizeGhost(ghostContext, color);
                    }
                });
            }
        }
        renderDetached(context) {
            if (this.visible) {
                this._setMatrix();
                context.save();
                // We must apply the mask before we transform the element
                const mask = this.mask;
                if (mask) {
                    mask._setMatrix();
                    mask._transform(context, 1);
                    mask._runPath(context);
                    context.clip();
                }
                // TODO handle compoundAlpha somehow ?
                context.globalAlpha = this.compoundAlpha * this.alpha;
                this._transform(context, 1);
                if (this.filter) {
                    context.filter = this.filter;
                }
                context.globalCompositeOperation = this.blendMode;
                context.beginPath();
                each$1(this._operations, (op) => {
                    op.path(context);
                    op.colorize(context, undefined);
                });
                context.restore();
            }
        }
        _addBounds(bounds) {
            if (this.visible && this.isMeasured) {
                each$1(this._operations, (op) => {
                    op.addBounds(bounds);
                });
            }
        }
    }
    /**
     * @ignore
     */
    class CanvasText extends CanvasDisplayObject {
        constructor(renderer, text, style) {
            super(renderer);
            Object.defineProperty(this, "text", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "style", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "resolution", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "textVisible", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "_textInfo", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_originalScale", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            this.text = text;
            this.style = style;
        }
        invalidateBounds() {
            super.invalidateBounds();
            this._textInfo = undefined;
        }
        _shared(context) {
            if (this.style.textAlign) {
                context.textAlign = this.style.textAlign;
            }
            if (this.style.direction) {
                context.direction = this.style.direction;
            }
            if (this.style.textBaseline) {
                context.textBaseline = this.style.textBaseline;
            }
        }
        _prerender(status, ignoreGhost = false, ignoreFontWeight = false) {
            super._render(status);
            const context = status.layer.context;
            const ghostContext = this._renderer._ghostLayer.context;
            // Font style
            const style = this.style;
            let fontStyle = this._getFontStyle(undefined, ignoreFontWeight);
            context.font = fontStyle;
            if (this._isInteractive(status) && !ignoreGhost) {
                ghostContext.font = fontStyle;
            }
            // Other parameters
            if (style.fill) {
                if (style.fill instanceof Color) {
                    context.fillStyle = style.fill.toCSS(style.fillOpacity != undefined ? style.fillOpacity : 1);
                }
                else {
                    context.fillStyle = style.fill;
                }
            }
            if (style.shadowColor) {
                status.layer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);
            }
            if (style.shadowBlur) {
                status.layer.context.shadowBlur = style.shadowBlur;
            }
            if (style.shadowOffsetX) {
                status.layer.context.shadowOffsetX = style.shadowOffsetX;
            }
            if (style.shadowOffsetY) {
                status.layer.context.shadowOffsetY = style.shadowOffsetY;
            }
            this._shared(context);
            if (this._isInteractive(status) && !ignoreGhost) {
                ghostContext.fillStyle = this._getColorId();
                this._shared(ghostContext);
            }
        }
        _getFontStyle(style2, ignoreFontWeight = false) {
            // Process defaults
            const style = this.style;
            let fontStyle = [];
            if (style2 && style2.fontVariant) {
                fontStyle.push(style2.fontVariant);
            }
            else if (style.fontVariant) {
                fontStyle.push(style.fontVariant);
            }
            if (!ignoreFontWeight) {
                if (style2 && style2.fontWeight) {
                    fontStyle.push(style2.fontWeight);
                }
                else if (style.fontWeight) {
                    fontStyle.push(style.fontWeight);
                }
            }
            if (style2 && style2.fontStyle) {
                fontStyle.push(style2.fontStyle);
            }
            else if (style.fontStyle) {
                fontStyle.push(style.fontStyle);
            }
            if (style2 && style2.fontSize) {
                if (isNumber(style2.fontSize)) {
                    style2.fontSize = style2.fontSize + "px";
                }
                fontStyle.push(style2.fontSize);
            }
            else if (style.fontSize) {
                if (isNumber(style.fontSize)) {
                    style.fontSize = style.fontSize + "px";
                }
                fontStyle.push(style.fontSize);
            }
            if (style2 && style2.fontFamily) {
                fontStyle.push(style2.fontFamily);
            }
            else if (style.fontFamily) {
                fontStyle.push(style.fontFamily);
            }
            else if (fontStyle.length) {
                fontStyle.push("Arial");
            }
            return fontStyle.join(" ");
        }
        _render(status) {
            // We need measurements in order to properly position text for alignment
            if (!this._textInfo) {
                this._measure(status);
            }
            if (this.textVisible) {
                const interactive = this._isInteractive(status);
                const context = status.layer.context;
                const layerDirty = status.layer.dirty;
                const ghostContext = this._renderer._ghostLayer.context;
                context.save();
                ghostContext.save();
                this._prerender(status);
                // const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
                // const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;
                // Process text info produced by _measure()
                each$1(this._textInfo, (line, _index) => {
                    each$1(line.textChunks, (chunk, _index) => {
                        // Set style
                        if (chunk.style) {
                            context.save();
                            ghostContext.save();
                            context.font = chunk.style;
                            if (this._isInteractive(status)) {
                                ghostContext.font = chunk.style;
                            }
                        }
                        if (chunk.fill) {
                            context.save();
                            context.fillStyle = chunk.fill.toCSS();
                            // Color does not affect ghostContext so we not set it
                        }
                        // Draw text
                        if (layerDirty) {
                            context.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);
                        }
                        // Draw underline
                        if (chunk.textDecoration == "underline" || chunk.textDecoration == "line-through") {
                            let thickness = 1;
                            let offset = 1;
                            let fontSize = chunk.height;
                            const oversizedBehavior = this.style.oversizedBehavior || "";
                            if (["truncate", "wrap", "wrap-no-break"].indexOf(oversizedBehavior) > -1) {
                                // Measure actual width of the text so the line fits
                                const metrics = this._measureText(chunk.text, context);
                                chunk.width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
                            }
                            let offsetX = chunk.offsetX;
                            switch (this.style.textAlign) {
                                case "right":
                                case "end":
                                    offsetX -= chunk.width;
                                    break;
                                case "center":
                                    offsetX -= chunk.width / 2;
                                    break;
                            }
                            if (chunk.style) {
                                const format = TextFormatter.getTextStyle(chunk.style);
                                switch (format.fontWeight) {
                                    case "bolder":
                                    case "bold":
                                    case "700":
                                    case "800":
                                    case "900":
                                        thickness = 2;
                                        break;
                                }
                            }
                            if (fontSize) {
                                offset = fontSize / 20;
                            }
                            let y;
                            if (chunk.textDecoration == "line-through") {
                                y = thickness + line.offsetY + chunk.offsetY - chunk.height / 2;
                            }
                            else {
                                y = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;
                            }
                            context.save();
                            context.beginPath();
                            if (chunk.fill) {
                                context.strokeStyle = chunk.fill.toCSS();
                            }
                            else if (this.style.fill && this.style.fill instanceof Color) {
                                context.strokeStyle = this.style.fill.toCSS();
                            }
                            context.lineWidth = thickness * offset;
                            context.moveTo(offsetX, y);
                            context.lineTo(offsetX + chunk.width, y);
                            context.stroke();
                            context.restore();
                        }
                        if (interactive && this.interactive) {
                            // Draw text in ghost canvas ONLY if it is set as interactive
                            // explicitly. This way we avoid hit test anomalies caused by anti
                            // aliasing of text.
                            ghostContext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);
                        }
                        if (chunk.fill) {
                            context.restore();
                            // Color does not affect ghostContext so we not set it
                        }
                        // Reset style
                        if (chunk.style) {
                            context.restore();
                            ghostContext.restore();
                        }
                    });
                });
                context.restore();
                ghostContext.restore();
            }
        }
        _addBounds(bounds) {
            if (this.visible && this.isMeasured) {
                //if (this._textVisible) {
                const x = this._measure({
                    inactive: this.inactive,
                    layer: this.getLayer(),
                });
                setPoint(bounds, { x: x.left, y: x.top });
                setPoint(bounds, { x: x.right, y: x.bottom });
                //}
            }
        }
        _ignoreFontWeight() {
            return /apple/i.test(navigator.vendor);
        }
        _measure(status) {
            const context = status.layer.context;
            const ghostContext = this._renderer._ghostLayer.context;
            const rtl = this.style.direction == "rtl";
            // Reset text info
            this._textInfo = [];
            // Init
            const oversizedBehavior = this.style.oversizedBehavior;
            const maxWidth = this.style.maxWidth;
            const truncate = isNumber(maxWidth) && oversizedBehavior == "truncate";
            const wrap = isNumber(maxWidth) && (oversizedBehavior == "wrap" || oversizedBehavior == "wrap-no-break");
            // Pre-render
            context.save();
            ghostContext.save();
            this._prerender(status, true, this._ignoreFontWeight());
            // Get default font metrix
            const refText = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
            // Split up text into lines
            const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
            let styleRestored = true;
            let minX = 0;
            let maxX = 0;
            // Iterate through the lines
            let offsetY = 0;
            let currentStyle;
            each$1(lines, (line, _index) => {
                // Split up line into format/value chunks
                let chunks;
                if (line == "") {
                    chunks = [{
                            type: "value",
                            text: ""
                        }];
                }
                else {
                    chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);
                }
                while (chunks.length > 0) {
                    // Init line object
                    let lineInfo = {
                        offsetY: offsetY,
                        ascent: 0,
                        width: 0,
                        height: 0,
                        left: 0,
                        right: 0,
                        textChunks: []
                    };
                    // Measure reference text
                    const metrics = this._measureText(refText, context);
                    const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                    lineInfo.height = height;
                    lineInfo.ascent = metrics.actualBoundingBoxAscent;
                    let currentFormat;
                    let currentDecoration = this.style.textDecoration;
                    let currentFill;
                    let currentChunkWidth;
                    let skipFurtherText = false;
                    let firstTextChunk = true;
                    let leftoverChunks = [];
                    let currentVerticalAlign;
                    //let offsetX = 0;
                    //let chunk;
                    //while(chunk = chunks.shift()) {
                    eachContinue$1(chunks, (chunk, index) => {
                        // Format chunk
                        if (chunk.type == "format") {
                            if (chunk.text == "[/]") {
                                if (!styleRestored) {
                                    context.restore();
                                    ghostContext.restore();
                                    styleRestored = true;
                                }
                                currentFill = undefined;
                                currentStyle = undefined;
                                currentChunkWidth = undefined;
                                currentDecoration = this.style.textDecoration;
                                currentVerticalAlign = undefined;
                                currentFormat = chunk.text;
                            }
                            else {
                                if (!styleRestored) {
                                    context.restore();
                                    ghostContext.restore();
                                }
                                let format = TextFormatter.getTextStyle(chunk.text);
                                const fontStyle = this._getFontStyle(format);
                                context.save();
                                ghostContext.save();
                                context.font = fontStyle;
                                currentStyle = fontStyle;
                                currentFormat = chunk.text;
                                if (format.textDecoration) {
                                    currentDecoration = format.textDecoration;
                                }
                                if (format.fill) {
                                    currentFill = format.fill;
                                }
                                if (format.width) {
                                    currentChunkWidth = toNumber(format.width);
                                }
                                if (format.verticalAlign) {
                                    currentVerticalAlign = format.verticalAlign;
                                }
                                styleRestored = false;
                                // Measure reference text after change of format
                                const metrics = this._measureText(refText, context);
                                const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                                if (height > lineInfo.height) {
                                    lineInfo.height = height;
                                }
                                if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                                    lineInfo.ascent = metrics.actualBoundingBoxAscent;
                                }
                            }
                        }
                        // Text chunk
                        else if (chunk.type == "value" && !skipFurtherText) {
                            // Measure
                            const metrics = this._measureText(chunk.text, context);
                            let chunkWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
                            // Check for fit
                            if (truncate) {
                                // Break words?
                                let breakWords = firstTextChunk || this.style.breakWords || false;
                                // Measure ellipsis and check if it fits
                                const ellipsis = this.style.ellipsis || "";
                                const ellipsisMetrics = this._measureText(ellipsis, context);
                                const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;
                                // Check fit
                                if ((lineInfo.width + chunkWidth) > maxWidth) {
                                    const excessWidth = maxWidth - lineInfo.width - ellipsisWidth;
                                    chunk.text = this._truncateText(context, chunk.text, excessWidth, breakWords);
                                    chunk.text += ellipsis;
                                    skipFurtherText = true;
                                }
                            }
                            else if (wrap) {
                                // Check fit
                                if ((lineInfo.width + chunkWidth) > maxWidth) {
                                    const excessWidth = maxWidth - lineInfo.width;
                                    const tmpText = this._truncateText(context, chunk.text, excessWidth, false, (firstTextChunk && this.style.oversizedBehavior != "wrap-no-break"));
                                    if (tmpText == "") {
                                        // Unable to fit a single letter - hide the whole label
                                        this.textVisible = true;
                                        return false;
                                    }
                                    //skipFurtherText = true;
                                    //Add remaining chunks for the next line
                                    leftoverChunks = chunks.slice(index + 1);
                                    //Add remaining text of current chunk if it was forced-cut
                                    if (trim(tmpText) != trim(chunk.text)) {
                                        leftoverChunks.unshift({
                                            type: "value",
                                            text: chunk.text.substr(tmpText.length)
                                        });
                                        if (currentFormat) {
                                            leftoverChunks.unshift({
                                                type: "format",
                                                text: currentFormat
                                            });
                                        }
                                    }
                                    // Set current chunk (truncated)
                                    chunk.text = trim(tmpText);
                                    chunks = [];
                                    skipFurtherText = true;
                                }
                            }
                            // Chunk width?
                            let leftBoundMod = 1;
                            let rightBoundMod = 1;
                            if (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {
                                // increase horizontal bounding boxes accordingly
                                const boundsMod = chunkWidth / currentChunkWidth;
                                switch (this.style.textAlign) {
                                    case "right":
                                    case "end":
                                        leftBoundMod = boundsMod;
                                        break;
                                    case "center":
                                        leftBoundMod = boundsMod;
                                        rightBoundMod = boundsMod;
                                        break;
                                    default:
                                        rightBoundMod = boundsMod;
                                }
                                chunkWidth = currentChunkWidth;
                            }
                            const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            if (chunkHeight > lineInfo.height) {
                                lineInfo.height = chunkHeight;
                            }
                            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                                lineInfo.ascent = metrics.actualBoundingBoxAscent;
                            }
                            lineInfo.width += chunkWidth;
                            lineInfo.left += metrics.actualBoundingBoxLeft / leftBoundMod;
                            lineInfo.right += metrics.actualBoundingBoxRight / rightBoundMod;
                            lineInfo.textChunks.push({
                                style: currentStyle,
                                fill: currentFill,
                                text: chunk.text,
                                width: chunkWidth,
                                height: chunkHeight,
                                left: metrics.actualBoundingBoxLeft,
                                right: metrics.actualBoundingBoxRight,
                                ascent: metrics.actualBoundingBoxAscent,
                                offsetX: 0,
                                offsetY: 0,
                                textDecoration: currentDecoration,
                                verticalAlign: currentVerticalAlign
                            });
                            //offsetX += chunkWidth;
                            firstTextChunk = false;
                        }
                        return true;
                        //}
                    });
                    if (this.style.lineHeight instanceof Percent) {
                        lineInfo.height *= this.style.lineHeight.value;
                        lineInfo.ascent *= this.style.lineHeight.value;
                    }
                    else {
                        lineInfo.height *= this.style.lineHeight || 1.2;
                        lineInfo.ascent *= this.style.lineHeight || 1.2;
                    }
                    if (minX < lineInfo.left) {
                        minX = lineInfo.left;
                    }
                    if (maxX < lineInfo.right) {
                        maxX = lineInfo.right;
                    }
                    this._textInfo.push(lineInfo);
                    //lineInfo.offsetY += lineInfo.ascent;
                    offsetY += lineInfo.height;
                    // Reset chunks so that it can proceed to the next line
                    chunks = leftoverChunks || [];
                }
            });
            if (!styleRestored) {
                context.restore();
                ghostContext.restore();
            }
            // Adjust chunk internal offsets
            each$1(this._textInfo, (lineInfo, _index) => {
                let currentChunkOffset = 0;
                each$1(lineInfo.textChunks, (chunk) => {
                    chunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;
                    chunk.offsetY += lineInfo.height - lineInfo.height * (this.style.baselineRatio || 0.19);
                    currentChunkOffset += chunk.width;
                    if (chunk.verticalAlign) {
                        switch (chunk.verticalAlign) {
                            case "super":
                                chunk.offsetY -= lineInfo.height / 2 - chunk.height / 2;
                                break;
                            case "sub":
                                chunk.offsetY += chunk.height / 2;
                                break;
                        }
                    }
                });
            });
            const bounds = {
                left: rtl ? -maxX : -minX,
                top: 0,
                right: rtl ? minX : maxX,
                bottom: offsetY,
            };
            // We need to fit?
            if (oversizedBehavior !== "none") {
                const ratio = this._fitRatio(bounds);
                if (ratio < 1) {
                    if (oversizedBehavior == "fit") {
                        if (isNumber(this.style.minScale) && (ratio < this.style.minScale)) {
                            this.textVisible = false;
                            bounds.left = 0;
                            bounds.top = 0;
                            bounds.right = 0;
                            bounds.bottom = 0;
                        }
                        else {
                            if (!this._originalScale || this._originalScale == 1) {
                                this._originalScale = this.scale;
                            }
                            this.scale = ratio;
                            this.textVisible = true;
                        }
                    }
                    else if (oversizedBehavior == "hide") {
                        this.textVisible = false;
                        bounds.left = 0;
                        bounds.top = 0;
                        bounds.right = 0;
                        bounds.bottom = 0;
                    }
                    else {
                        switch (this.style.textAlign) {
                            case "right":
                            case "end":
                                bounds.left = -maxWidth;
                                bounds.right = 0;
                                break;
                            case "center":
                                bounds.left = -maxWidth / 2;
                                bounds.right = maxWidth / 2;
                                break;
                            default:
                                bounds.left = 0;
                                bounds.right = maxWidth;
                        }
                        this.scale = this._originalScale || 1;
                        this._originalScale = undefined;
                        this.textVisible = true;
                    }
                }
                else {
                    this.scale = this._originalScale || 1;
                    this._originalScale = undefined;
                    this.textVisible = true;
                }
            }
            context.restore();
            ghostContext.restore();
            return bounds;
        }
        _fitRatio(bounds) {
            const maxW = this.style.maxWidth;
            const maxH = this.style.maxHeight;
            if (!isNumber(maxW) && !isNumber(maxH)) {
                return 1;
            }
            const w = bounds.right - bounds.left;
            const h = bounds.bottom - bounds.top;
            return Math.min(maxW / w || 1, maxH / h || 1);
        }
        _truncateText(context, text, maxWidth, breakWords = false, fallbackBreakWords = true) {
            let width;
            do {
                if (breakWords) {
                    text = text.slice(0, -1);
                }
                else {
                    let tmp = text.replace(/[^,;:!?\\\/\s​]+[,;:!?\\\/\s​]*$/g, "");
                    if ((tmp == "" || tmp === text) && fallbackBreakWords) {
                        breakWords = true;
                    }
                    else if (tmp == "") {
                        return text;
                    }
                    else {
                        text = tmp;
                    }
                }
                const metrics = this._measureText(text, context);
                width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
            } while ((width > maxWidth) && text != "");
            return text;
        }
        _measureText(text, context) {
            let metrics = context.measureText(text);
            let fakeMetrics = {};
            if (metrics.actualBoundingBoxAscent == null) {
                const div = document.createElement("div");
                div.innerText = text;
                div.style.visibility = "hidden";
                div.style.position = "absolute";
                div.style.top = "-1000000px;";
                div.style.fontFamily = this.style.fontFamily || "";
                div.style.fontSize = this.style.fontSize + "";
                document.body.appendChild(div);
                const bbox = div.getBoundingClientRect();
                document.body.removeChild(div);
                const h = bbox.height;
                const w = metrics.width;
                let left = 0;
                let right = w;
                fakeMetrics = {
                    actualBoundingBoxAscent: h,
                    actualBoundingBoxDescent: 0,
                    actualBoundingBoxLeft: left,
                    actualBoundingBoxRight: right,
                    fontBoundingBoxAscent: h,
                    fontBoundingBoxDescent: 0,
                    width: w
                };
                //return fake;
            }
            else {
                fakeMetrics = {
                    actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                    actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                    actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,
                    actualBoundingBoxRight: metrics.actualBoundingBoxRight,
                    fontBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                    fontBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                    width: metrics.width
                };
            }
            const w = metrics.width;
            switch (this.style.textAlign) {
                case "right":
                case "end":
                    fakeMetrics.actualBoundingBoxLeft = w;
                    fakeMetrics.actualBoundingBoxRight = 0;
                    break;
                case "center":
                    fakeMetrics.actualBoundingBoxLeft = w / 2;
                    fakeMetrics.actualBoundingBoxRight = w / 2;
                    break;
                default:
                    fakeMetrics.actualBoundingBoxLeft = 0;
                    fakeMetrics.actualBoundingBoxRight = w;
            }
            return fakeMetrics;
        }
    }
    /**
     * @ignore
     */
    class CanvasTextStyle {
        constructor() {
            //public wordWrapWidth: number = 100;
            Object.defineProperty(this, "fill", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "fillOpacity", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "textAlign", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "fontFamily", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "fontSize", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "fontWeight", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "fontStyle", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "fontVariant", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "textDecoration", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowColor", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowBlur", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowOffsetX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowOffsetY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowOpacity", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // leading?: number;
            // letterSpacing?: number;
            Object.defineProperty(this, "lineHeight", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: percent(120)
            });
            Object.defineProperty(this, "baselineRatio", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0.19
            });
            // padding?: number;
            // stroke?: number;
            // strokeThickness?: number;
            // trim?: number;
            // wordWrap?: boolean;
            Object.defineProperty(this, "direction", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "textBaseline", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "oversizedBehavior", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: "none"
            });
            Object.defineProperty(this, "breakWords", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "ellipsis", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: "…"
            });
            Object.defineProperty(this, "maxWidth", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "maxHeight", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "minScale", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "ignoreFormatting", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
    }
    /**
     * @ignore
     */
    class CanvasRadialText extends CanvasText {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "textType", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: "circular"
            });
            Object.defineProperty(this, "radius", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "startAngle", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "inside", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "orientation", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: "auto"
            });
            Object.defineProperty(this, "kerning", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_textReversed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        _render(status) {
            switch (this.textType) {
                case "circular":
                    this._renderCircular(status);
                    break;
                default:
                    super._render(status);
                    break;
            }
        }
        _renderCircular(status) {
            if (this.textVisible) {
                this._prerender(status);
                const interactive = this._isInteractive(status);
                const context = status.layer.context;
                const layerDirty = status.layer.dirty;
                const ghostContext = this._renderer._ghostLayer.context;
                // Savepoint
                context.save();
                if (interactive) {
                    ghostContext.save();
                }
                // We need measurements in order to properly position text for alignment
                if (!this._textInfo) {
                    this._measure(status);
                }
                // Init
                let radius = (this.radius || 0);
                let startAngle = (this.startAngle || 0);
                let deltaAngle = 0;
                let orientation = this.orientation;
                let inward = orientation == "auto" ? "auto" : orientation == "inward";
                const inside = this.inside;
                const align = this.style.textAlign || "left";
                const kerning = this.kerning || 0;
                let clockwise = align == "left" ? 1 : -1;
                const shouldReverse = !this._textReversed;
                // Check if we need to invert the whole stuff
                if (inward == "auto") {
                    // Calc max angle so we know whether we need to flip it
                    let maxAngle = 0;
                    let midAngle = 0;
                    each$1(this._textInfo, (line, _index) => {
                        const deltaAngle = startAngle + (line.width / (radius - line.height)) / 2 * -clockwise;
                        if (deltaAngle > maxAngle) {
                            maxAngle = deltaAngle;
                        }
                    });
                    if (align == "left") {
                        midAngle = (maxAngle + deltaAngle / 2) * DEGREES;
                    }
                    else if (align == "right") {
                        midAngle = (maxAngle - deltaAngle / 2) * DEGREES;
                    }
                    else {
                        midAngle = startAngle * DEGREES;
                    }
                    midAngle = normalizeAngle(midAngle);
                    inward = (midAngle >= 270) || (midAngle <= 90);
                }
                if (inward == true && shouldReverse) {
                    this._textInfo.reverse();
                    this._textReversed = true;
                }
                // if ((inward == false && align == "left") || (inward == true && align == "right")) {
                // 	clockwise *= -1;
                // }
                // Process text info produced by _measure()
                each$1(this._textInfo, (line, _index) => {
                    const textHeight = line.height;
                    // Adjust radius (for `inside = false`)
                    // Radius adjustment for `inside = false` is below the line calculation
                    if (!inside) {
                        radius += textHeight;
                    }
                    // Reverse letters if we're painting them counter-clockwise
                    if (((clockwise == -1 && inward) || (clockwise == 1 && !inward)) && shouldReverse) {
                        line.textChunks.reverse();
                    }
                    // Init angles
                    let lineStartAngle = startAngle;
                    deltaAngle = 0;
                    // Adjust for center-align
                    if (align == "center") {
                        lineStartAngle += (line.width / (radius - textHeight)) / 2 * -clockwise;
                        deltaAngle = lineStartAngle - startAngle;
                    }
                    // if (inward == "auto") {
                    // 	let midAngle;
                    // 	if (align == "left") {
                    // 		midAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;
                    // 	}
                    // 	else if () {
                    // 		midAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;
                    // 	}
                    // 	inward = (midAngle >= 270) || (midAngle <= 90);
                    // }
                    // Rotate letters if they are facing outward
                    lineStartAngle += (Math.PI * (inward ? 0 : 1)); // Rotate 180 if outward
                    // Savepoint
                    context.save();
                    if (interactive) {
                        ghostContext.save();
                    }
                    // Assume starting angle
                    context.rotate(lineStartAngle);
                    if (interactive) {
                        ghostContext.rotate(lineStartAngle);
                    }
                    let angleShift = 0;
                    each$1(line.textChunks, (chunk, _index) => {
                        // Draw the letter
                        const char = chunk.text;
                        const charWidth = chunk.width;
                        // Rotate half a letter
                        angleShift = (charWidth / 2) / (radius - textHeight) * clockwise;
                        context.rotate(angleShift);
                        if (interactive) {
                            ghostContext.rotate(angleShift);
                        }
                        // Set style
                        if (chunk.style) {
                            context.save();
                            ghostContext.save();
                            context.font = chunk.style;
                            if (interactive) {
                                ghostContext.font = chunk.style;
                            }
                        }
                        if (chunk.fill) {
                            context.save();
                            context.fillStyle = chunk.fill.toCSS();
                            // Color does not affect ghostContext so we not set it
                        }
                        // Center letters
                        context.textBaseline = "middle";
                        context.textAlign = "center";
                        if (interactive) {
                            ghostContext.textBaseline = "middle";
                            ghostContext.textAlign = "center";
                        }
                        // Plop the letter
                        if (layerDirty) {
                            context.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));
                        }
                        if (interactive) {
                            ghostContext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));
                        }
                        if (chunk.fill) {
                            context.restore();
                            // Color does not affect ghostContext so we not set it
                        }
                        // Reset style
                        if (chunk.style) {
                            context.restore();
                            ghostContext.restore();
                        }
                        // Rotate half a letter and add spacing
                        angleShift = (charWidth / 2 + kerning) / (radius - textHeight) * clockwise;
                        context.rotate(angleShift);
                        if (interactive) {
                            ghostContext.rotate(angleShift);
                        }
                    });
                    // Restore angle
                    context.restore();
                    if (interactive) {
                        ghostContext.restore();
                    }
                    // Adjust radius (for `inside = true`)
                    if (inside) {
                        radius -= textHeight;
                    }
                });
                // Restore
                context.restore();
                if (interactive) {
                    ghostContext.restore();
                }
            }
        }
        _measure(status) {
            switch (this.textType) {
                case "circular":
                    return this._measureCircular(status);
                default:
                    return super._measure(status);
            }
        }
        _measureCircular(status) {
            const context = status.layer.context;
            const ghostContext = this._renderer._ghostLayer.context;
            const rtl = this.style.direction == "rtl";
            const oversizedBehavior = this.style.oversizedBehavior;
            const maxWidth = this.style.maxWidth;
            const truncate = isNumber(maxWidth) && oversizedBehavior == "truncate";
            const ellipsis = this.style.ellipsis || "";
            let ellipsisMetrics;
            //const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == "wrap" || oversizedBehavior == "wrap-no-break");
            // Reset text info
            this.textVisible = true;
            this._textInfo = [];
            this._textReversed = false;
            // Pre-render
            context.save();
            ghostContext.save();
            this._prerender(status, true);
            // Split up text into lines
            const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
            let styleRestored = true;
            let totalWidth = 0;
            // Iterate through the lines
            let offsetY = 0;
            each$1(lines, (line, _index) => {
                // Split up line into format/value chunks
                let chunks = TextFormatter.chunk(line, false, this.style.ignoreFormatting);
                // Init line object
                let lineInfo = {
                    offsetY: offsetY,
                    ascent: 0,
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    textChunks: []
                };
                let currentStyle;
                let currentFill;
                let currentChunkWidth;
                //while(chunk = chunks.shift()) {
                each$1(chunks, (chunk, _index) => {
                    // Format chunk
                    if (chunk.type == "format") {
                        if (chunk.text == "[/]") {
                            if (!styleRestored) {
                                context.restore();
                                ghostContext.restore();
                                styleRestored = true;
                            }
                            currentFill = undefined;
                            currentStyle = undefined;
                            currentChunkWidth = undefined;
                        }
                        else {
                            let format = TextFormatter.getTextStyle(chunk.text);
                            const fontStyle = this._getFontStyle(format);
                            context.save();
                            ghostContext.save();
                            context.font = fontStyle;
                            currentStyle = fontStyle;
                            if (format.fill) {
                                currentFill = format.fill;
                            }
                            if (format.width) {
                                currentChunkWidth = toNumber(format.width);
                            }
                            styleRestored = false;
                        }
                        if (truncate) {
                            ellipsisMetrics = this._measureText(ellipsis, context);
                        }
                    }
                    // Text format
                    else if (chunk.type == "value") {
                        // Measure each letter
                        let chars = chunk.text.match(/./ug) || [];
                        if (rtl) {
                            chars = splitString(chunk.text);
                            chars.reverse();
                        }
                        for (let i = 0; i < chars.length; i++) {
                            const char = chars[i];
                            // Measure
                            const metrics = this._measureText(char, context);
                            let chunkWidth = metrics.width;
                            // Chunk width?
                            if (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {
                                chunkWidth = currentChunkWidth;
                            }
                            const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            if (chunkHeight > lineInfo.height) {
                                lineInfo.height = chunkHeight;
                            }
                            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                                lineInfo.ascent = metrics.actualBoundingBoxAscent;
                            }
                            totalWidth += chunkWidth;
                            // Handle oversized behavior
                            if (truncate) {
                                // Measure ellipsis and check if it fits
                                if (!ellipsisMetrics) {
                                    ellipsisMetrics = this._measureText(ellipsis, context);
                                }
                                const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;
                                //totalWidth += ellipsisWidth;
                                if ((totalWidth + ellipsisWidth) > maxWidth) {
                                    if (lineInfo.textChunks.length == 1) {
                                        this.textVisible = false;
                                    }
                                    else {
                                        lineInfo.width += ellipsisWidth;
                                        lineInfo.left += ellipsisMetrics.actualBoundingBoxLeft;
                                        lineInfo.right += ellipsisMetrics.actualBoundingBoxRight;
                                        lineInfo.textChunks.push({
                                            style: currentStyle,
                                            fill: currentFill,
                                            text: ellipsis,
                                            width: ellipsisWidth,
                                            height: chunkHeight + ellipsisMetrics.actualBoundingBoxDescent,
                                            left: ellipsisMetrics.actualBoundingBoxLeft,
                                            right: ellipsisMetrics.actualBoundingBoxRight,
                                            ascent: ellipsisMetrics.actualBoundingBoxAscent,
                                            offsetX: 0,
                                            offsetY: chunkHeight,
                                            textDecoration: undefined
                                        });
                                    }
                                    break;
                                }
                            }
                            lineInfo.width += chunkWidth;
                            lineInfo.left += metrics.actualBoundingBoxLeft;
                            lineInfo.right += metrics.actualBoundingBoxRight;
                            lineInfo.textChunks.push({
                                style: currentStyle,
                                fill: currentFill,
                                text: char,
                                width: chunkWidth,
                                height: chunkHeight + metrics.actualBoundingBoxDescent,
                                left: metrics.actualBoundingBoxLeft,
                                right: metrics.actualBoundingBoxRight,
                                ascent: metrics.actualBoundingBoxAscent,
                                offsetX: 0,
                                offsetY: chunkHeight,
                                textDecoration: undefined
                            });
                        }
                    }
                });
                if (this.style.lineHeight instanceof Percent) {
                    lineInfo.height *= this.style.lineHeight.value;
                }
                else {
                    lineInfo.height *= this.style.lineHeight || 1.2;
                }
                this._textInfo.push(lineInfo);
                //lineInfo.offsetY += lineInfo.ascent;
                offsetY += lineInfo.height;
            });
            if (!styleRestored) {
                context.restore();
                ghostContext.restore();
            }
            if (oversizedBehavior == "hide" && (totalWidth > maxWidth)) {
                this.textVisible = false;
            }
            // Adjust chunk internal offsets
            each$1(this._textInfo, (lineInfo) => {
                each$1(lineInfo.textChunks, (chunk) => {
                    chunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);
                });
            });
            context.restore();
            ghostContext.restore();
            return {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
            };
        }
    }
    /**
     * @ignore
     */
    class CanvasImage extends CanvasDisplayObject {
        constructor(renderer, image) {
            super(renderer);
            Object.defineProperty(this, "width", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "height", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "image", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "tainted", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowColor", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowBlur", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowOffsetX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowOffsetY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shadowOpacity", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_imageMask", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.image = image;
        }
        _dispose() {
            super._dispose();
            if (this._imageMask) {
                clearCanvas(this._imageMask);
            }
        }
        getLocalBounds() {
            if (!this._localBounds) {
                let w = 0;
                let h = 0;
                if (this.width) {
                    w = this.width;
                }
                if (this.height) {
                    h = this.height;
                }
                this._localBounds = {
                    left: 0,
                    top: 0,
                    right: w,
                    bottom: h
                };
                this._addBounds(this._localBounds);
            }
            return this._localBounds;
        }
        _render(status) {
            super._render(status);
            if (this.image) {
                if (this.tainted === undefined) {
                    this.tainted = isTainted(this.image);
                    status.layer.tainted = true;
                }
                if (this.tainted && this._renderer._omitTainted) {
                    return;
                }
                if (status.layer.dirty) {
                    if (this.shadowColor) {
                        status.layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);
                    }
                    if (this.shadowBlur) {
                        status.layer.context.shadowBlur = this.shadowBlur;
                    }
                    if (this.shadowOffsetX) {
                        status.layer.context.shadowOffsetX = this.shadowOffsetX;
                    }
                    if (this.shadowOffsetY) {
                        status.layer.context.shadowOffsetY = this.shadowOffsetY;
                    }
                    // TODO should this round ?
                    const width = this.width || this.image.naturalWidth;
                    const height = this.height || this.image.naturalHeight;
                    status.layer.context.drawImage(this.image, 0, 0, width, height);
                }
                if (this.interactive && this._isInteractive(status)) {
                    const mask = this._getMask(this.image);
                    this._renderer._ghostLayer.context.drawImage(mask, 0, 0);
                }
            }
        }
        clear() {
            super.clear();
            this.image = undefined;
            this._imageMask = undefined;
        }
        _getMask(image) {
            if (this._imageMask === undefined) {
                // TODO should this round ?
                const width = this.width || image.naturalWidth;
                const height = this.height || image.naturalHeight;
                // We need to create a second canvas because destination-in clears out the entire canvas
                const canvas = document.createElement("canvas");
                canvas.width = width;
                canvas.height = height;
                const context = canvas.getContext("2d");
                context.imageSmoothingEnabled = false;
                context.fillStyle = this._getColorId();
                context.fillRect(0, 0, width, height);
                if (!isTainted(image)) {
                    context.globalCompositeOperation = "destination-in";
                    context.drawImage(image, 0, 0, width, height);
                }
                this._imageMask = canvas;
            }
            return this._imageMask;
        }
    }
    /**
     * @ignore
     */
    class CanvasRendererEvent {
        constructor(event, originalPoint, point, bbox) {
            Object.defineProperty(this, "event", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: event
            });
            Object.defineProperty(this, "originalPoint", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: originalPoint
            });
            Object.defineProperty(this, "point", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: point
            });
            Object.defineProperty(this, "bbox", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: bbox
            });
            Object.defineProperty(this, "id", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "simulated", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "native", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            if (supports("touchevents") && event instanceof Touch) {
                this.id = event.identifier;
            }
            else {
                this.id = null;
            }
        }
    }
    /**
     * @ignore
     */
    class CanvasRenderer extends ArrayDisposer {
        constructor(resolution) {
            super();
            Object.defineProperty(this, "view", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: document.createElement("div")
            });
            Object.defineProperty(this, "_layerDom", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: document.createElement("div")
            });
            Object.defineProperty(this, "layers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_dirtyLayers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "defaultLayer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.getLayer(0)
            });
            Object.defineProperty(this, "_ghostLayer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new GhostLayer()
            });
            Object.defineProperty(this, "_patternCanvas", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: document.createElement("canvas")
            });
            Object.defineProperty(this, "_patternContext", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._patternCanvas.getContext("2d")
            });
            Object.defineProperty(this, "_realWidth", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_realHeight", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_calculatedWidth", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_calculatedHeight", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "resolution", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "interactionsEnabled", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "_listeners", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_events", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_colorId", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_colorMap", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_forceInteractive", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_omitTainted", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            // TODO this should store the Id as well
            Object.defineProperty(this, "_hovering", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new Set()
            });
            Object.defineProperty(this, "_dragging", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_mousedown", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_lastPointerMoveEvent", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "tapToActivate", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "tapToActivateTimeout", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 3000
            });
            Object.defineProperty(this, "_touchActive", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_touchActiveTimeout", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            if (resolution == null) {
                this.resolution = window.devicePixelRatio;
            }
            else {
                this.resolution = resolution;
            }
            this.view.style.position = "absolute";
            this.view.setAttribute("aria-hidden", "true");
            this.view.appendChild(this._layerDom);
            this._disposers.push(new Disposer(() => {
                each(this._events, (_key, events) => {
                    events.disposer.dispose();
                });
                each$1(this.layers, (layer) => {
                    clearCanvas(layer.view);
                    if (layer.exportableView) {
                        clearCanvas(layer.exportableView);
                    }
                });
                clearCanvas(this._ghostLayer.view);
                clearCanvas(this._patternCanvas);
            }));
            /*
            this._disposers.push($utils.addEventListener(this._ghostLayer.view, "click", (originalEvent: MouseEvent) => {
                const event = this.getEvent(originalEvent);
                const target = this._getHitTarget(event.originalPoint, event.bbox);
                console.debug(target);
            }));
            */
            // Monitor for possible pixel ratio changes (when page is zoomed)
            this._disposers.push(onZoom(() => {
                if (resolution == null) {
                    this.resolution = window.devicePixelRatio;
                }
            }));
            // We need this in order top prevent default touch gestures when dragging
            // draggable elements
            if (supports("touchevents")) {
                const listener = (ev) => {
                    if (this._dragging.length !== 0) {
                        eachContinue$1(this._dragging, (item) => {
                            if (item.value.shouldCancelTouch()) {
                                ev.preventDefault();
                                return false;
                            }
                            return true;
                        });
                    }
                    // If touch down happends, delay touch out
                    if (this._touchActiveTimeout) {
                        this._delayTouchDeactivate();
                    }
                };
                this._disposers.push(addEventListener(window, "touchstart", listener, { passive: false }));
                this._disposers.push(addEventListener(this.view, "touchstart", listener, { passive: false }));
                this._disposers.push(addEventListener(this.view, "touchmove", () => {
                    // If touch is moving, delay touch out
                    if (this._touchActiveTimeout) {
                        this._delayTouchDeactivate();
                    }
                }, { passive: true }));
                this._disposers.push(addEventListener(window, "click", (_ev) => {
                    this._touchActive = false;
                }, { passive: true }));
                this._disposers.push(addEventListener(this.view, "click", (_ev) => {
                    window.setTimeout(() => {
                        this._touchActive = true;
                        this._delayTouchDeactivate();
                    }, 100);
                }, { passive: true }));
            }
            // Prevent scrolling of the window when hovering on "wheelable" object
            if (supports("wheelevents")) {
                this._disposers.push(addEventListener(this.view, "wheel", (ev) => {
                    let prevent = false;
                    this._hovering.forEach((obj) => {
                        if (obj.wheelable) {
                            prevent = true;
                            return false;
                        }
                    });
                    if (prevent) {
                        ev.preventDefault();
                    }
                }, { passive: false }));
            }
        }
        /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {
            this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);
        });
        */
        resetImageArray() {
            this._ghostLayer.imageArray = undefined;
        }
        _delayTouchDeactivate() {
            if (this._touchActiveTimeout) {
                clearTimeout(this._touchActiveTimeout);
            }
            if (this.tapToActivateTimeout > 0) {
                this._touchActiveTimeout = window.setTimeout(() => {
                    this._touchActive = false;
                }, this.tapToActivateTimeout);
            }
        }
        get debugGhostView() {
            return !!this._ghostLayer.view.parentNode;
        }
        set debugGhostView(value) {
            if (value) {
                if (!this._ghostLayer.view.parentNode) {
                    this.view.appendChild(this._ghostLayer.view);
                }
            }
            else {
                if (this._ghostLayer.view.parentNode) {
                    this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);
                }
            }
        }
        createLinearGradient(x1, y1, x2, y2) {
            return this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);
        }
        createRadialGradient(x1, y1, radius1, x2, y2, radius2) {
            return this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);
        }
        createPattern(graphics, background, repetition, width, height) {
            // const patternCanvas = document.createElement("canvas");
            // const patternContext = patternCanvas.getContext("2d")!;
            // patternCanvas.width = width;
            // patternCanvas.height = height;
            // if (fill) {
            // 	patternContext.fillStyle = fill.toCSS();
            // 	patternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
            // }
            // const layer = {
            // 	view: patternCanvas,
            // 	context: patternContext,
            // 	visible: true,
            // 	order: 0,
            // 	width: width,
            // 	height: height,
            // 	dirty: true
            // };
            // // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);
            // // patternContext.stroke();
            // image.targetLayer = layer;
            // image.render(layer);
            //this._layerDom.appendChild(patternCanvas);
            this._patternCanvas.width = width;
            this._patternCanvas.height = height;
            this._patternContext.clearRect(0, 0, width, height);
            // patternCanvas.style.width = width * this.resolution + "px";
            // patternCanvas.style.height = height * this.resolution + "px";
            background.renderDetached(this._patternContext);
            graphics.renderDetached(this._patternContext);
            return this._patternContext.createPattern(this._patternCanvas, repetition);
        }
        makeContainer() {
            return new CanvasContainer(this);
        }
        makeGraphics() {
            return new CanvasGraphics(this);
        }
        makeText(text, style) {
            return new CanvasText(this, text, style);
        }
        makeTextStyle() {
            return new CanvasTextStyle();
        }
        makeRadialText(text, style) {
            return new CanvasRadialText(this, text, style);
        }
        makePicture(image) {
            return new CanvasImage(this, image);
        }
        resizeLayer(layer) {
            layer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);
        }
        resizeGhost() {
            this._ghostLayer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);
        }
        resize(realWidth, realHeight, calculatedWidth, calculatedHeight) {
            this._realWidth = realWidth;
            this._realHeight = realHeight;
            this._calculatedWidth = calculatedWidth;
            this._calculatedHeight = calculatedHeight;
            each$1(this.layers, (layer) => {
                if (layer) {
                    layer.dirty = true;
                    this.resizeLayer(layer);
                }
            });
            this.resizeGhost();
            this.view.style.width = calculatedWidth + "px";
            this.view.style.height = calculatedHeight + "px";
        }
        createDetachedLayer(willReadFrequently = false) {
            const view = document.createElement("canvas");
            const context = view.getContext("2d", { willReadFrequently: willReadFrequently });
            const layer = new CanvasLayer(view, context);
            view.style.position = "absolute";
            view.style.top = "0px";
            view.style.left = "0px";
            return layer;
        }
        getLayerByOrder(order) {
            const layers = this.layers;
            const length = layers.length;
            for (let i = 0; i < length; i++) {
                const layer = layers[i];
                if (layer.order == order) {
                    return layer;
                }
            }
        }
        getLayer(order, visible = true) {
            let existingLayer = this.getLayerByOrder(order);
            if (existingLayer) {
                return existingLayer;
            }
            const layer = this.createDetachedLayer(order == 99);
            layer.order = order;
            layer.visible = visible;
            layer.view.className = "am5-layer-" + order;
            if (layer.visible) {
                this.resizeLayer(layer);
            }
            const layers = this.layers;
            layers.push(layer);
            layers.sort((a, b) => {
                if (a.order > b.order) {
                    return 1;
                }
                else if (a.order < b.order) {
                    return -1;
                }
                else {
                    return 0;
                }
            });
            const length = layers.length;
            const layerIndex = indexOf(layers, layer);
            let next;
            for (let i = layerIndex + 1; i < length; i++) {
                if (layers[i].visible) {
                    next = layers[i];
                    break;
                }
            }
            if (layer.visible) {
                if (next === undefined) {
                    this._layerDom.appendChild(layer.view);
                }
                else {
                    this._layerDom.insertBefore(layer.view, next.view);
                }
            }
            return layer;
        }
        render(root) {
            this._dirtyLayers.length = 0;
            each$1(this.layers, (layer) => {
                if (layer) {
                    if (layer.dirty && layer.visible) {
                        this._dirtyLayers.push(layer);
                        layer.clear();
                    }
                }
            });
            this._ghostLayer.clear();
            root.render({
                inactive: null,
                layer: this.defaultLayer,
            });
            this._ghostLayer.context.restore();
            //setTimeout(() => {
            // Remove this after the Chrome bug is fixed:
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1279394
            each$1(this.layers, (layer) => {
                if (layer) {
                    const context = layer.context;
                    context.beginPath();
                    context.moveTo(0, 0);
                    context.stroke();
                }
            });
            each$1(this._dirtyLayers, (layer) => {
                layer.context.restore();
                layer.dirty = false;
            });
            //}, 100)
            if (this._hovering.size && this._lastPointerMoveEvent) {
                const { events, target, native } = this._lastPointerMoveEvent;
                //this._mouseMoveThrottler.run();
                each$1(events, (event) => {
                    this._dispatchGlobalMousemove(event, target, native);
                });
            }
        }
        paintId(obj) {
            const id = distributeId(++this._colorId);
            const color = Color.fromHex(id).toCSS();
            this._colorMap[color] = obj;
            return color;
        }
        _removeObject(obj) {
            if (obj._colorId !== undefined) {
                delete this._colorMap[obj._colorId];
            }
        }
        // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {
        // 	return this._colorMap[colorId];
        // }
        _adjustBoundingBox(bbox) {
            const margin = this._ghostLayer.margin;
            return new DOMRect(-margin.left, -margin.top, bbox.width + margin.left + margin.right, bbox.height + margin.top + margin.bottom);
        }
        getEvent(originalEvent, adjustPoint = true) {
            const bbox = this.view.getBoundingClientRect();
            const x = originalEvent.clientX || 0;
            const y = originalEvent.clientY || 0;
            const widthScale = this._calculatedWidth / this._realWidth;
            const heightScale = this._calculatedHeight / this._realHeight;
            const originalPoint = {
                x: x - bbox.left,
                y: y - bbox.top,
            };
            const point = {
                x: (x - (adjustPoint ? bbox.left : 0)) * widthScale,
                y: (y - (adjustPoint ? bbox.top : 0)) * heightScale,
            };
            return new CanvasRendererEvent(originalEvent, originalPoint, point, this._adjustBoundingBox(bbox));
        }
        _getHitTarget(point, bbox, target) {
            if (bbox.width === 0 || bbox.height === 0 || point.x < bbox.left || point.x > bbox.right || point.y < bbox.top || point.y > bbox.bottom) {
                return;
            }
            if (!target || !this._layerDom.contains(target)) {
                return;
            }
            const pixel = this._ghostLayer.getImageData(point, bbox);
            if (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {
                return false;
            }
            const colorId = Color.fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();
            const hit = this._colorMap[colorId];
            return hit;
        }
        getObjectAtPoint(point) {
            const data = this._ghostLayer.getImageArray(point);
            if (data[0] === 0 && data[1] === 0 && data[2] === 0) {
                return undefined;
            }
            const colorId = Color.fromRGB(data[0], data[1], data[2]).toCSS();
            const hit = this._colorMap[colorId];
            return hit;
        }
        _withEvents(key, f) {
            const events = this._events[key];
            if (events !== undefined) {
                events.dispatching = true;
                try {
                    f(events);
                }
                finally {
                    events.dispatching = false;
                    if (events.cleanup) {
                        events.cleanup = false;
                        keepIf(events.callbacks, (callback) => {
                            return !callback.disposed;
                        });
                        if (events.callbacks.length === 0) {
                            events.disposer.dispose();
                            delete this._events[key];
                        }
                    }
                }
            }
        }
        _dispatchEventAll(key, event) {
            if (!this.interactionsEnabled) {
                return;
            }
            this._withEvents(key, (events) => {
                each$1(events.callbacks, (callback) => {
                    if (!callback.disposed) {
                        callback.callback.call(callback.context, event);
                    }
                });
            });
        }
        _dispatchEvent(key, target, event) {
            if (!this.interactionsEnabled) {
                return false;
            }
            let dispatched = false;
            this._withEvents(key, (events) => {
                each$1(events.callbacks, (callback) => {
                    if (!callback.disposed && callback.object === target) {
                        callback.callback.call(callback.context, event);
                        dispatched = true;
                    }
                });
            });
            return dispatched;
        }
        _dispatchMousedown(originalEvent, originalTarget) {
            const button = originalEvent.button;
            if (button != 0 && button != 2 && button != 1 && button !== undefined) {
                // Ignore non-primary mouse buttons
                return;
            }
            const event = this.getEvent(originalEvent);
            const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
            if (target) {
                const id = event.id;
                let dragged = false;
                eachTargets(target, (obj) => {
                    const info = { id: id, value: obj };
                    this._mousedown.push(info);
                    if (!dragged && this._dispatchEvent("pointerdown", obj, event)) {
                        // Only dispatch the first element which matches
                        dragged = true;
                        const has = this._dragging.some((x) => {
                            return x.value === obj && x.id === id;
                        });
                        if (!has) {
                            this._dragging.push(info);
                        }
                    }
                    return true;
                });
            }
        }
        _dispatchGlobalMousemove(originalEvent, originalTarget, native) {
            const event = this.getEvent(originalEvent);
            const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
            event.native = native;
            if (target) {
                this._hovering.forEach((obj) => {
                    if (!obj.contains(target)) {
                        this._hovering.delete(obj);
                        if (obj.cursorOverStyle) {
                            setStyle(document.body, "cursor", obj._replacedCursorStyle);
                        }
                        this._dispatchEvent("pointerout", obj, event);
                    }
                });
                if (event.native) {
                    eachTargets(target, (obj) => {
                        if (!this._hovering.has(obj)) {
                            this._hovering.add(obj);
                            if (obj.cursorOverStyle) {
                                obj._replacedCursorStyle = getStyle(document.body, "cursor");
                                setStyle(document.body, "cursor", obj.cursorOverStyle);
                            }
                            this._dispatchEvent("pointerover", obj, event);
                        }
                        return true;
                    });
                }
                //} else if (target === false) {
            }
            else {
                this._hovering.forEach((obj) => {
                    if (obj.cursorOverStyle) {
                        setStyle(document.body, "cursor", obj._replacedCursorStyle);
                    }
                    this._dispatchEvent("pointerout", obj, event);
                });
                this._hovering.clear();
            }
            this._dispatchEventAll("globalpointermove", event);
        }
        removeHovering(graphics) {
            this._hovering.delete(graphics);
            if (graphics.cursorOverStyle) {
                setStyle(document.body, "cursor", graphics._replacedCursorStyle);
            }
        }
        _dispatchGlobalMouseup(originalEvent, native) {
            const event = this.getEvent(originalEvent);
            event.native = native;
            //const target = this._getHitTarget(event.originalPoint);
            this._dispatchEventAll("globalpointerup", event);
        }
        _dispatchDragMove(originalEvent) {
            if (this._dragging.length !== 0) {
                const event = this.getEvent(originalEvent);
                const id = event.id;
                this._dragging.forEach((obj) => {
                    if (obj.id === id) {
                        this._dispatchEvent("pointermove", obj.value, event);
                    }
                });
            }
        }
        _dispatchDragEnd(originalEvent, originalTarget) {
            const button = originalEvent.button;
            let clickevent;
            if (button == 0 || button === undefined) {
                clickevent = "click";
            }
            else if (button == 2) {
                clickevent = "rightclick";
            }
            else if (button == 1) {
                clickevent = "middleclick";
            }
            else {
                // Ignore non-primary mouse buttons
                return;
            }
            const event = this.getEvent(originalEvent);
            const id = event.id;
            if (this._mousedown.length !== 0) {
                const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
                if (target) {
                    this._mousedown.forEach((obj) => {
                        if (obj.id === id && obj.value.contains(target)) {
                            this._dispatchEvent(clickevent, obj.value, event);
                        }
                    });
                }
                this._mousedown.length = 0;
            }
            if (this._dragging.length !== 0) {
                this._dragging.forEach((obj) => {
                    if (obj.id === id) {
                        this._dispatchEvent("pointerup", obj.value, event);
                    }
                });
                this._dragging.length = 0;
            }
        }
        _dispatchDoubleClick(originalEvent, originalTarget) {
            const event = this.getEvent(originalEvent);
            const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
            if (target) {
                eachTargets(target, (obj) => {
                    if (this._dispatchEvent("dblclick", obj, event)) {
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
        }
        _dispatchWheel(originalEvent, originalTarget) {
            const event = this.getEvent(originalEvent);
            const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
            if (target) {
                eachTargets(target, (obj) => {
                    if (this._dispatchEvent("wheel", obj, event)) {
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
        }
        _makeSharedEvent(key, f) {
            if (this._listeners[key] === undefined) {
                const listener = f();
                this._listeners[key] = new CounterDisposer(() => {
                    delete this._listeners[key];
                    listener.dispose();
                });
            }
            return this._listeners[key].increment();
        }
        _onPointerEvent(name, f) {
            let native = false;
            let timer = null;
            function clear() {
                timer = null;
                native = false;
            }
            return new MultiDisposer([
                new Disposer(() => {
                    if (timer !== null) {
                        clearTimeout(timer);
                    }
                    clear();
                }),
                addEventListener(this.view, getRendererEvent(name), (_) => {
                    native = true;
                    if (timer !== null) {
                        clearTimeout(timer);
                    }
                    timer = window.setTimeout(clear, 0);
                }),
                onPointerEvent(window, name, (ev, target) => {
                    if (timer !== null) {
                        clearTimeout(timer);
                        timer = null;
                    }
                    f(ev, target, native);
                    native = false;
                }),
            ]);
        }
        // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)
        _initEvent(key) {
            switch (key) {
                case "globalpointermove":
                case "pointerover":
                case "pointerout":
                    return this._makeSharedEvent("pointermove", () => {
                        const listener = (events, target, native) => {
                            this._lastPointerMoveEvent = { events, target, native };
                            each$1(events, (event) => {
                                this._dispatchGlobalMousemove(event, target, native);
                            });
                        };
                        return new MultiDisposer([
                            this._onPointerEvent("pointerdown", listener),
                            this._onPointerEvent("pointermove", listener),
                        ]);
                    });
                case "globalpointerup":
                    return this._makeSharedEvent("pointerup", () => {
                        const mouseup = this._onPointerEvent("pointerup", (events, target, native) => {
                            each$1(events, (event) => {
                                this._dispatchGlobalMouseup(event, native);
                            });
                            this._lastPointerMoveEvent = { events, target, native };
                        });
                        const pointercancel = this._onPointerEvent("pointercancel", (events, target, native) => {
                            each$1(events, (event) => {
                                this._dispatchGlobalMouseup(event, native);
                            });
                            this._lastPointerMoveEvent = { events, target, native };
                        });
                        return new Disposer(() => {
                            mouseup.dispose();
                            pointercancel.dispose();
                        });
                    });
                case "click":
                case "rightclick":
                case "middleclick":
                case "pointerdown":
                /*
                    return this._makeSharedEvent("pointerdown", () => {
                        return this._onPointerEvent("pointerdown", (event, target, native) => {
                            this._lastPointerMoveEvent = { event, target, native };
                            this._dispatchMousedown(event)
                        });
                    });
                */
                case "pointermove":
                case "pointerup":
                    return this._makeSharedEvent("pointerdown", () => {
                        //const throttler = new Throttler();
                        const mousedown = this._onPointerEvent("pointerdown", (events, target) => {
                            each$1(events, (ev) => {
                                this._dispatchMousedown(ev, target);
                            });
                        });
                        // TODO handle throttling properly for multitouch
                        const mousemove = this._onPointerEvent("pointermove", (ev) => {
                            //throttler.throttle(() => {
                            each$1(ev, (ev) => {
                                this._dispatchDragMove(ev);
                            });
                            //});
                        });
                        const mouseup = this._onPointerEvent("pointerup", (ev, target) => {
                            each$1(ev, (ev) => {
                                this._dispatchDragEnd(ev, target);
                            });
                        });
                        const pointercancel = this._onPointerEvent("pointercancel", (ev, target) => {
                            each$1(ev, (ev) => {
                                this._dispatchDragEnd(ev, target);
                            });
                        });
                        return new Disposer(() => {
                            mousedown.dispose();
                            mousemove.dispose();
                            mouseup.dispose();
                            pointercancel.dispose();
                        });
                    });
                case "dblclick":
                    return this._makeSharedEvent("dblclick", () => {
                        return this._onPointerEvent("dblclick", (ev, target) => {
                            each$1(ev, (ev) => {
                                this._dispatchDoubleClick(ev, target);
                            });
                        });
                    });
                case "wheel":
                    return this._makeSharedEvent("wheel", () => {
                        return addEventListener(this.view, getRendererEvent("wheel"), (event) => {
                            this._dispatchWheel(event, getEventTarget(event));
                        }, { passive: false });
                    });
            }
        }
        _addEvent(object, key, callback, context) {
            let events = this._events[key];
            if (events === undefined) {
                events = this._events[key] = {
                    disposer: this._initEvent(key),
                    callbacks: [],
                    dispatching: false,
                    cleanup: false,
                };
            }
            const listener = { object, context, callback, disposed: false };
            events.callbacks.push(listener);
            return new Disposer(() => {
                listener.disposed = true;
                if (events.dispatching) {
                    events.cleanup = true;
                }
                else {
                    removeFirst(events.callbacks, listener);
                    if (events.callbacks.length === 0) {
                        events.disposer.dispose();
                        delete this._events[key];
                    }
                }
            });
        }
        getCanvas(root, options) {
            // Make sure everything is rendered
            this.render(root);
            if (!options) {
                options = {};
            }
            let scale = this.resolution;
            let canvasWidth = Math.floor(this._calculatedWidth * this.resolution);
            let canvasHeight = Math.floor(this._calculatedHeight * this.resolution);
            // Check if we need to scale
            if (options.minWidth && (options.minWidth > canvasWidth)) {
                let minScale = options.minWidth / canvasWidth;
                if (minScale > scale) {
                    scale = minScale * this.resolution;
                }
            }
            if (options.minHeight && (options.minHeight > canvasHeight)) {
                let minScale = options.minHeight / canvasHeight;
                if (minScale > scale) {
                    scale = minScale * this.resolution;
                }
            }
            if (options.maxWidth && (options.maxWidth < canvasWidth)) {
                let maxScale = options.maxWidth / canvasWidth;
                if (maxScale < scale) {
                    scale = maxScale * this.resolution;
                }
            }
            if (options.maxHeight && (options.maxHeight > canvasHeight)) {
                let maxScale = options.maxHeight / canvasHeight;
                if (maxScale < scale) {
                    scale = maxScale * this.resolution;
                }
            }
            // Check if we need to compensate for pixel ratio
            if (options.maintainPixelRatio) {
                scale /= this.resolution;
            }
            // Init list canvases to remove from DOM after export
            const canvases = [];
            // Set up new canvas for export
            let forceRender = false;
            const canvas = document.createElement("canvas");
            if (scale != this.resolution) {
                forceRender = true;
                canvasWidth = canvasWidth * scale / this.resolution;
                canvasHeight = canvasHeight * scale / this.resolution;
            }
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            // Add to DOM so it inherits CSS
            canvas.style.position = "fixed";
            canvas.style.top = "-10000px";
            this.view.appendChild(canvas);
            canvases.push(canvas);
            // Context
            const context = canvas.getContext("2d");
            let width = 0;
            let height = 0;
            let needRerender = false;
            each$1(this.layers, (layer) => {
                if (layer && layer.visible) {
                    if (layer.tainted || forceRender) {
                        needRerender = true;
                        layer.exportableView = layer.view;
                        layer.exportableContext = layer.context;
                        layer.view = document.createElement("canvas");
                        // Add to DOM so it inherits CSS
                        layer.view.style.position = "fixed";
                        layer.view.style.top = "-10000px";
                        this.view.appendChild(layer.view);
                        canvases.push(layer.view);
                        let extraX = 0;
                        let extraY = 0;
                        if (layer.margin) {
                            extraX += layer.margin.left || 0 + layer.margin.right || 0;
                            extraY += layer.margin.top || 0 + layer.margin.bottom || 0;
                        }
                        layer.view.width = canvasWidth + extraX;
                        layer.view.height = canvasHeight + extraY;
                        layer.context = layer.view.getContext("2d");
                        layer.dirty = true;
                        layer.scale = scale;
                    }
                }
            });
            if (needRerender) {
                this._omitTainted = true;
                this.render(root);
                this._omitTainted = false;
            }
            each$1(this.layers, (layer) => {
                if (layer && layer.visible) {
                    // Layer is fine. Just plop it into our target canvas
                    let x = 0;
                    let y = 0;
                    if (layer.margin) {
                        x = -(layer.margin.left || 0) * this.resolution;
                        y = -(layer.margin.top || 0) * this.resolution;
                    }
                    context.drawImage(layer.view, x, y);
                    // Restore layer original canvas
                    if (layer.exportableView) {
                        layer.view = layer.exportableView;
                        layer.exportableView = undefined;
                    }
                    if (layer.exportableContext) {
                        layer.context = layer.exportableContext;
                        layer.exportableContext = undefined;
                    }
                    if (width < layer.view.clientWidth) {
                        width = layer.view.clientWidth;
                    }
                    if (height < layer.view.clientHeight) {
                        height = layer.view.clientHeight;
                    }
                    layer.scale = undefined;
                }
            });
            canvas.style.width = width + "px";
            canvas.style.height = height + "px";
            each$1(canvases, (canvas) => {
                canvas.style.position = "";
                canvas.style.top = "";
                this.view.removeChild(canvas);
            });
            return canvas;
        }
    }
    class GhostLayer {
        constructor() {
            Object.defineProperty(this, "view", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "context", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "margin", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                }
            });
            Object.defineProperty(this, "_resolution", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_width", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_height", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "imageArray", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.view = document.createElement("canvas");
            this.context = this.view.getContext("2d", { alpha: false, willReadFrequently: true });
            this.context.imageSmoothingEnabled = false;
            this.view.style.position = "absolute";
            this.view.style.top = "0px";
            this.view.style.left = "0px";
        }
        resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {
            this._resolution = resolution;
            canvasWidth += (this.margin.left + this.margin.right);
            canvasHeight += (this.margin.top + this.margin.bottom);
            // TODO this should take into account calculateSize
            domWidth += (this.margin.left + this.margin.right);
            domHeight += (this.margin.top + this.margin.bottom);
            this.view.style.left = -this.margin.left + "px";
            this.view.style.top = -this.margin.top + "px";
            this._width = Math.floor(canvasWidth * resolution);
            this._height = Math.floor(canvasHeight * resolution);
            this.view.width = this._width;
            this.view.style.width = domWidth + "px";
            this.view.height = this._height;
            this.view.style.height = domHeight + "px";
        }
        getImageData(point, bbox) {
            return this.context.getImageData(
            // TODO should this round ?
            Math.round(((point.x - bbox.left) / bbox.width) * this._width), Math.round(((point.y - bbox.top) / bbox.height) * this._height), 1, 1);
        }
        getImageArray(point) {
            if (!this.imageArray) {
                this.imageArray = this.context.getImageData(0, 0, this._width, this._height).data;
            }
            const data = this.imageArray;
            const x = Math.round(point.x * this._resolution);
            const y = Math.round(point.y * this._resolution);
            const i = (y * this._width + x) * 4;
            return [data[i], data[i + 1], data[i + 2], data[i + 3]];
        }
        setMargin(layers) {
            this.margin.left = 0;
            this.margin.right = 0;
            this.margin.top = 0;
            this.margin.bottom = 0;
            each$1(layers, (layer) => {
                if (layer.margin) {
                    this.margin.left = Math.max(this.margin.left, layer.margin.left);
                    this.margin.right = Math.max(this.margin.right, layer.margin.right);
                    this.margin.top = Math.max(this.margin.top, layer.margin.top);
                    this.margin.bottom = Math.max(this.margin.bottom, layer.margin.bottom);
                }
            });
        }
        clear() {
            this.context.save();
            this.context.fillStyle = '#000';
            this.context.fillRect(0, 0, this._width, this._height);
        }
    }
    /**
     * @ignore
     */
    class CanvasLayer {
        constructor(view, context) {
            Object.defineProperty(this, "view", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "context", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "tainted", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "margin", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "order", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "visible", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "width", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "height", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "scale", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "dirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "exportableView", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "exportableContext", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_width", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_height", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            this.view = view;
            this.context = context;
        }
        resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {
            // TODO should this take into account calculateSize ?
            if (this.width != null) {
                canvasWidth = this.width;
                domWidth = this.width;
            }
            // TODO should this take into account calculateSize ?
            if (this.height != null) {
                canvasHeight = this.height;
                domHeight = this.height;
            }
            if (this.margin) {
                canvasWidth += (this.margin.left + this.margin.right);
                canvasHeight += (this.margin.top + this.margin.bottom);
                // TODO this should take into account calculateSize
                domWidth += (this.margin.left + this.margin.right);
                domHeight += (this.margin.top + this.margin.bottom);
                this.view.style.left = -this.margin.left + "px";
                this.view.style.top = -this.margin.top + "px";
            }
            else {
                this.view.style.left = "0px";
                this.view.style.top = "0px";
            }
            this._width = Math.floor(canvasWidth * resolution);
            this._height = Math.floor(canvasHeight * resolution);
            this.view.width = this._width;
            this.view.style.width = domWidth + "px";
            this.view.height = this._height;
            this.view.style.height = domHeight + "px";
        }
        clear() {
            this.context.save();
            this.context.clearRect(0, 0, this._width, this._height);
        }
    }

    function rAF(fps, callback) {
        if (fps == null) {
            requestAnimationFrame(callback);
        }
        else {
            setTimeout(() => {
                requestAnimationFrame(callback);
            }, 1000 / fps);
        }
    }
    // TODO implement Disposer
    /**
     * Root element of the chart.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#Root_element} for more info
     */
    class Root {
        constructor(id, settings = {}, isReal) {
            /**
             * A reference to original chart container (div element).
             */
            Object.defineProperty(this, "dom", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_inner", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_settings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_isDirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_isDirtyParents", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_isDirtyAnimation", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_dirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_dirtyParents", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_dirtyBounds", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_dirtyPositions", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_ticker", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: null
            });
            Object.defineProperty(this, "_tickers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_updateTick", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            /**
             * Root's event dispatcher.
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
             */
            Object.defineProperty(this, "events", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new EventDispatcher()
            });
            /**
             * @ignore
             * @todo needs description
             */
            Object.defineProperty(this, "animationTime", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: null
            });
            Object.defineProperty(this, "_animations", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_renderer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_rootContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * Main content container.
             */
            Object.defineProperty(this, "container", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * A [[Container]] used to display tooltips in.
             */
            Object.defineProperty(this, "tooltipContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltipContainerSettings", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltip", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // Locale-related
            /**
             * @ignore
             */
            Object.defineProperty(this, "language", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Language.new(this, {})
            });
            /**
             * Locale used by the chart.
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/}
             */
            Object.defineProperty(this, "locale", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: en
            });
            // Date-time related
            /**
             * Use UTC when formatting date/time.
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#utc-and-time-zones} for more info
             */
            Object.defineProperty(this, "utc", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            /**
             * If set, will format date/time in specific time zone.
             *
             * The value should be named time zone, e.g.:
             * `"America/Vancouver"`, `"Australia/Sydney"`, `"UTC"`.
             *
             * NOTE: Using time zone feature may noticeable affect performance of the
             * chart, especially with large data sets, since every single date will need
             * to be recalculated.
             *
             * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#time-zone} for more info
             * @since 5.1.0
             */
            Object.defineProperty(this, "timezone", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * The maximum FPS that the Root will run at.
             *
             * If `undefined` it will run at the highest FPS.
             *
             * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Performance} for more info
             */
            Object.defineProperty(this, "fps", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * Number formatter.
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info
             */
            Object.defineProperty(this, "numberFormatter", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: NumberFormatter.new(this, {})
            });
            /**
             * Date/time formatter.
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info
             */
            Object.defineProperty(this, "dateFormatter", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: DateFormatter.new(this, {})
            });
            /**
             * Duration formatter.
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info
             */
            Object.defineProperty(this, "durationFormatter", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: DurationFormatter.new(this, {})
            });
            // Accessibility
            /**
             * Global tab index for using for the whole chart
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
             */
            Object.defineProperty(this, "tabindex", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            //@todo maybe make this better
            Object.defineProperty(this, "_tabindexes", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_a11yD", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_focusElementDirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_focusElementContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_focusedSprite", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_isShift", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_keyboardDragPoint", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltipElementContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_readerAlertElement", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_logo", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltipDiv", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * Used for dynamically-created CSS and JavaScript with strict source policies.
             */
            Object.defineProperty(this, "nonce", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * Special color set to be used for various controls.
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Interface_colors} for more info
             */
            Object.defineProperty(this, "interfaceColors", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * An instance of vertical layout object that can be used to set `layout` setting
             * of a [[Container]].
             *
             * @default VerticalLayout.new()
             */
            Object.defineProperty(this, "verticalLayout", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: VerticalLayout.new(this, {})
            });
            /**
             * An instance of horizontal layout object that can be used to set `layout` setting
             * of a [[Container]].
             *
             * @default HorizontalLayout.new()
             */
            Object.defineProperty(this, "horizontalLayout", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: HorizontalLayout.new(this, {})
            });
            /**
             * An instance of grid layout object that can be used to set `layout` setting
             * of a [[Container]].
             *
             * @default VerticalLayout.new()
             */
            Object.defineProperty(this, "gridLayout", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: GridLayout.new(this, {})
            });
            Object.defineProperty(this, "_paused", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            /**
             * Indicates whether chart should resized automatically when parent container
             * width and/or height changes.
             *
             * If disabled (`autoResize = false`) you can make the chart resize manually
             * by calling root element's `resize()` method.
             */
            Object.defineProperty(this, "autoResize", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "_fontHash", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: ""
            });
            Object.defineProperty(this, "_isDisposed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_disposers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_resizeSensorDisposer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltips", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_htmlElementContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_htmlEnabledContainers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            if (!isReal) {
                throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
            }
            this._settings = settings;
            if (settings.accessible == false) {
                this._a11yD = true;
            }
            if (settings.useSafeResolution == null) {
                settings.useSafeResolution = true;
            }
            let resolution;
            if (settings.useSafeResolution) {
                resolution = getSafeResolution();
            }
            this._renderer = new CanvasRenderer(resolution);
            let dom;
            if (id instanceof HTMLElement) {
                dom = id;
            }
            else {
                dom = document.getElementById(id);
            }
            each$1(registry.rootElements, (root) => {
                if (root.dom === dom) {
                    throw new Error("You cannot have multiple Roots on the same DOM node");
                }
            });
            this.interfaceColors = InterfaceColors.new(this, {});
            if (dom === null) {
                throw new Error("Could not find HTML element with id `" + id + "`");
            }
            this.dom = dom;
            let inner = document.createElement("div");
            inner.style.position = "relative";
            inner.style.width = "100%";
            inner.style.height = "100%";
            dom.appendChild(inner);
            const tooltipContainerBounds = settings.tooltipContainerBounds;
            if (tooltipContainerBounds) {
                this._tooltipContainerSettings = tooltipContainerBounds;
            }
            this._inner = inner;
            this._updateComputedStyles();
            registry.rootElements.push(this);
        }
        static new(id, settings) {
            const root = new Root(id, settings, true);
            root._init();
            return root;
        }
        moveDOM(id) {
            let dom;
            if (id instanceof HTMLElement) {
                dom = id;
            }
            else {
                dom = document.getElementById(id);
            }
            if (dom) {
                while (this.dom.childNodes.length > 0) {
                    dom.appendChild(this.dom.childNodes[0]);
                }
                this.dom = dom;
                this._initResizeSensor();
                this.resize();
            }
        }
        _handleLogo() {
            if (this._logo) {
                const w = this.dom.offsetWidth;
                const h = this.dom.offsetHeight;
                if ((w <= 150) || (h <= 60)) {
                    this._logo.hide();
                }
                else {
                    this._logo.show();
                }
            }
        }
        _showBranding() {
            if (!this._logo) {
                const logo = this.tooltipContainer.children.push(Container.new(this, {
                    interactive: true,
                    interactiveChildren: false,
                    position: "absolute",
                    setStateOnChildren: true,
                    paddingTop: 9,
                    paddingRight: 9,
                    paddingBottom: 9,
                    paddingLeft: 9,
                    scale: .6,
                    y: percent(100),
                    centerY: p100,
                    tooltipText: "Created using amCharts 5",
                    tooltipX: p100,
                    cursorOverStyle: "pointer",
                    background: Rectangle.new(this, {
                        fill: color(0x474758),
                        fillOpacity: 0,
                        tooltipY: 5
                    })
                }));
                const tooltip = Tooltip.new(this, {
                    pointerOrientation: "horizontal",
                    paddingTop: 4,
                    paddingRight: 7,
                    paddingBottom: 4,
                    paddingLeft: 7
                });
                tooltip.label.setAll({
                    fontSize: 12
                });
                tooltip.get("background").setAll({
                    fill: this.interfaceColors.get("background"),
                    stroke: this.interfaceColors.get("grid"),
                    strokeOpacity: 0.3
                });
                logo.set("tooltip", tooltip);
                logo.events.on("click", () => {
                    window.open("https://www.amcharts.com/", "_blank");
                });
                logo.states.create("hover", {});
                const m = logo.children.push(Graphics.new(this, {
                    stroke: color(0xcccccc),
                    strokeWidth: 3,
                    svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6"
                }));
                m.states.create("hover", { stroke: color(0x3CABFF) });
                const a = logo.children.push(Graphics.new(this, {
                    stroke: color(0x888888),
                    strokeWidth: 3,
                    svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0"
                }));
                a.states.create("hover", { stroke: color(0x474758) });
                //logo.set("tooltip", this._tooltip);
                //logo.setPrivate("tooltipTarget", logo.get("background"));
                this._logo = logo;
                this._handleLogo();
            }
        }
        _getRealSize() {
            return this.dom.getBoundingClientRect();
        }
        _getCalculatedSize(rect) {
            if (this._settings.calculateSize) {
                return this._settings.calculateSize(rect);
            }
            else {
                return {
                    width: rect.width,
                    height: rect.height,
                };
            }
        }
        _init() {
            const settings = this._settings;
            if (settings.accessible !== false) {
                if (settings.focusable) {
                    this._inner.setAttribute("focusable", "true");
                    this._inner.setAttribute("tabindex", this.tabindex + "");
                }
                if (settings.ariaLabel) {
                    this._inner.setAttribute("aria-label", settings.ariaLabel);
                }
                if (settings.role) {
                    this._inner.setAttribute("role", settings.role);
                }
            }
            const renderer = this._renderer;
            const rect = this._getRealSize();
            const size = this._getCalculatedSize(rect);
            const width = Math.floor(size.width);
            const height = Math.floor(size.height);
            const realWidth = Math.floor(rect.width);
            const realHeight = Math.floor(rect.height);
            const rootContainer = Container.new(this, {
                visible: true,
                width: width,
                height: height,
            });
            this._rootContainer = rootContainer;
            this._rootContainer._defaultThemes.push(DefaultTheme.new(this));
            const container = rootContainer.children.push(Container.new(this, { visible: true, width: p100, height: p100 }));
            this.container = container;
            renderer.resize(realWidth, realHeight, width, height);
            //@todo: better appendChild - refer
            this._inner.appendChild(renderer.view);
            // TODO: TMP TMP TMP for testing only, remove
            //renderer.debugGhostView = true;
            this._initResizeSensor();
            // HTML content holder
            const htmlElementContainer = document.createElement("div");
            this._htmlElementContainer = htmlElementContainer;
            htmlElementContainer.className = "am5-html-container";
            htmlElementContainer.style.position = "absolute";
            htmlElementContainer.style.pointerEvents = "none";
            if (!this._tooltipContainerSettings) {
                htmlElementContainer.style.overflow = "hidden";
            }
            this._inner.appendChild(htmlElementContainer);
            if (this._a11yD !== true) {
                // Create element which is used to make announcements to screen reader
                const readerAlertElement = document.createElement("div");
                readerAlertElement.className = "am5-reader-container";
                readerAlertElement.setAttribute("role", "alert");
                // readerAlertElement.style.zIndex = "-100000";
                // readerAlertElement.style.opacity = "0";
                // readerAlertElement.style.top = "0";
                readerAlertElement.style.position = "absolute";
                readerAlertElement.style.width = "1px";
                readerAlertElement.style.height = "1px";
                readerAlertElement.style.overflow = "hidden";
                readerAlertElement.style.clip = "rect(1px, 1px, 1px, 1px)";
                this._readerAlertElement = readerAlertElement;
                this._inner.appendChild(this._readerAlertElement);
                const focusElementContainer = document.createElement("div");
                focusElementContainer.className = "am5-focus-container";
                focusElementContainer.style.position = "absolute";
                focusElementContainer.style.pointerEvents = "none";
                focusElementContainer.style.top = "0px";
                focusElementContainer.style.left = "0px";
                focusElementContainer.style.overflow = "hidden";
                focusElementContainer.style.width = width + "px";
                focusElementContainer.style.height = height + "px";
                focusElementContainer.setAttribute("role", "graphics-document");
                setInteractive(focusElementContainer, false);
                this._focusElementContainer = focusElementContainer;
                this._inner.appendChild(this._focusElementContainer);
                const tooltipElementContainer = document.createElement("div");
                this._tooltipElementContainer = tooltipElementContainer;
                tooltipElementContainer.className = "am5-tooltip-container";
                this._inner.appendChild(tooltipElementContainer);
                // Add keyboard events for accessibility, e.g. simulating drag with arrow
                // keys and click with ENTER
                if (supports("keyboardevents")) {
                    this._disposers.push(addEventListener(window, "keydown", (ev) => {
                        const eventKey = getEventKey(ev);
                        if (eventKey == "Shift") {
                            this._isShift = true;
                        }
                        else if (eventKey == "Tab") {
                            this._isShift = ev.shiftKey;
                        }
                    }));
                    this._disposers.push(addEventListener(window, "keyup", (ev) => {
                        const eventKey = getEventKey(ev);
                        if (eventKey == "Shift") {
                            this._isShift = false;
                        }
                    }));
                    this._disposers.push(addEventListener(focusElementContainer, "click", () => {
                        // Some screen readers convert ENTER (and some SPACE) press whil on
                        // focused element to a "click" event, preventing actual "keydown"
                        // event from firing. We're using this "click" event to still
                        // generate internal click events.
                        const focusedSprite = this._focusedSprite;
                        if (focusedSprite) {
                            const downEvent = renderer.getEvent(new MouseEvent("click"));
                            focusedSprite.events.dispatch("click", {
                                type: "click",
                                originalEvent: downEvent.event,
                                point: downEvent.point,
                                simulated: true,
                                target: focusedSprite
                            });
                        }
                    }));
                    this._disposers.push(addEventListener(focusElementContainer, "keydown", (ev) => {
                        const focusedSprite = this._focusedSprite;
                        if (focusedSprite) {
                            if (ev.key == "Escape") {
                                // ESC pressed - lose current focus
                                blur();
                                this._focusedSprite = undefined;
                            }
                            let dragOffsetX = 0;
                            let dragOffsetY = 0;
                            // TODO: figure out if using bogus MouseEvent is fine, or it will
                            // fail on some platforms
                            const eventKey = getEventKey(ev);
                            switch (eventKey) {
                                case "Enter":
                                case " ":
                                    if (eventKey == " " && focusedSprite.get("role") != "checkbox") {
                                        return;
                                    }
                                    ev.preventDefault();
                                    const downEvent = renderer.getEvent(new MouseEvent("mouse"));
                                    focusedSprite.events.dispatch("click", {
                                        type: "click",
                                        originalEvent: downEvent.event,
                                        point: downEvent.point,
                                        simulated: true,
                                        target: focusedSprite
                                    });
                                    return;
                                case "ArrowLeft":
                                    dragOffsetX = -6;
                                    break;
                                case "ArrowRight":
                                    dragOffsetX = 6;
                                    break;
                                case "ArrowUp":
                                    dragOffsetY = -6;
                                    break;
                                case "ArrowDown":
                                    dragOffsetY = 6;
                                    break;
                                default:
                                    return;
                            }
                            if (dragOffsetX != 0 || dragOffsetY != 0) {
                                ev.preventDefault();
                                if (!focusedSprite.isDragging()) {
                                    // Start dragging
                                    this._keyboardDragPoint = {
                                        x: 0,
                                        y: 0
                                    };
                                    const downEvent = renderer.getEvent(new MouseEvent("mousedown", {
                                        clientX: 0,
                                        clientY: 0
                                    }));
                                    if (focusedSprite.events.isEnabled("pointerdown")) {
                                        focusedSprite.events.dispatch("pointerdown", {
                                            type: "pointerdown",
                                            originalEvent: downEvent.event,
                                            point: downEvent.point,
                                            simulated: true,
                                            target: focusedSprite
                                        });
                                    }
                                }
                                // Move incrementally
                                const dragPoint = this._keyboardDragPoint;
                                dragPoint.x += dragOffsetX;
                                dragPoint.y += dragOffsetY;
                                const moveEvent = renderer.getEvent(new MouseEvent("mousemove", {
                                    clientX: dragPoint.x,
                                    clientY: dragPoint.y
                                }), false);
                                if (focusedSprite.events.isEnabled("globalpointermove")) {
                                    focusedSprite.events.dispatch("globalpointermove", {
                                        type: "globalpointermove",
                                        originalEvent: moveEvent.event,
                                        point: moveEvent.point,
                                        simulated: true,
                                        target: focusedSprite
                                    });
                                }
                            }
                        }
                    }));
                    this._disposers.push(addEventListener(focusElementContainer, "keyup", (ev) => {
                        if (this._focusedSprite) {
                            const focusedSprite = this._focusedSprite;
                            const eventKey = getEventKey(ev);
                            switch (eventKey) {
                                case "ArrowLeft":
                                case "ArrowRight":
                                case "ArrowTop":
                                case "ArrowDown":
                                    if (focusedSprite.isDragging()) {
                                        // Simulate drag stop
                                        const dragPoint = this._keyboardDragPoint;
                                        const upEvent = renderer.getEvent(new MouseEvent("mouseup", {
                                            clientX: dragPoint.x,
                                            clientY: dragPoint.y
                                        }));
                                        if (focusedSprite.events.isEnabled("globalpointerup")) {
                                            focusedSprite.events.dispatch("globalpointerup", {
                                                type: "globalpointerup",
                                                originalEvent: upEvent.event,
                                                point: upEvent.point,
                                                simulated: true,
                                                target: focusedSprite
                                            });
                                        }
                                        //this._positionFocusElement(focusedSprite);
                                        this._keyboardDragPoint = undefined;
                                        // @todo dispatch mouseup event instead of calling dragStop?
                                        // this._dispatchEvent("globalpointerup", target, upEvent);
                                        return;
                                    }
                                    else if (focusedSprite.get("focusableGroup")) {
                                        // Find next item in focusable group
                                        const group = focusedSprite.get("focusableGroup");
                                        const items = this._tabindexes.filter((item) => {
                                            return item.get("focusableGroup") == group && item.getPrivate("focusable") !== false && item.isVisibleDeep() ? true : false;
                                        });
                                        let index = items.indexOf(focusedSprite);
                                        const lastIndex = items.length - 1;
                                        index += (eventKey == "ArrowRight" || eventKey == "ArrowDown") ? 1 : -1;
                                        if (index < 0) {
                                            index = lastIndex;
                                        }
                                        else if (index > lastIndex) {
                                            index = 0;
                                        }
                                        focus(items[index].getPrivate("focusElement").dom);
                                    }
                                    break;
                            }
                        }
                    }));
                }
            }
            this._startTicker();
            this.setThemes([]);
            this._addTooltip();
            if (!this._hasLicense()) {
                this._showBranding();
            }
        }
        _initResizeSensor() {
            if (this._resizeSensorDisposer) {
                this._resizeSensorDisposer.dispose();
            }
            this._resizeSensorDisposer = new ResizeSensor(this.dom, () => {
                if (this.autoResize) {
                    this.resize();
                }
            });
            this._disposers.push(this._resizeSensorDisposer);
        }
        /**
         * If automatic resizing of char is disabled (`root.autoResize = false`), it
         * can be resized manually by calling this method.
         */
        resize() {
            const rect = this._getRealSize();
            const size = this._getCalculatedSize(rect);
            const w = Math.floor(size.width);
            const h = Math.floor(size.height);
            if (w > 0 && h > 0) {
                const realWidth = Math.floor(rect.width);
                const realHeight = Math.floor(rect.height);
                const htmlElementContainer = this._htmlElementContainer;
                htmlElementContainer.style.width = w + "px";
                htmlElementContainer.style.height = h + "px";
                if (this._a11yD !== true) {
                    const focusElementContainer = this._focusElementContainer;
                    focusElementContainer.style.width = w + "px";
                    focusElementContainer.style.height = h + "px";
                }
                this._renderer.resize(realWidth, realHeight, w, h);
                const rootContainer = this._rootContainer;
                rootContainer.setPrivate("width", w);
                rootContainer.setPrivate("height", h);
                this._render();
                this._handleLogo();
            }
        }
        _render() {
            this._renderer.render(this._rootContainer._display);
            if (this._focusElementDirty) {
                this._updateCurrentFocus();
                this._focusElementDirty = false;
            }
        }
        _runTickers(currentTime) {
            each$1(this._tickers, (f) => {
                f(currentTime);
            });
        }
        _runAnimations(currentTime) {
            let running = 0;
            keepIf(this._animations, (animation) => {
                const state = animation._runAnimation(currentTime);
                if (state === AnimationState.Stopped) {
                    return false;
                }
                else if (state === AnimationState.Playing) {
                    ++running;
                    return true;
                }
                else {
                    return true;
                }
            });
            this._isDirtyAnimation = false;
            return running === 0;
        }
        _runDirties() {
            //console.log("tick **************************************************************");
            let allParents = {};
            while (this._isDirtyParents) {
                // This must be before calling _prepareChildren
                this._isDirtyParents = false;
                keys(this._dirtyParents).forEach((key) => {
                    const parent = this._dirtyParents[key];
                    delete this._dirtyParents[key];
                    if (!parent.isDisposed()) {
                        allParents[parent.uid] = parent;
                        parent._prepareChildren();
                    }
                });
            }
            keys(allParents).forEach((key) => {
                allParents[key]._updateChildren();
            });
            const objects = [];
            //		console.log("_beforeChanged")
            keys(this._dirty).forEach((key) => {
                const entity = this._dirty[key];
                if (entity.isDisposed()) {
                    delete this._dirty[entity.uid];
                }
                else {
                    objects.push(entity);
                    entity._beforeChanged();
                }
            });
            //		console.log("_changed")
            objects.forEach((entity) => {
                entity._changed();
                delete this._dirty[entity.uid];
                entity._clearDirty();
            });
            this._isDirty = false;
            const depths = {};
            const bounds = [];
            keys(this._dirtyBounds).forEach((key) => {
                const entity = this._dirtyBounds[key];
                delete this._dirtyBounds[key];
                if (!entity.isDisposed()) {
                    depths[entity.uid] = entity.depth();
                    bounds.push(entity);
                }
            });
            this._positionHTMLElements();
            // High depth -> low depth
            bounds.sort((x, y) => {
                return compare(depths[y.uid], depths[x.uid]);
            });
            //		console.log("_updateBounds")
            bounds.forEach((entity) => {
                entity._updateBounds();
            });
            //		console.log("_updatePosition")
            const dirtyPositions = this._dirtyPositions;
            keys(dirtyPositions).forEach((key) => {
                const sprite = dirtyPositions[key];
                delete dirtyPositions[key];
                if (!sprite.isDisposed()) {
                    sprite._updatePosition();
                }
            });
            //		console.log("_afterChanged")
            objects.forEach((entity) => {
                entity._afterChanged();
            });
        }
        _renderFrame(currentTime) {
            if (this._updateTick) {
                if (this.events.isEnabled("framestarted")) {
                    this.events.dispatch("framestarted", {
                        type: "framestarted",
                        target: this,
                        timestamp: currentTime,
                    });
                }
                this._checkComputedStyles();
                this._runTickers(currentTime);
                const animationDone = this._runAnimations(currentTime);
                this._runDirties();
                this._render();
                this._renderer.resetImageArray();
                this._positionHTMLElements();
                if (this.events.isEnabled("frameended")) {
                    this.events.dispatch("frameended", {
                        type: "frameended",
                        target: this,
                        timestamp: currentTime,
                    });
                }
                return this._tickers.length === 0 &&
                    animationDone &&
                    !this._isDirtyAnimation &&
                    !this._isDirty;
            }
            else {
                return true;
            }
        }
        _runTicker(currentTime, now) {
            if (!this.isDisposed()) {
                this.animationTime = currentTime;
                const done = this._renderFrame(currentTime);
                // No more work to do
                if (done) {
                    this._ticker = null;
                    this.animationTime = null;
                }
                else {
                    if (!this._paused) {
                        if (now) {
                            this._ticker;
                        }
                        else {
                            rAF(this.fps, this._ticker);
                        }
                    }
                }
            }
        }
        _runTickerNow(timeout = 10000) {
            if (!this.isDisposed()) {
                const endTime = performance.now() + timeout;
                for (;;) {
                    const currentTime = performance.now();
                    if (currentTime >= endTime) {
                        this.animationTime = null;
                        break;
                    }
                    this.animationTime = currentTime;
                    const done = this._renderFrame(currentTime);
                    if (done) {
                        this.animationTime = null;
                        break;
                    }
                }
            }
        }
        _startTicker() {
            if (this._ticker === null) {
                this.animationTime = null;
                this._ticker = (currentTime) => {
                    this._runTicker(currentTime);
                };
                rAF(this.fps, this._ticker);
            }
        }
        /**
         * Returns whether the root is updating or not.
         */
        get updateTick() {
            return this._updateTick;
        }
        /**
         * Enables or disables the root updating.
         */
        set updateTick(value) {
            this._updateTick = value;
            if (value) {
                this._startTicker();
            }
        }
        _addDirtyEntity(entity) {
            this._isDirty = true;
            if (this._dirty[entity.uid] === undefined) {
                this._dirty[entity.uid] = entity;
            }
            this._startTicker();
        }
        _addDirtyParent(parent) {
            this._isDirty = true;
            this._isDirtyParents = true;
            if (this._dirtyParents[parent.uid] === undefined) {
                this._dirtyParents[parent.uid] = parent;
            }
            this._startTicker();
        }
        _addDirtyBounds(entity) {
            this._isDirty = true;
            if (this._dirtyBounds[entity.uid] === undefined) {
                this._dirtyBounds[entity.uid] = entity;
            }
            this._startTicker();
        }
        _addDirtyPosition(sprite) {
            this._isDirty = true;
            if (this._dirtyPositions[sprite.uid] === undefined) {
                this._dirtyPositions[sprite.uid] = sprite;
            }
            this._startTicker();
        }
        _addAnimation(animation) {
            this._isDirtyAnimation = true;
            // TODO use numeric id instead
            if (this._animations.indexOf(animation) === -1) {
                this._animations.push(animation);
            }
            this._startTicker();
        }
        _markDirty() {
            this._isDirty = true;
        }
        _markDirtyRedraw() {
            this.events.once("frameended", () => {
                this._isDirty = true;
                this._startTicker();
            });
        }
        eachFrame(f) {
            this._tickers.push(f);
            this._startTicker();
            return new Disposer(() => {
                removeFirst(this._tickers, f);
            });
        }
        markDirtyGlobal(container) {
            if (!container) {
                container = this.container;
            }
            container.walkChildren((child) => {
                if (child instanceof Container) {
                    this.markDirtyGlobal(child);
                }
                child.markDirty();
                child.markDirtyBounds();
            });
        }
        /**
         * Returns width of the target container, in pixels.
         *
         * @return Width
         */
        width() {
            // TODO make this more efficient, maybe just return the renderer's width ?
            return Math.floor(this._getCalculatedSize(this._getRealSize()).width);
        }
        /**
         * Returns height of the target container, in pixels.
         *
         * @return Height
         */
        height() {
            // TODO make this more efficient, maybe just return the renderer's height ?
            return Math.floor(this._getCalculatedSize(this._getRealSize()).height);
        }
        /**
         * Disposes root and all the content in it.
         */
        dispose() {
            if (!this._isDisposed) {
                this._isDisposed = true;
                this._rootContainer.dispose();
                this._renderer.dispose();
                this.horizontalLayout.dispose();
                this.verticalLayout.dispose();
                this.interfaceColors.dispose();
                each$1(this._disposers, (x) => {
                    x.dispose();
                });
                if (this._inner) {
                    removeElement(this._inner);
                }
                remove(registry.rootElements, this);
            }
        }
        /**
         * Returns `true` if root element is disposed.
         *
         * @return Disposed?
         */
        isDisposed() {
            return this._isDisposed;
        }
        /**
         * Triggers screen reader read out a message.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
         * @param  text  Alert text
         */
        readerAlert(text) {
            if (this._a11yD !== true) {
                this._readerAlertElement.innerHTML = stripTags(text);
            }
        }
        /**
         * Sets themes to be used for the chart.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
         * @param  themes  A list of themes
         */
        setThemes(themes) {
            this._rootContainer.set("themes", themes);
            // otherwise new themes are not applied
            const tooltipContainer = this.tooltipContainer;
            if (tooltipContainer) {
                tooltipContainer._applyThemes();
            }
            // @todo review this
            const interfaceColors = this.interfaceColors;
            if (interfaceColors) {
                interfaceColors._applyThemes();
            }
        }
        _addTooltip() {
            if (!this.tooltipContainer) {
                const tooltipContainerSettings = this._tooltipContainerSettings;
                const tooltipContainer = this._rootContainer.children.push(Container.new(this, {
                    position: "absolute",
                    isMeasured: false,
                    width: p100,
                    height: p100,
                    layer: tooltipContainerSettings ? 35 : 30,
                    layerMargin: tooltipContainerSettings ? tooltipContainerSettings : undefined
                }));
                this.tooltipContainer = tooltipContainer;
                const tooltip = Tooltip.new(this, {});
                this.container.set("tooltip", tooltip);
                tooltip.hide(0);
                this._tooltip = tooltip;
            }
        }
        /**
         * Accesibility
         */
        _registerTabindexOrder(target) {
            if (this._a11yD == true) {
                return;
            }
            if (target.get("focusable")) {
                pushOne(this._tabindexes, target);
            }
            else {
                remove(this._tabindexes, target);
            }
            this._invalidateTabindexes();
        }
        _unregisterTabindexOrder(target) {
            if (this._a11yD == true) {
                return;
            }
            remove(this._tabindexes, target);
            this._invalidateTabindexes();
        }
        _invalidateTabindexes() {
            if (this._a11yD == true) {
                return;
            }
            this._tabindexes.sort((a, b) => {
                const aindex = a.get("tabindexOrder", 0);
                const bindex = b.get("tabindexOrder", 0);
                if (aindex == bindex) {
                    return 0;
                }
                else if (aindex > bindex) {
                    return 1;
                }
                else {
                    return -1;
                }
            });
            const groups = [];
            each$1(this._tabindexes, (item, index) => {
                if (!item.getPrivate("focusElement")) {
                    this._makeFocusElement(index, item);
                }
                else {
                    this._moveFocusElement(index, item);
                }
                const group = item.get("focusableGroup");
                if (group && item.getPrivate("focusable") !== false) {
                    if (groups.indexOf(group) !== -1) {
                        // Non-first element in the group, make it not directly focusable
                        item.getPrivate("focusElement").dom.setAttribute("tabindex", "-1");
                    }
                    else {
                        groups.push(group);
                    }
                }
            });
        }
        _updateCurrentFocus() {
            if (this._a11yD == true) {
                return;
            }
            if (this._focusedSprite) {
                this._decorateFocusElement(this._focusedSprite);
                this._positionFocusElement(this._focusedSprite);
            }
        }
        _decorateFocusElement(target, focusElement) {
            if (this._a11yD == true) {
                return;
            }
            // Decorate with proper accessibility attributes
            if (!focusElement) {
                focusElement = target.getPrivate("focusElement").dom;
            }
            if (!focusElement) {
                return;
            }
            const role = target.get("role");
            if (role) {
                focusElement.setAttribute("role", role);
            }
            else {
                focusElement.removeAttribute("role");
            }
            const ariaLabel = target.get("ariaLabel");
            if (ariaLabel) {
                const label = populateString(target, ariaLabel);
                focusElement.setAttribute("aria-label", label);
            }
            else {
                focusElement.removeAttribute("aria-label");
            }
            const ariaLive = target.get("ariaLive");
            if (ariaLive) {
                focusElement.setAttribute("aria-live", ariaLive);
            }
            else {
                focusElement.removeAttribute("aria-live");
            }
            const ariaChecked = target.get("ariaChecked");
            if (ariaChecked != null && role && ["checkbox", "option", "radio", "menuitemcheckbox", "menuitemradio", "treeitem"].indexOf(role) !== -1) {
                focusElement.setAttribute("aria-checked", ariaChecked ? "true" : "false");
            }
            else {
                focusElement.removeAttribute("aria-checked");
            }
            const ariaCurrent = target.get("ariaCurrent");
            if (ariaCurrent != null) {
                focusElement.setAttribute("aria-current", ariaCurrent);
            }
            else {
                focusElement.removeAttribute("aria-current");
            }
            const ariaSelected = target.get("ariaSelected");
            if (ariaSelected != null && role && ["gridcell", "option", "row", "tab", "columnheader", "rowheader", "treeitem"].indexOf(role) !== -1) {
                focusElement.setAttribute("aria-selected", ariaSelected ? "true" : "false");
            }
            else {
                focusElement.removeAttribute("aria-selected");
            }
            if (target.get("ariaHidden")) {
                focusElement.setAttribute("aria-hidden", "true");
            }
            else {
                focusElement.removeAttribute("aria-hidden");
            }
            const ariaOrientation = target.get("ariaOrientation");
            if (ariaOrientation) {
                focusElement.setAttribute("aria-orientation", ariaOrientation);
            }
            else {
                focusElement.removeAttribute("aria-orientation");
            }
            const ariaValueNow = target.get("ariaValueNow");
            if (ariaValueNow) {
                focusElement.setAttribute("aria-valuenow", ariaValueNow);
            }
            else {
                focusElement.removeAttribute("aria-valuenow");
            }
            const ariaValueMin = target.get("ariaValueMin");
            if (ariaValueMin) {
                focusElement.setAttribute("aria-valuemin", ariaValueMin);
            }
            else {
                focusElement.removeAttribute("aria-valuemin");
            }
            const ariaValueMax = target.get("ariaValueMax");
            if (ariaValueMax) {
                focusElement.setAttribute("aria-valuemax", ariaValueMax);
            }
            else {
                focusElement.removeAttribute("aria-valuemax");
            }
            const ariaValueText = target.get("ariaValueText");
            if (ariaValueText) {
                focusElement.setAttribute("aria-valuetext", ariaValueText);
            }
            else {
                focusElement.removeAttribute("aria-valuetext");
            }
            const ariaControls = target.get("ariaControls");
            if (ariaControls) {
                focusElement.setAttribute("aria-controls", ariaControls);
            }
            else {
                focusElement.removeAttribute("aria-controls");
            }
            if (target.get("visible") && target.get("opacity") !== 0 && target.get("role") != "tooltip" && !target.isHidden() && target.getPrivate("focusable") !== false) {
                if (focusElement.getAttribute("tabindex") != "-1") {
                    focusElement.setAttribute("tabindex", "" + this.tabindex);
                }
                focusElement.removeAttribute("aria-hidden");
            }
            else {
                focusElement.removeAttribute("tabindex");
                focusElement.setAttribute("aria-hidden", "true");
            }
        }
        _makeFocusElement(index, target) {
            if (target.getPrivate("focusElement") || this._a11yD == true) {
                return;
            }
            // Init
            const focusElement = document.createElement("div");
            if (target.get("role") != "tooltip") {
                focusElement.tabIndex = this.tabindex;
            }
            focusElement.style.position = "absolute";
            setInteractive(focusElement, false);
            const disposers = [];
            target.setPrivate("focusElement", {
                dom: focusElement,
                disposers,
            });
            this._decorateFocusElement(target);
            disposers.push(addEventListener(focusElement, "focus", (ev) => {
                this._handleFocus(ev);
            }));
            disposers.push(addEventListener(focusElement, "blur", (ev) => {
                this._handleBlur(ev);
            }));
            this._moveFocusElement(index, target);
        }
        _removeFocusElement(target) {
            if (this._a11yD == true) {
                return;
            }
            remove(this._tabindexes, target);
            const focusElement = target.getPrivate("focusElement");
            if (focusElement) {
                const container = this._focusElementContainer;
                container.removeChild(focusElement.dom);
                each$1(focusElement.disposers, (x) => {
                    x.dispose();
                });
            }
        }
        _hideFocusElement(target) {
            if (this._a11yD == true) {
                return;
            }
            const focusElement = target.getPrivate("focusElement");
            focusElement.dom.style.display = "none";
        }
        _moveFocusElement(index, target) {
            if (this._a11yD == true) {
                return;
            }
            // Get container
            const container = this._focusElementContainer;
            const focusElement = target.getPrivate("focusElement").dom;
            if (focusElement === this._focusElementContainer.children[index]) {
                // Nothing to do
                return;
            }
            const next = this._focusElementContainer.children[index + 1];
            if (next) {
                container.insertBefore(focusElement, next);
            }
            else {
                container.append(focusElement);
            }
        }
        _positionFocusElement(target) {
            if (this._a11yD == true || target == undefined) {
                return;
            }
            const bounds = target.globalBounds();
            let width = bounds.right == bounds.left ? target.width() : bounds.right - bounds.left;
            let height = bounds.top == bounds.bottom ? target.height() : bounds.bottom - bounds.top;
            const padding = this._settings.focusPadding !== undefined ? this._settings.focusPadding : 2;
            let x = bounds.left - padding;
            let y = bounds.top - padding;
            if (width < 0) {
                x += width;
                width = Math.abs(width);
            }
            if (height < 0) {
                y += height;
                height = Math.abs(height);
            }
            const focusElement = target.getPrivate("focusElement").dom;
            focusElement.style.top = y + "px";
            focusElement.style.left = x + "px";
            focusElement.style.width = (width + padding * 2) + "px";
            focusElement.style.height = (height + padding * 2) + "px";
        }
        _getSpriteByFocusElement(target) {
            let found;
            eachContinue$1(this._tabindexes, (item, _index) => {
                if (item.getPrivate("focusElement").dom === target) {
                    found = item;
                    return false;
                }
                return true;
            });
            return found;
        }
        _handleFocus(ev) {
            if (this._a11yD == true) {
                return;
            }
            // Get element
            //const focused = this._tabindexes[index];
            const focused = this._getSpriteByFocusElement(ev.target);
            if (!focused) {
                return;
            }
            // Jump over hidden elements
            if (!focused.isVisibleDeep()) {
                this._focusNext(ev.target, this._isShift ? -1 : 1);
                return;
            }
            // Size and position
            this._positionFocusElement(focused);
            //this._decorateFocusElement(focused);
            this._focusedSprite = focused;
            if (focused.events.isEnabled("focus")) {
                focused.events.dispatch("focus", {
                    type: "focus",
                    originalEvent: ev,
                    target: focused
                });
            }
        }
        _focusNext(el, direction) {
            if (this._a11yD == true) {
                return;
            }
            const focusableElements = Array.from(document.querySelectorAll([
                'a[href]',
                'area[href]',
                'button:not([disabled])',
                'details',
                'input:not([disabled])',
                'iframe:not([disabled])',
                'select:not([disabled])',
                'textarea:not([disabled])',
                '[contentEditable=""]',
                '[contentEditable="true"]',
                '[contentEditable="TRUE"]',
                '[tabindex]:not([tabindex^="-"])',
                //':not([disabled])'
            ].join(',')));
            let index = focusableElements.indexOf(el) + direction;
            if (index < 0) {
                index = focusableElements.length - 1;
            }
            else if (index >= focusableElements.length) {
                index = 0;
            }
            focusableElements[index].focus();
        }
        _handleBlur(ev) {
            if (this._a11yD == true) {
                return;
            }
            const focused = this._focusedSprite;
            if (focused && !focused.isDisposed() && focused.events.isEnabled("blur")) {
                focused.events.dispatch("blur", {
                    type: "blur",
                    originalEvent: ev,
                    target: focused
                });
            }
            this._focusedSprite = undefined;
        }
        /**
         * @ignore
         */
        updateTooltip(target) {
            if (this._a11yD == true) {
                return;
            }
            const text = stripTags(target._getText());
            let tooltipElement = target.getPrivate("tooltipElement");
            if (target.get("role") == "tooltip" && text != "") {
                if (!tooltipElement) {
                    tooltipElement = this._makeTooltipElement(target);
                }
                if (tooltipElement.innerHTML != text) {
                    tooltipElement.innerHTML = text;
                }
                tooltipElement.setAttribute("aria-hidden", target.isVisibleDeep() ? "false" : "true");
            }
            else if (tooltipElement) {
                tooltipElement.remove();
                target.removePrivate("tooltipElement");
            }
        }
        _makeTooltipElement(target) {
            const container = this._tooltipElementContainer;
            const tooltipElement = document.createElement("div");
            tooltipElement.style.position = "absolute";
            tooltipElement.style.width = "1px";
            tooltipElement.style.height = "1px";
            tooltipElement.style.overflow = "hidden";
            tooltipElement.style.clip = "rect(1px, 1px, 1px, 1px)";
            setInteractive(tooltipElement, false);
            this._decorateFocusElement(target, tooltipElement);
            container.append(tooltipElement);
            target.setPrivate("tooltipElement", tooltipElement);
            return tooltipElement;
        }
        _removeTooltipElement(target) {
            if (this._a11yD == true) {
                return;
            }
            const tooltipElement = target.getPrivate("tooltipElement");
            if (tooltipElement) {
                const parent = tooltipElement.parentElement;
                if (parent) {
                    parent.removeChild(tooltipElement);
                }
            }
        }
        _invalidateAccessibility(target) {
            if (this._a11yD == true) {
                return;
            }
            this._focusElementDirty = true;
            const focusElement = target.getPrivate("focusElement");
            if (target.get("focusable")) {
                if (focusElement) {
                    this._decorateFocusElement(target);
                    this._positionFocusElement(target);
                }
                // else {
                // 	this._renderer._makeFocusElement(0, this);
                // }
            }
            else if (focusElement) {
                this._removeFocusElement(target);
            }
            //this.updateCurrentFocus();
        }
        /**
         * Returns `true` if `target` is currently focused.
         *
         * @param   target  Target
         * @return          Focused?
         */
        focused(target) {
            return this._focusedSprite === target;
        }
        /**
         * Converts document coordinates to coordinates withing root element.
         *
         * @param   point  Document point
         * @return         Root point
         */
        documentPointToRoot(point) {
            const rect = this._getRealSize();
            const size = this._getCalculatedSize(rect);
            const scaleWidth = size.width / rect.width;
            const scaleHeight = size.height / rect.height;
            return {
                x: (point.x - rect.left) * scaleWidth,
                y: (point.y - rect.top) * scaleHeight,
            };
        }
        /**
         * Converts root coordinates to document
         *
         * @param   point  Document point
         * @return         Root point
         */
        rootPointToDocument(point) {
            const rect = this._getRealSize();
            const size = this._getCalculatedSize(rect);
            const scaleWidth = size.width / rect.width;
            const scaleHeight = size.height / rect.height;
            return {
                x: (point.x / scaleWidth) + rect.left,
                y: (point.y / scaleHeight) + rect.top
            };
        }
        /**
         * @ignore
         */
        addDisposer(disposer) {
            this._disposers.push(disposer);
            return disposer;
        }
        _updateComputedStyles() {
            const styles = window.getComputedStyle(this.dom);
            let fontHash = "";
            each(styles, (key, val) => {
                if (isString(key) && key.match(/^font/)) {
                    fontHash += val;
                }
            });
            const changed = fontHash != this._fontHash;
            if (changed) {
                this._fontHash = fontHash;
            }
            return changed;
        }
        _checkComputedStyles() {
            if (this._updateComputedStyles()) {
                this._invalidateLabelBounds(this.container);
            }
        }
        _invalidateLabelBounds(target) {
            if (target instanceof Container) {
                target.children.each((child) => {
                    this._invalidateLabelBounds(child);
                });
            }
            else if (target instanceof Text) {
                target.markDirtyBounds();
            }
        }
        /**
         * To all the clever heads out there. Yes, we did not make any attempts to
         * scramble this.
         *
         * This is a part of a tool meant for our users to manage their commercial
         * licenses for removal of amCharts branding from charts.
         *
         * The only legit way to do so is to purchase a commercial license for amCharts:
         * https://www.amcharts.com/online-store/
         *
         * Removing or altering this code, or disabling amCharts branding in any other
         * way is against the license and thus illegal.
         */
        _hasLicense() {
            for (let i = 0; i < registry.licenses.length; i++) {
                if (registry.licenses[i].match(/^AM5C.{5,}/i)) {
                    return true;
                }
            }
            return false;
        }
        _licenseApplied() {
            if (this._logo) {
                this._logo.set("forceHidden", true);
            }
        }
        /**
         * @ignore
         */
        get debugGhostView() {
            return this._renderer.debugGhostView;
        }
        /**
         * @ignore
         */
        set debugGhostView(value) {
            this._renderer.debugGhostView = value;
        }
        /**
         * Set this to `true` if you need chart to require first a tap onto it before
         * touch gesture related functionality like zoom/pan is turned on.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
         * @default false
         * @since 5.2.9
         * @param  value  Needs a tap to activate touch functions
         */
        set tapToActivate(value) {
            this._renderer.tapToActivate = value;
        }
        /**
         * @return Needs a tap to activate touch functions
         */
        get tapToActivate() {
            return this._renderer.tapToActivate;
        }
        /**
         * If `tapToActivate` is set to `true`, this setting will determine number
         * of milliseconds the chart will stay "active", before releasing the
         * controls back to the page.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
         * @default 3000
         * @since 5.2.9
         * @param  value  Timeout
         */
        set tapToActivateTimeout(value) {
            this._renderer.tapToActivateTimeout = value;
        }
        /**
         * @return Timeout
         */
        get tapToActivateTimeout() {
            return this._renderer.tapToActivateTimeout;
        }
        _makeHTMLElement(target) {
            // Get container
            const container = this._htmlElementContainer;
            // Init
            const htmlElement = document.createElement("div");
            target.setPrivate("htmlElement", htmlElement);
            //htmlElement.tabIndex = this.tabindex;
            htmlElement.style.position = "absolute";
            htmlElement.style.overflow = "auto";
            htmlElement.style.boxSizing = "border-box";
            setInteractive(htmlElement, target.get("interactive", false));
            // Translate events
            if (target.events.isEnabled("click")) {
                setInteractive(htmlElement, true);
                this._disposers.push(addEventListener(htmlElement, "click", (ev) => {
                    const downEvent = this._renderer.getEvent(ev);
                    target.events.dispatch("click", {
                        type: "click",
                        originalEvent: downEvent.event,
                        point: downEvent.point,
                        simulated: false,
                        target: target
                    });
                }));
            }
            this._positionHTMLElement(target);
            container.append(htmlElement);
            pushOne(this._htmlEnabledContainers, target);
            return htmlElement;
        }
        _positionHTMLElements() {
            each$1(this._htmlEnabledContainers, (target) => {
                this._positionHTMLElement(target);
            });
        }
        _positionHTMLElement(target) {
            const htmlElement = target.getPrivate("htmlElement");
            if (htmlElement) {
                // Translate settings
                const visualSettings = ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "minWidth", "minHeight", "maxWidth", "maxHeight"];
                each$1(visualSettings, (setting) => {
                    const value = target.get(setting);
                    if (value) {
                        htmlElement.style[setting] = value + "px";
                    }
                    else {
                        htmlElement.style[setting] = "";
                    }
                });
                // Init and reset scale / rotation
                const scale = target.compositeScale() || 1;
                const rotation = target.compositeRotation() || 0;
                htmlElement.style.transform = "";
                htmlElement.style.transformOrigin = "";
                // Deal with opacity
                const opacity = target.compositeOpacity();
                setTimeout(() => {
                    htmlElement.style.opacity = opacity + "";
                }, 10);
                const visible = target.isVisibleDeep();
                if (visible) {
                    htmlElement.style.display = "block";
                }
                // Deal with position
                const bounds = target.globalBounds();
                htmlElement.style.top = (bounds.top) + "px";
                htmlElement.style.left = (bounds.left) + "px";
                // Use width/height if those are set
                const width = target.get("width");
                const height = target.get("height");
                let w = 0;
                let h = 0;
                if (width) {
                    w = target.width();
                }
                if (height) {
                    h = target.height();
                }
                if (!width || !height) {
                    htmlElement.style.position = "fixed";
                    htmlElement.style.width = "";
                    htmlElement.style.height = "";
                    const bbox = htmlElement.getBoundingClientRect();
                    htmlElement.style.position = "absolute";
                    if (!width)
                        w = bbox.width;
                    if (!height)
                        h = bbox.height;
                    target._adjustedLocalBounds = { left: 0, right: 0, top: 0, bottom: 0 };
                    target.setPrivate("minWidth", w / scale);
                    target.setPrivate("minHeight", h / scale);
                }
                else {
                    target.removePrivate("minWidth");
                    target.removePrivate("minHeight");
                }
                if (w > 0) {
                    htmlElement.style.minWidth = (w) + "px";
                }
                if (h > 0) {
                    htmlElement.style.minHeight = (h) + "px";
                }
                // Hide or show
                if (!visible || opacity == 0) {
                    htmlElement.style.display = "none";
                }
                // Deal with scale
                if (scale != 1) {
                    htmlElement.style.transform += "scale(" + scale + ")";
                }
                if (rotation != 0) {
                    htmlElement.style.transform += " rotate(" + rotation + "deg)";
                }
                if (htmlElement.style.transform != "") {
                    htmlElement.style.transformOrigin = target.get("centerX", 0) + "%  " + target.get("centerY", 0) + "%";
                }
            }
        }
        _setHTMLContent(target, html) {
            let htmlElement = target.getPrivate("htmlElement");
            if (!htmlElement) {
                htmlElement = this._makeHTMLElement(target);
            }
            if (htmlElement.innerHTML != html) {
                htmlElement.innerHTML = html;
            }
        }
        _removeHTMLContent(target) {
            let htmlElement = target.getPrivate("htmlElement");
            if (htmlElement) {
                this._htmlElementContainer.removeChild(htmlElement);
                target.removePrivate("htmlElement");
            }
            remove(this._htmlEnabledContainers, target);
        }
    }

    /**
     * @ignore
     */
    let rules;
    /**
     * @ignore
     */
    function modalCSS(element, root, _prefix) {
        const ic = root.interfaceColors;
        const active = ic.get("secondaryButton").toCSS();
        const text = ic.get("text").toCSS();
        const shadow = ic.get("alternativeBackground").toCSS(0.45);
        //const altbg = ic.get("alternativeBackground")!.toCSS();
        if (!rules) {
            const disposer = new MultiDisposer([
                new StyleRule(element, ".am5-modal", {
                    "width": "100%",
                    "height": "100%",
                    "position": "absolute",
                    "z-index": "100000",
                    "top": "0",
                    "left": "0"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-curtain", {
                    "top": "0",
                    "left": "0",
                    "width": "100%",
                    "height": "100%",
                    "position": "absolute",
                    "background": ic.get("background").toCSS(0.5),
                    "z-index": "100"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-wrapper", {
                    "top": "0",
                    "left": "0",
                    "width": "100%",
                    "height": "100%",
                    "position": "absolute",
                    "text-align": "center",
                    "white-space": "nowrap",
                    "background": ic.get("background").toCSS(0.5),
                    "z-index": "101"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-wrapper:before", {
                    "content": "''",
                    "display": "inline-block",
                    "height": "100%",
                    "vertical-align": "middle",
                    "margin-right": "-0.25em"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-content", {
                    "display": "inline-block",
                    "padding": "1.2em",
                    "vertical-align": "middle",
                    "text-align": "left",
                    "white-space": "normal",
                    "background": ic.get("background").toCSS(),
                    //"border": "1px solid " + ic.get("alternativeBackground")!.toCSS(),
                    "border-radius": "4px",
                    "-webkit-box-shadow": "0px 0px 36px 0px " + shadow,
                    "box-shadow": "0px 0px 36px 0px " + shadow,
                    "color": text
                }, root.nonce),
                new StyleRule(element, ".am5-modal-content h1", {
                    "font-size": "1em",
                    "margin": "0 0 0.5em 0"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-table", {
                    "display": "table",
                    "margin": "1em 0"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-table-row", {
                    "display": "table-row"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-table-heading", {
                    "display": "table-heading",
                    "padding": "3px 10px 3px 0",
                }, root.nonce),
                new StyleRule(element, ".am5-modal-table-cell", {
                    "display": "table-cell",
                    "padding": "3px 0 3px 0",
                }, root.nonce),
                new StyleRule(element, ".am5-modal-table-cell > *", {
                    "vertical-align": "middle"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-content input[type=text], .am5-modal-content input[type=number], .am5-modal-content select", {
                    "border": "1px solid " + active,
                    "border-radius": "4px",
                    "padding": "3px 5px",
                    "margin": "2px"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-input-narrow", {
                    "width": "50px"
                }, root.nonce),
                new StyleRule(element, ".am5-modal-button", {
                    "font-weight": "400",
                    "color": ic.get("secondaryButtonText").toCSS(),
                    "line-height": "1.5",
                    "text-align": "center",
                    "text-decoration": "none",
                    "vertical-align": "middle",
                    "cursor": "pointer",
                    "padding": "0.2em 0.8em",
                    "font-size": "1em",
                    "border-radius": "0.25em",
                    "margin": "0 0.25em 0 0",
                    "border": "1px solid " + ic.get("secondaryButtonStroke").toCSS(),
                    "background": ic.get("secondaryButton").toCSS()
                }, root.nonce),
                new StyleRule(element, ".am5-modal-button:hover", {
                    "background": ic.get("secondaryButtonHover").toCSS()
                }, root.nonce),
                new StyleRule(element, ".am5-modal-button.am5-modal-primary", {
                    "color": ic.get("primaryButtonText").toCSS(),
                    "border": "1px solid " + ic.get("primaryButtonStroke").toCSS(),
                    "background": ic.get("primaryButton").toCSS()
                }, root.nonce),
                new StyleRule(element, ".am5-modal-button.am5-modal-primary:hover", {
                    "background": ic.get("primaryButtonHover").toCSS()
                }, root.nonce),
            ]);
            rules = new CounterDisposer(() => {
                rules = undefined;
                disposer.dispose();
            });
        }
        return rules.increment();
    }
    /**
     * Used to display a modal dialog with HTML content.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/modal-popups/} for more info
     */
    class Modal extends Entity {
        //protected _currentPass: number = 0;
        _afterNew() {
            // Applying themes because this will not have parents
            super._afterNewApplyThemes();
            // Defaults
            this._setRawDefault("deactivateRoot", true);
            // Load CSS
            modalCSS(getShadowRoot(this._root.dom), this._root);
            // Create elements
            const container = document.createElement("div");
            container.className = "am5-modal";
            container.style.display = "none";
            this.root._inner.appendChild(container);
            this.setPrivate("container", container);
            const curtain = document.createElement("div");
            curtain.className = "am5-modal-curtain";
            container.appendChild(curtain);
            this.setPrivate("curtain", curtain);
            this._disposers.push(addEventListener(curtain, "click", () => {
                this.cancel();
            }));
            const wrapper = document.createElement("div");
            wrapper.className = "am5-modal-wrapper";
            container.appendChild(wrapper);
            this.setPrivate("wrapper", wrapper);
            const content = document.createElement("div");
            content.className = "am5-modal-content";
            wrapper.appendChild(content);
            this.setPrivate("content", content);
            const html = this.get("content");
            if (html) {
                content.innerHTML = html;
            }
            // Close on ESC
            if (supports("keyboardevents")) {
                this._disposers.push(addEventListener(document, "keydown", (ev) => {
                    if (this.isOpen() && getEventKey(ev) == "Escape") {
                        this.cancel();
                    }
                }));
            }
        }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("content")) {
                this.getPrivate("content").innerHTML = this.get("content", "");
            }
        }
        /**
         * Returns `true` if modal is currently open.
         *
         * @return  Modal open?
         */
        isOpen() {
            return this.getPrivate("container").style.display != "none";
        }
        /**
         * Opens modal.
         */
        open() {
            this.getPrivate("container").style.display = "block";
            if (this.get("deactivateRoot")) {
                this.setTimeout(() => {
                    this._root._renderer.interactionsEnabled = false;
                }, 10);
            }
            this.events.dispatch("opened", {
                type: "opened",
                target: this
            });
        }
        /**
         * Closes modal.
         */
        close() {
            this.getPrivate("container").style.display = "none";
            if (this.get("deactivateRoot")) {
                this._root._renderer.interactionsEnabled = true;
            }
            this.events.dispatch("closed", {
                type: "closed",
                target: this
            });
        }
        /**
         * Closes modal and invokes `cancelled` event.
         */
        cancel() {
            this.getPrivate("container").style.display = "none";
            if (this.get("deactivateRoot")) {
                this._root._renderer.interactionsEnabled = true;
            }
            this.events.dispatch("cancelled", {
                type: "cancelled",
                target: this
            });
        }
        /**
         * Disposes modal.
         */
        dispose() {
            super.dispose();
            const container = this.getPrivate("container");
            if (container.parentElement) {
                container.parentElement.removeChild(container);
            }
        }
    }
    Object.defineProperty(Modal, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Modal"
    });
    Object.defineProperty(Modal, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([Modal.className])
    });

    /**
     * A universal placeholder for bullet elements.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info
     */
    class Bullet extends Entity {
        constructor() {
            super(...arguments);
            // used by MapPolygons where one data item can have multiple bullets of the same kind
            Object.defineProperty(this, "_index", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * Target series object if it's a bullet for series.
             */
            Object.defineProperty(this, "series", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _afterNew() {
            // Applying themes because bullet will not have parent
            super._afterNewApplyThemes();
        }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("sprite")) {
                const sprite = this.get("sprite");
                if (sprite) {
                    sprite.setAll({ position: "absolute", role: "figure" });
                    this._disposers.push(sprite);
                }
            }
            if (this.isDirty("locationX") || this.isDirty("locationY")) {
                if (this.series) {
                    this.series._positionBullet(this);
                }
            }
        }
    }
    Object.defineProperty(Bullet, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Bullet"
    });
    Object.defineProperty(Bullet, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([Bullet.className])
    });

    /**
     * Draws a rectangle with rounded corners.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     * @important
     */
    class RoundedRectangle extends Rectangle {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) {
                this._clear = true;
            }
        }
        _draw() {
            let width = this.width();
            let height = this.height();
            let w = width;
            let h = height;
            let wSign = w / Math.abs(width);
            let hSign = h / Math.abs(height);
            if (isNumber(w) && isNumber(h)) {
                let minSide = Math.min(w, h) / 2;
                let crtl = relativeToValue(this.get("cornerRadiusTL", 8), minSide);
                let crtr = relativeToValue(this.get("cornerRadiusTR", 8), minSide);
                let crbr = relativeToValue(this.get("cornerRadiusBR", 8), minSide);
                let crbl = relativeToValue(this.get("cornerRadiusBL", 8), minSide);
                let maxcr = Math.min(Math.abs(w / 2), Math.abs(h / 2));
                crtl = fitToRange(crtl, 0, maxcr);
                crtr = fitToRange(crtr, 0, maxcr);
                crbr = fitToRange(crbr, 0, maxcr);
                crbl = fitToRange(crbl, 0, maxcr);
                const display = this._display;
                display.moveTo(crtl * wSign, 0);
                display.lineTo(w - crtr * wSign, 0);
                if (crtr > 0) {
                    display.arcTo(w, 0, w, crtr * hSign, crtr);
                }
                display.lineTo(w, h - crbr * hSign);
                if (crbr > 0) {
                    display.arcTo(w, h, w - crbr * wSign, h, crbr);
                }
                display.lineTo(crbl * wSign, h);
                if (crbl > 0) {
                    display.arcTo(0, h, 0, h - crbl * hSign, crbl);
                }
                display.lineTo(0, crtl * hSign);
                if (crtl > 0) {
                    display.arcTo(0, 0, crtl * wSign, 0, crtl);
                }
                display.closePath();
            }
        }
    }
    Object.defineProperty(RoundedRectangle, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RoundedRectangle"
    });
    Object.defineProperty(RoundedRectangle, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Rectangle.classNames.concat([RoundedRectangle.className])
    });

    /**
     * Draws an interactive button.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/buttons/} for more info
     * @important
     */
    class Button extends Container {
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["button"]);
            super._afterNew();
            if (!this._settings.background) {
                this.set("background", RoundedRectangle.new(this._root, {
                    themeTags: mergeTags(this._settings.themeTags, ["background"])
                }));
            }
            this.setPrivate("trustBounds", true);
        }
        _prepareChildren() {
            super._prepareChildren();
            if (this.isDirty("icon")) {
                const previous = this._prevSettings.icon;
                const icon = this.get("icon");
                if (icon !== previous) {
                    this._disposeProperty("icon");
                    if (previous) {
                        previous.dispose();
                    }
                    if (icon) {
                        this.children.push(icon);
                    }
                    this._prevSettings.icon = icon;
                }
            }
            if (this.isDirty("label")) {
                const previous = this._prevSettings.label;
                const label = this.get("label");
                if (label !== previous) {
                    this._disposeProperty("label");
                    if (previous) {
                        previous.dispose();
                    }
                    if (label) {
                        this.children.push(label);
                    }
                    this._prevSettings.label = label;
                }
            }
        }
    }
    Object.defineProperty(Button, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Button"
    });
    Object.defineProperty(Button, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Button.className])
    });

    /**
     * Draws a circle.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     * @important
     */
    class Circle extends Graphics {
        _afterNew() {
            super._afterNew();
            this._display.isMeasured = true;
            this.setPrivateRaw("trustBounds", true);
        }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("radius")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear) {
                this._display.drawCircle(0, 0, Math.abs(this.get("radius", 10)));
            }
        }
    }
    Object.defineProperty(Circle, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Circle"
    });
    Object.defineProperty(Circle, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Circle.className])
    });

    /**
     * Draws a polygon.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/polygon/} for more info
     * @important
     * @since 5.4.0
     */
    class Polygon extends Graphics {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "morphAnimation", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("coordinates")) {
                const points = [];
                const coordinates = this.get("coordinates");
                if (coordinates) {
                    each$1(coordinates, (coord) => {
                        points.push({ x: coord[0], y: coord[1] });
                    });
                }
                this.set("points", points);
            }
            if (this.isPrivateDirty("points")) {
                this._clear = true;
            }
            if (this.isDirty("points")) {
                this._clear = true;
                const points = this.get("points");
                const prevPoints = this._prevSettings.points;
                if (prevPoints) {
                    if (points) {
                        let copy = copy$2(points);
                        let prevCopy = copy$2(prevPoints);
                        let cl = copy.length;
                        let pl = prevCopy.length;
                        if (cl > pl) {
                            let newCopy = copy$2(copy);
                            for (let i = 0; i < cl; i++) {
                                let index = Math.floor(i / cl * pl);
                                newCopy[i] = { x: prevCopy[index].x, y: prevCopy[index].y };
                            }
                            prevCopy = newCopy;
                        }
                        else if (pl > cl) {
                            let newCopy = copy$2(prevCopy);
                            for (let i = 0; i < pl; i++) {
                                let index = Math.floor(i / pl * cl);
                                newCopy[i] = { x: copy[index].x, y: copy[index].y };
                            }
                            copy = newCopy;
                        }
                        this.setPrivateRaw("previousPoints", prevCopy);
                        this.setPrivateRaw("points", copy);
                        this.morphAnimation = this.animatePrivate({ key: "morphProgress", from: 0, to: 1, duration: this.get("animationDuration", 0), easing: this.get("animationEasing") });
                        // solves no animated theme
                        this._root.events.once("frameended", () => {
                            this._markDirtyPrivateKey("morphProgress");
                        });
                    }
                }
                else {
                    this.setPrivateRaw("previousPoints", points);
                    this.setPrivateRaw("points", points);
                }
                let minX = Infinity;
                let maxX = -Infinity;
                let minY = Infinity;
                let maxY = -Infinity;
                if (points) {
                    for (let i = 1, len = points.length; i < len; i++) {
                        const point = points[i];
                        minX = Math.min(minX, point.x);
                        maxX = Math.max(maxX, point.x);
                        minY = Math.min(minY, point.y);
                        maxY = Math.max(maxY, point.y);
                    }
                }
                this.setPrivate("minX", minX);
                this.setPrivate("maxX", maxX);
                this.setPrivate("minY", minY);
                this.setPrivate("maxY", minY);
            }
            if (this.isPrivateDirty("morphProgress")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear) {
                this._draw();
            }
        }
        _draw() {
            const previousPoints = this.getPrivate("previousPoints");
            const points = this.getPrivate("points");
            const morphProgress = this.getPrivate("morphProgress", 1);
            if (points && previousPoints) {
                const first = points[0];
                const prevFirst = previousPoints[0];
                if (first) {
                    this._display.moveTo(prevFirst.x + (first.x - prevFirst.x) * morphProgress, prevFirst.y + (first.y - prevFirst.y) * morphProgress);
                }
                for (let i = 1, len = points.length; i < len; i++) {
                    const point = points[i];
                    const prevPoint = previousPoints[i];
                    this._display.lineTo(prevPoint.x + (point.x - prevPoint.x) * morphProgress, prevPoint.y + (point.y - prevPoint.y) * morphProgress);
                }
                this._display.closePath();
            }
        }
        _updateSize() {
            this.markDirty();
            this._clear = true;
        }
    }
    Object.defineProperty(Polygon, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Polygon"
    });
    Object.defineProperty(Polygon, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Polygon.className])
    });

    /**
     * Draws a Ellipse.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     * @important
     */
    class Ellipse extends Graphics {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("radiusX") || this.isDirty("radiusY") || this.isDirty("rotation")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear) {
                this._display.drawEllipse(0, 0, Math.abs(this.get("radiusX")), Math.abs(this.get("radiusY")));
            }
        }
    }
    Object.defineProperty(Ellipse, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Ellipse"
    });
    Object.defineProperty(Ellipse, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Ellipse.className])
    });

    /**
     * Draws a Star.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     * @important
     */
    class Star extends Graphics {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("spikes")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear) {
                const display = this._display;
                const r = this.get("radius", 0);
                const ir = relativeToValue(this.get("innerRadius", 0), r);
                const spikes = this.get("spikes", 0);
                const step = Math.PI / spikes;
                let angle = Math.PI / 2 * 3;
                display.moveTo(0, -r);
                for (let i = 0; i < spikes; i++) {
                    display.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                    angle += step;
                    display.lineTo(Math.cos(angle) * ir, Math.sin(angle) * ir);
                    angle += step;
                }
                display.lineTo(0, -r);
                display.closePath();
            }
        }
    }
    Object.defineProperty(Star, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Star"
    });
    Object.defineProperty(Star, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Star.className])
    });

    /**
     * A [[List]] that holds components data.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
     */
    class ListData extends List {
        constructor() {
            super(...arguments);
            /**
             * An optional processor for data.
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Pre_processing_data} for more info
             */
            Object.defineProperty(this, "processor", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        /**
         * @ignore
         */
        incrementRef() { }
        /**
         * @ignore
         */
        decrementRef() { }
        _onPush(newValue) {
            if (this.processor) {
                this.processor.processRow(newValue);
            }
            super._onPush(newValue);
        }
        _onInsertIndex(index, newValue) {
            if (this.processor) {
                this.processor.processRow(newValue);
            }
            super._onInsertIndex(index, newValue);
        }
        _onSetIndex(index, oldValue, newValue) {
            if (this.processor) {
                this.processor.processRow(newValue);
            }
            super._onSetIndex(index, oldValue, newValue);
        }
    }
    /**
     * @deprecated
     * @todo remove
     */
    class JsonData {
        constructor(value) {
            Object.defineProperty(this, "processor", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_value", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this._value = value;
        }
        incrementRef() { }
        decrementRef() { }
    }

    /**
     * A base element that holds data bit (data item) for any [[Component]].
     */
    class DataItem extends Settings {
        constructor(component, dataContext, settings) {
            super(settings);
            /**
             * A data item's owener [[Component]].
             */
            Object.defineProperty(this, "component", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * A reference to actual item in source data this item is based on.
             */
            Object.defineProperty(this, "dataContext", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * @todo requires description
             */
            Object.defineProperty(this, "bullets", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * A set of "open" values.
             */
            Object.defineProperty(this, "open", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * A set of "close" values.
             */
            Object.defineProperty(this, "close", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.dataContext = dataContext;
            this.component = component;
            this._settings.visible = true;
            this._checkDirty();
        }
        /**
         * @ignore
         */
        markDirty() {
            this.component.markDirtyValues(this);
        }
        _startAnimation() {
            this.component._root._addAnimation(this);
        }
        _animationTime() {
            return this.component._root.animationTime;
        }
        _dispose() {
            if (this.component) {
                this.component.disposeDataItem(this);
            }
            super._dispose();
        }
        /**
         * Shows a data item that's currently hidden.
         */
        show(duration) {
            this.setRaw("visible", true);
            if (this.component) {
                this.component.showDataItem(this, duration);
            }
        }
        /**
         * Hides a data item that's currently visible.
         */
        hide(duration) {
            this.setRaw("visible", false);
            if (this.component) {
                this.component.hideDataItem(this, duration);
            }
        }
        isHidden() {
            return !this.get("visible");
        }
    }
    /**
     * A base class for elements that make use of data.
     */
    class Component extends Container {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListData()
            });
            Object.defineProperty(this, "_dataItems", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_mainDataItems", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._dataItems
            });
            Object.defineProperty(this, "valueFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "fields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: ["id"]
            });
            Object.defineProperty(this, "_valueFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_valueFieldsF", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_fields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_fieldsF", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_valuesDirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_dataChanged", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_dataGrouped", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            /**
             * Indicates if the component has already been initialized.
             */
            Object.defineProperty(this, "inited", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        /**
         * Component's data.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
         */
        set data(data) {
            data.incrementRef();
            this._data.decrementRef();
            this._data = data;
        }
        /**
         * @return  Data
         */
        get data() {
            return this._data;
        }
        _dispose() {
            super._dispose();
            this._data.decrementRef();
        }
        _onDataClear() {
        }
        _afterNew() {
            super._afterNew();
            this._data.incrementRef();
            this._updateFields();
            this._disposers.push(this.data.events.onAll((change) => {
                const dataItems = this._mainDataItems;
                this.markDirtyValues();
                this._markDirtyGroup();
                this._dataChanged = true;
                if (change.type === "clear") {
                    each$1(dataItems, (dataItem) => {
                        dataItem.dispose();
                    });
                    dataItems.length = 0;
                    this._onDataClear();
                }
                else if (change.type === "push") {
                    const dataItem = new DataItem(this, change.newValue, this._makeDataItem(change.newValue));
                    dataItems.push(dataItem);
                    this.processDataItem(dataItem);
                }
                else if (change.type === "setIndex") {
                    const dataItem = dataItems[change.index];
                    const properties = this._makeDataItem(change.newValue);
                    if (dataItem.bullets && dataItem.bullets.length == 0) {
                        dataItem.bullets = undefined;
                    }
                    keys(properties).forEach((key) => {
                        dataItem.animate({
                            key: key,
                            to: properties[key],
                            duration: this.get("interpolationDuration", 0),
                            easing: this.get("interpolationEasing"),
                        });
                    });
                    dataItem.dataContext = change.newValue;
                }
                else if (change.type === "insertIndex") {
                    const dataItem = new DataItem(this, change.newValue, this._makeDataItem(change.newValue));
                    dataItems.splice(change.index, 0, dataItem);
                    this.processDataItem(dataItem);
                }
                else if (change.type === "removeIndex") {
                    const dataItem = dataItems[change.index];
                    dataItem.dispose();
                    dataItems.splice(change.index, 1);
                }
                else if (change.type === "moveIndex") {
                    const dataItem = dataItems[change.oldIndex];
                    dataItems.splice(change.oldIndex, 1);
                    dataItems.splice(change.newIndex, 0, dataItem);
                }
                else {
                    throw new Error("Unknown IStreamEvent type");
                }
                this._afterDataChange();
            }));
        }
        _updateFields() {
            if (this.valueFields) {
                this._valueFields = [];
                this._valueFieldsF = {};
                each$1(this.valueFields, (key) => {
                    const field = this.get((key + "Field"));
                    if (field) {
                        this._valueFields.push(key);
                        this._valueFieldsF[key] = { fieldKey: key + "Field", workingKey: key + "Working" };
                    }
                });
            }
            if (this.fields) {
                this._fields = [];
                this._fieldsF = {};
                each$1(this.fields, (key) => {
                    const field = this.get((key + "Field"));
                    if (field) {
                        this._fields.push(key);
                        this._fieldsF[key] = key + "Field";
                    }
                });
            }
        }
        /**
         * A list of component's data items.
         *
         * @return  Data items
         */
        get dataItems() {
            return this._dataItems;
        }
        processDataItem(_dataItem) { }
        _makeDataItem(data) {
            //const output: this["_dataItemSettings"] = {};
            const output = {}; // temporary to solve error
            if (this._valueFields) {
                each$1(this._valueFields, (key) => {
                    const field = this.get((this._valueFieldsF[key].fieldKey));
                    output[key] = data[field];
                    output[this._valueFieldsF[key].workingKey] = output[key];
                });
            }
            if (this._fields) {
                each$1(this._fields, (key) => {
                    const field = this.get((this._fieldsF[key]));
                    output[key] = data[field];
                });
            }
            return output;
        }
        /**
         * Creates a new data item and processes it.
         *
         * @param   data         Data item settings
         * @param   dataContext  Data context
         * @return               New data item
         */
        makeDataItem(data, dataContext) {
            let dataItem = new DataItem(this, dataContext, data);
            this.processDataItem(dataItem);
            return dataItem;
        }
        /**
         * Adds new explicit data item to series.
         *
         * @param   data         Data item settings
         * @param   dataContext  Data context
         * @return               New data item
         */
        pushDataItem(data, dataContext) {
            const dataItem = this.makeDataItem(data, dataContext);
            this._mainDataItems.push(dataItem);
            return dataItem;
        }
        /**
         * @ignore
         */
        disposeDataItem(_dataItem) {
        }
        /**
         * Shows component's data item.
         *
         * @param   dataItem   Data item
         * @param   _duration  Animation duration in milliseconds
         * @return             Promise
         */
        showDataItem(dataItem, _duration) {
            return __awaiter(this, void 0, void 0, function* () {
                dataItem.set("visible", true);
            });
        }
        /**
         * Hides component's data item.
         *
         * @param   dataItem   Data item
         * @param   _duration  Animation duration in milliseconds
         * @return             Promise
         */
        hideDataItem(dataItem, _duration) {
            return __awaiter(this, void 0, void 0, function* () {
                dataItem.set("visible", false);
            });
        }
        _clearDirty() {
            super._clearDirty();
            this._valuesDirty = false;
        }
        _afterDataChange() {
        }
        _afterChanged() {
            super._afterChanged();
            if (this._dataChanged) {
                const type = "datavalidated";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this });
                }
                this._dataChanged = false;
            }
            this.inited = true;
        }
        /**
         * Forces a repaint of the element which relies on data.
         *
         * @since 5.0.21
         */
        markDirtyValues(_dataItem) {
            this.markDirty();
            this._valuesDirty = true;
        }
        _markDirtyGroup() {
            this._dataGrouped = false;
        }
        /**
         * @ignore
         */
        markDirtySize() {
            this._sizeDirty = true;
            this.markDirty();
        }
    }
    Object.defineProperty(Component, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Component"
    });
    Object.defineProperty(Component, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Component.className])
    });

    /**
     * A version of [[Container]] which adds zooming capabilities.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Zoomable_container} for more info
     * @since 5.8.0
     * @important
     */
    class ZoomableContainer extends Container {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_za", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_txa", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tya", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_movePoints", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_downScale", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_downX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_downY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_pinchDP", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * All elements must be added to `contents.children` instead of `children` of
             * [[ZoomableContainer]].
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Zoomable_container} for more info
             */
            Object.defineProperty(this, "contents", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Container.new(this._root, {
                    width: p100,
                    height: p100,
                    x: 0,
                    y: 0,
                    draggable: true,
                    background: Rectangle.new(this._root, {
                        fill: color(0xffffff),
                        fillOpacity: 0
                    })
                }))
            });
            Object.defineProperty(this, "_wheelDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _afterNew() {
            super._afterNew();
            const events = this.contents.events;
            this._disposers.push(events.on("pointerdown", (event) => {
                this._handleThisDown(event);
            }));
            this._disposers.push(events.on("globalpointerup", (event) => {
                this._handleThisUp(event);
            }));
            this._disposers.push(events.on("globalpointermove", (event) => {
                this._handleThisMove(event);
            }));
            const bg = this.contents.get("background");
            if (bg) {
                bg.adapters.add("width", (width) => {
                    return Number(width) * 5;
                });
                bg.adapters.add("height", (height) => {
                    return Number(height) * 5;
                });
                bg.adapters.add("x", (x) => {
                    return Number(x) - bg.width() / 5 * 2;
                });
                bg.adapters.add("y", (y) => {
                    return Number(y) - bg.height() / 5 * 2;
                });
            }
        }
        _prepareChildren() {
            super._prepareChildren();
            if (this.isDirty("wheelable")) {
                this._handleSetWheel();
            }
            this.contents._display.cancelTouch = this.get("pinchZoom", false);
        }
        _handleSetWheel() {
            // const contents = this.contents;
            if (this.get("wheelable")) {
                if (this._wheelDp) {
                    this._wheelDp.dispose();
                }
                this._wheelDp = this.events.on("wheel", (event) => {
                    const wheelEvent = event.originalEvent;
                    // Ignore wheel event if it is happening on a non-ZoomableContainer element, e.g. if
                    // some page element is over the ZoomableContainer.
                    if (isLocalEvent(wheelEvent, this)) {
                        wheelEvent.preventDefault();
                    }
                    else {
                        return;
                    }
                    const point = this.toLocal(event.point);
                    this._handleWheelZoom(wheelEvent.deltaY, point);
                });
                this._disposers.push(this._wheelDp);
            }
            else {
                if (this._wheelDp) {
                    this._wheelDp.dispose();
                }
            }
        }
        _handleWheelZoom(delta, point) {
            let step = this.get("zoomStep", 2);
            let zoomLevel = this.contents.get("scale", 1);
            let newZoomLevel = zoomLevel;
            if (delta > 0) {
                newZoomLevel = zoomLevel / step;
            }
            else if (delta < 0) {
                newZoomLevel = zoomLevel * step;
            }
            if (newZoomLevel != zoomLevel) {
                this.zoomToPoint(point, newZoomLevel);
            }
        }
        /**
         * Zooms to specific X/Y point.
         *
         * @param   point  Center point
         * @param   level  Zoom level
         * @return         Zoom Animation object
         */
        zoomToPoint(point, level) {
            if (level) {
                level = fitToRange(level, this.get("minZoomLevel", 1), this.get("maxZoomLevel", 32));
            }
            const zoomLevel = this.contents.get("scale", 1);
            let x = point.x;
            let y = point.y;
            let cx = x;
            let cy = y;
            const contents = this.contents;
            let tx = contents.x();
            let ty = contents.y();
            let xx = cx - ((x - tx) / zoomLevel * level);
            let yy = cy - ((y - ty) / zoomLevel * level);
            this._animateTo(xx, yy, level);
            return this._za;
        }
        /**
         * Zooms the container contents in by `zoomStep`.
         *
         * @return Zoom Animation object
         */
        zoomIn() {
            return this.zoomToPoint({ x: this.width() / 2, y: this.height() / 2 }, this.contents.get("scale", 1) * this.get("zoomStep", 2));
        }
        /**
         * Zooms the container contents out by `zoomStep`.
         *
         * @return Zoom Animation object
         */
        zoomOut() {
            return this.zoomToPoint({ x: this.width() / 2, y: this.height() / 2 }, this.contents.get("scale", 1) / this.get("zoomStep", 2));
        }
        /**
         * Fully zooms out the container contents.
         *
         * @return Zoom Animation object
         */
        goHome() {
            return this._animateTo(0, 0, 1);
        }
        _animateTo(x, y, scale) {
            const duration = this.get("animationDuration", 0);
            const easing = this.get("animationEasing");
            const contents = this.contents;
            this._txa = contents.animate({ key: "x", to: x, duration: duration, easing: easing });
            this._tya = contents.animate({ key: "y", to: y, duration: duration, easing: easing });
            this._za = contents.animate({ key: "scale", to: scale, duration: duration, easing: easing });
        }
        _handleThisUp(_event) {
            this._downPoints = {};
        }
        _handleThisDown(event) {
            const contents = this.contents;
            this._downScale = contents.get("scale", 1);
            const downPoints = contents._downPoints;
            let count = keys(downPoints).length;
            if (count == 1) {
                // workaround to solve a problem when events are added to some children of chart container (rotation stops working)
                let downPoint = downPoints[1];
                if (!downPoint) {
                    downPoint = downPoints[0];
                }
                if (downPoint && (downPoint.x == event.point.x && downPoint.y == event.point.y)) {
                    count = 0;
                }
            }
            if (count > 0) {
                this._downX = contents.x();
                this._downY = contents.y();
                const downId = contents._getDownPointId();
                if (downId) {
                    let movePoint = this._movePoints[downId];
                    if (movePoint) {
                        contents._downPoints[downId] = movePoint;
                    }
                }
            }
        }
        _handleThisMove(event) {
            const originalEvent = event.originalEvent;
            const pointerId = originalEvent.pointerId;
            if (this.get("pinchZoom")) {
                if (pointerId) {
                    this._movePoints[pointerId] = event.point;
                    if (keys(this.contents._downPoints).length > 1) {
                        this._handlePinch();
                        return;
                    }
                }
            }
        }
        _handlePinch() {
            let i = 0;
            let downPoints = [];
            let movePoints = [];
            each(this.contents._downPoints, (k, point) => {
                downPoints[i] = point;
                let movePoint = this._movePoints[k];
                if (movePoint) {
                    movePoints[i] = movePoint;
                }
                i++;
            });
            if (downPoints.length > 1 && movePoints.length > 1) {
                this.contents._isDragging = false;
                let downPoint0 = downPoints[0];
                let downPoint1 = downPoints[1];
                let movePoint0 = movePoints[0];
                let movePoint1 = movePoints[1];
                if (downPoint0 && downPoint1 && movePoint0 && movePoint1) {
                    downPoint0 = this.toLocal(downPoint0);
                    downPoint1 = this.toLocal(downPoint1);
                    movePoint0 = this.toLocal(movePoint0);
                    movePoint1 = this.toLocal(movePoint1);
                    let initialDistance = Math.hypot(downPoint1.x - downPoint0.x, downPoint1.y - downPoint0.y);
                    let currentDistance = Math.hypot(movePoint1.x - movePoint0.x, movePoint1.y - movePoint0.y);
                    let level = currentDistance / initialDistance * this._downScale;
                    let moveCenter = { x: movePoint0.x + (movePoint1.x - movePoint0.x) / 2, y: movePoint0.y + (movePoint1.y - movePoint0.y) / 2 };
                    let downCenter = { x: downPoint0.x + (downPoint1.x - downPoint0.x) / 2, y: downPoint0.y + (downPoint1.y - downPoint0.y) / 2 };
                    let tx = this._downX || 0;
                    let ty = this._downY || 0;
                    let zoomLevel = this._downScale;
                    let xx = moveCenter.x - (-tx + downCenter.x) / zoomLevel * level;
                    let yy = moveCenter.y - (-ty + downCenter.y) / zoomLevel * level;
                    this.contents.setAll({
                        x: xx,
                        y: yy,
                        scale: level
                    });
                }
            }
        }
    }
    Object.defineProperty(ZoomableContainer, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ZoomableContainer"
    });
    Object.defineProperty(ZoomableContainer, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([ZoomableContainer.className])
    });

    /**
     * Base class for gradients.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info
     */
    class Gradient extends Entity {
        _afterNew() {
            // Applying themes because gradient will not have parent
            super._afterNewApplyThemes();
        }
        /**
         * @ignore
         */
        getFill(_target) {
            return {
                addColorStop: (_offset, _color) => { }
            };
        }
        _changed() {
            super._changed();
            //if (this.isDirty("target") && this.get("target")) {
            //	this.get("target")!.events.on("boundschanged", () => {
            //	});
            //}
        }
        /**
         * @ignore
         */
        getBounds(target) {
            const gradientTarget = this.get("target");
            if (gradientTarget) {
                let bounds = gradientTarget.globalBounds();
                const p0 = target.toLocal({ x: bounds.left, y: bounds.top });
                const p1 = target.toLocal({ x: bounds.right, y: bounds.top });
                const p2 = target.toLocal({ x: bounds.right, y: bounds.bottom });
                const p3 = target.toLocal({ x: bounds.left, y: bounds.bottom });
                return {
                    left: Math.min(p0.x, p1.x, p2.x, p3.x),
                    top: Math.min(p0.y, p1.y, p2.y, p3.y),
                    right: Math.max(p0.x, p1.x, p2.x, p3.x),
                    bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
                };
            }
            return target._display.getLocalBounds();
        }
    }
    Object.defineProperty(Gradient, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Gradient"
    });
    Object.defineProperty(Gradient, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([Gradient.className])
    });

    /**
     * Linear gradient.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info
     */
    class LinearGradient extends Gradient {
        /**
         * @ignore
         */
        getFill(target) {
            const rotation = this.get("rotation", 0);
            let bounds = this.getBounds(target);
            let l = bounds.left || 0;
            let r = bounds.right || 0;
            let t = bounds.top || 0;
            let b = bounds.bottom || 0;
            let cos$1 = cos(rotation);
            let sin$1 = sin(rotation);
            let w = cos$1 * (r - l);
            let h = sin$1 * (b - t);
            if (w == 0) {
                w = 1;
            }
            if (h == 0) {
                h = 1;
            }
            let longer = Math.max(w, h);
            const gradient = this._root._renderer.createLinearGradient(l, t, l + longer * cos$1, t + longer * sin$1);
            const stops = this.get("stops");
            if (stops) {
                let i = 0;
                each$1(stops, (stop) => {
                    let offset = stop.offset;
                    if (!isNumber(offset)) {
                        offset = i / (stops.length - 1);
                    }
                    let opacity = stop.opacity;
                    if (!isNumber(opacity)) {
                        opacity = 1;
                    }
                    let color = stop.color;
                    if (color) {
                        const lighten = stop.lighten;
                        if (lighten) {
                            color = Color.lighten(color, lighten);
                        }
                        const brighten = stop.brighten;
                        if (brighten) {
                            color = Color.brighten(color, brighten);
                        }
                        gradient.addColorStop(offset, 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + opacity + ')');
                    }
                    i++;
                });
            }
            return gradient;
        }
    }
    Object.defineProperty(LinearGradient, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "LinearGradient"
    });
    Object.defineProperty(LinearGradient, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Gradient.classNames.concat([LinearGradient.className])
    });

    /**
     * Heat legend.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/heat-legend/} for more info
     */
    class HeatLegend extends Container {
        constructor() {
            super(...arguments);
            /**
             * A [[Container]] that all labels are placed in.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "labelContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Container.new(this._root, {}))
            });
            /**
             * A [[Container]] that all markers are placed in.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "markerContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Container.new(this._root, {}))
            });
            /**
             * A start [[Label]].
             *
             * @default Label.new()
             */
            Object.defineProperty(this, "startLabel", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.labelContainer.children.push(Label.new(this._root, { themeTags: ["start"] }))
            });
            /**
             * An end [[Label]].
             *
             * @default Label.new()
             */
            Object.defineProperty(this, "endLabel", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.labelContainer.children.push(Label.new(this._root, { themeTags: ["end"] }))
            });
            /**
             * List of rectangle elements used for default legend markers.
             *
             * @default new ListTemplate<RoundedRectangle>
             */
            Object.defineProperty(this, "markers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {
                    themeTags: mergeTags(this.markers.template.get("themeTags", []), [this.get("orientation"), "heatlegend", "marker"])
                }, [this.markers.template]))
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["heatlegend", this._settings.orientation]);
            super._afterNew();
            this.set("tooltip", Tooltip.new(this._root, {
                themeTags: ["heatlegend"]
            }));
        }
        /**
         * @ignore
         */
        makeMarker() {
            const marker = this.markers.make();
            marker.states.create("disabled", {});
            return marker;
        }
        /**
         * Moves and shows tooltip at specific value.
         *
         * Can also specify optional text to show in tooltip, as well as the color.
         *
         * @param  value  Value
         * @param  text   Text
         * @param  color  Color
         */
        showValue(value, text, color) {
            const tooltip = this.getTooltip();
            if (tooltip && isNumber(value)) {
                const startValue = this.get("startValue", 0);
                const endValue = this.get("endValue", 1);
                let c = (value - startValue) / (endValue - startValue);
                if (c == Infinity || c == -Infinity || isNaN(c)) {
                    c = 0.5;
                }
                const startColor = this.get("startColor");
                const endColor = this.get("endColor");
                if (!text) {
                    text = this.getNumberFormatter().format(value);
                }
                if (!color) {
                    color = Color.interpolate(c, startColor, endColor);
                }
                tooltip.label.set("text", text);
                let p;
                if (this.get("orientation") == "vertical") {
                    p = this.markerContainer.toGlobal({ x: 0, y: this.innerHeight() * (1 - c) });
                }
                else {
                    p = this.markerContainer.toGlobal({ x: this.innerWidth() * c, y: 0 });
                }
                let background = tooltip.get("background");
                if (background) {
                    background.set("fill", color);
                }
                tooltip.set("pointTo", p);
                tooltip.show();
            }
        }
        _prepareChildren() {
            super._prepareChildren();
            const labelContainer = this.labelContainer;
            const orientation = this.get("orientation");
            const startLabel = this.startLabel;
            const endLabel = this.endLabel;
            const tooltip = this.getTooltip();
            if (this.isDirty("orientation")) {
                if (orientation == "vertical") {
                    this.markerContainer.setAll({ layout: this._root.verticalLayout, height: p100 });
                    this.set("layout", this._root.horizontalLayout);
                    startLabel.setAll({ y: p100, x: undefined, centerY: p100, centerX: p100 });
                    endLabel.setAll({ y: 0, x: undefined, centerY: 0, centerX: p100 });
                    labelContainer.setAll({ height: p100, width: undefined });
                    if (tooltip) {
                        tooltip.set("pointerOrientation", "horizontal");
                    }
                }
                else {
                    this.markerContainer.setAll({ layout: this._root.horizontalLayout, width: p100 });
                    this.set("layout", this._root.verticalLayout);
                    startLabel.setAll({ x: 0, y: undefined, centerX: 0, centerY: 0 });
                    endLabel.setAll({ x: p100, y: undefined, centerX: p100, centerY: 0 });
                    labelContainer.setAll({ width: p100, height: undefined });
                    if (tooltip) {
                        tooltip.set("pointerOrientation", "vertical");
                    }
                }
            }
            if (this.isDirty("stepCount")) {
                const stepCount = this.get("stepCount", 1);
                const startColor = this.get("startColor");
                const endColor = this.get("endColor");
                this.markerContainer.children.clear();
                if (stepCount > 1) {
                    for (let i = 0; i < stepCount; i++) {
                        const marker = this.makeMarker();
                        if (orientation == "vertical") {
                            this.markerContainer.children.moveValue(marker, 0);
                        }
                        else {
                            this.markerContainer.children.push(marker);
                        }
                        if (startColor && endColor) {
                            marker.set("fill", Color.interpolate(i / stepCount, startColor, endColor));
                        }
                    }
                }
                else if (stepCount == 1) {
                    const marker = this.makeMarker();
                    this.markerContainer.children.push(marker);
                    const gradient = LinearGradient.new(this._root, { stops: [{ color: startColor }, { color: endColor }] });
                    if (orientation == "vertical") {
                        gradient.set("rotation", 90);
                        let stops = gradient.get("stops");
                        if (stops) {
                            stops.reverse();
                        }
                    }
                    else {
                        gradient.set("rotation", 0);
                    }
                    if (startColor && endColor) {
                        marker.set("fillGradient", gradient);
                    }
                }
            }
            if (this.isDirty("startText") || this.isDirty("startValue")) {
                startLabel.set("text", this.get("startText", this.getNumberFormatter().format(this.get("startValue", 0))));
            }
            if (this.isDirty("endText") || this.isDirty("endValue")) {
                endLabel.set("text", this.get("endText", this.getNumberFormatter().format(this.get("endValue", 1))));
            }
        }
    }
    Object.defineProperty(HeatLegend, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "HeatLegend"
    });
    Object.defineProperty(HeatLegend, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([HeatLegend.className])
    });

    /**
     * Editable label.
     *
     * @since 5.9.5
     */
    class EditableLabel extends Label {
        _afterNew() {
            super._afterNew();
            const input = this.children.push(Container.new(this._root, {
                html: "<textarea class=\"am5-editable-label\"></textarea>",
                isMeasured: false
            }));
            input.hide();
            const editOn = this.get("editOn", "click");
            if (editOn != "none") {
                input.events.on(editOn, (_ev) => {
                    // this is here just to make it interactive
                });
                this.events.on(editOn, (_ev) => {
                    this.set("active", true);
                });
            }
            this.setPrivate("input", input);
            // Set background
            let background = this.get("background");
            if (!background) {
                background = this.set("background", RoundedRectangle.new(this._root, {
                    themeTags: ["editablelabel", "background"]
                }));
            }
            else {
                background.set("themeTags", ["editablelabel", "background"]);
            }
        }
        _prepareChildren() {
            super._prepareChildren();
            this._maybeInitTextarea();
        }
        _updateChildren() {
            super._updateChildren();
            if (this.isDirty("active")) {
                const editing = this.get("active", false);
                if (editing) {
                    this._startEditing();
                }
                else {
                    this._stopEditing();
                }
                const bg = this.get("background");
                if (bg) {
                    bg.set("active", editing);
                }
            }
            this._syncText();
            this._syncStyle();
        }
        _maybeInitTextarea() {
            if (!this._isInited()) {
                const input = this.getPrivate("input");
                if (input && input.getPrivate("htmlElement")) {
                    const el = input.getPrivate("htmlElement");
                    const textarea = el.querySelector(".am5-editable-label");
                    if (textarea) {
                        this.setPrivate("textarea", textarea);
                        // Resize textarea on keypress
                        textarea.addEventListener("input", _ev => {
                            if (this.get("multiLine") === false) {
                                // replace line breaks with spaces for single-line labels
                                textarea.value = textarea.value.replace(/\n/g, " ");
                            }
                            this.set("text", textarea.value);
                            this._syncStyle();
                        });
                        // Finish editing on blur
                        textarea.addEventListener("blur", _ev => this.set("active", false));
                        // Finish editing on ESC press
                        if (supports("keyboardevents")) {
                            this._disposers.push(addEventListener(document, "keydown", (ev) => {
                                if (getEventKey(ev) == "Escape") {
                                    this.set("active", false);
                                }
                            }));
                        }
                        // Intercept ENTER if necessary
                        this._disposers.push(addEventListener(document, "keydown", (ev) => {
                            if (getEventKey(ev) == "Enter" && this.get("multiLine") === false) {
                                // Single-line label, save instead of breaking into new line
                                ev.preventDefault();
                                this.set("active", false);
                            }
                        }));
                        this.events.dispatch("inited", {
                            type: "inited",
                            target: this
                        });
                    }
                }
            }
        }
        _isInited() {
            return this.getPrivate("textarea") ? true : false;
        }
        _startEditing() {
            if (!this._isInited()) {
                this.events.once("inited", () => {
                    this._startEditing();
                });
                return;
            }
            this._text.set("opacity", 0);
            const input = this.getPrivate("input");
            const textarea = this.getPrivate("textarea");
            if (textarea) {
                if (this.get("text", "") == "") {
                    this.set("text", " ");
                }
                input.show(0);
                this.setTimeout(() => {
                    // size textarea to fit its actual content
                    this._syncStyle();
                    textarea.focus();
                }, 100);
            }
        }
        _stopEditing() {
            if (!this._isInited()) {
                this.events.once("inited", () => {
                    this._stopEditing();
                });
                return;
            }
            const input = this.getPrivate("input");
            const textarea = this.getPrivate("textarea");
            if (textarea) {
                this.set("text", textarea.value);
                input.hide(0);
                this._text.set("opacity", 1);
            }
        }
        _syncStyle() {
            const input = this.getPrivate("input");
            const textarea = this.getPrivate("textarea");
            if (textarea) {
                // Set up HTML
                const el = input.getPrivate("htmlElement");
                // Reset all styles
                const computedStyles = window.getComputedStyle(textarea);
                each$1(computedStyles, (style) => {
                    textarea.style[style] = "initial";
                });
                // Remove textarea attributes
                textarea.style.color = this.get("fill", color(0x000000)).toCSS(this.get("fillOpacity", 1));
                textarea.style.backgroundColor = "rgba(0, 0, 0, 0)";
                textarea.style.border = "none";
                textarea.style.outline = "none";
                textarea.style.padding = "0";
                // Wrapping
                textarea.wrap = "off";
                textarea.style.resize = "none";
                // Place carret under mouse cursor
                // @todo
                // Size
                textarea.style.overflow = "hidden";
                const maxWidth = this.get("maxWidth", 0) - this.get("paddingLeft", 0) - this.get("paddingRight", 0);
                if (maxWidth > 0) {
                    textarea.style.maxWidth = maxWidth + "px";
                }
                else {
                    textarea.style.minWidth = textarea.scrollWidth + "px";
                }
                textarea.style.height = "auto";
                textarea.style.minHeight = textarea.scrollHeight + "px";
                // If width is explicitly set on a label, use it for textarea
                if (this.get("width")) {
                    textarea.style.width = (this.width() - this.get("paddingLeft", 0) - this.get("paddingRight", 0)) + "px";
                    textarea.style.minWidth = "";
                }
                // Line height
                const lineHeight = this.get("lineHeight");
                if (!lineHeight) {
                    textarea.style.lineHeight = "1.2";
                }
                else if (lineHeight instanceof Percent) {
                    textarea.style.lineHeight = lineHeight.value + "";
                }
                else if (isNumber(lineHeight)) {
                    textarea.style.lineHeight = lineHeight + "";
                }
                // Font stuff
                let fontFamily = this.get("fontFamily");
                if (!fontFamily) {
                    fontFamily = getComputedStyle(input.getPrivate("htmlElement"), "font-family").getPropertyValue("font-family");
                }
                textarea.style.fontFamily = fontFamily;
                let fontSize = this.get("fontSize");
                if (!fontSize) {
                    fontSize = getComputedStyle(input.getPrivate("htmlElement"), "font-size").getPropertyValue("font-size");
                }
                else if (isNumber(fontSize)) {
                    fontSize = fontSize + "px";
                }
                else {
                    fontSize = fontSize;
                }
                textarea.style.fontSize = fontSize;
                let fontWeight = this.get("fontWeight");
                if (!fontWeight) {
                    fontWeight = getComputedStyle(input.getPrivate("htmlElement"), "font-weight").getPropertyValue("font-weight");
                }
                else {
                    fontWeight = fontWeight;
                }
                textarea.style.fontWeight = fontWeight;
                let fontStyle = this.get("fontStyle");
                if (!fontStyle) {
                    fontStyle = getComputedStyle(input.getPrivate("htmlElement"), "font-style").getPropertyValue("font-style");
                }
                else {
                    fontStyle = fontStyle;
                }
                textarea.style.fontStyle = fontStyle;
                const oversizeBehavior = this.get("oversizedBehavior");
                if (oversizeBehavior == "wrap") {
                    textarea.style.whiteSpace = "pre-wrap";
                }
                else {
                    textarea.style.whiteSpace = "nowrap";
                }
                // Adjust textarea postion based on textAlign setting
                this._root.events.on("frameended", () => {
                    const textAlign = this.get("textAlign", "start");
                    if (textAlign == "center") {
                        textarea.style.textAlign = "center";
                        if (!el.style.transform.match(/translateX/) && !this.get("width")) {
                            el.style.transform += " translateX(-50%)";
                        }
                    }
                    else if (textAlign == "end") {
                        textarea.style.textAlign = "right";
                        if (!el.style.transform.match(/translateX/) && !this.get("width")) {
                            el.style.transform += " translateX(-100%)";
                        }
                    }
                    else {
                        textarea.style.textAlign = textAlign;
                    }
                });
            }
        }
        _syncText() {
            const textarea = this.getPrivate("textarea");
            let text = this.get("text", "");
            if (text == " ") {
                text = "";
            }
            if (textarea) {
                textarea.value = text;
            }
        }
    }
    Object.defineProperty(EditableLabel, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EditableLabel"
    });
    Object.defineProperty(EditableLabel, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Label.classNames.concat([EditableLabel.className])
    });

    /**
     * ============================================================================
     * IMPORTS
     * ============================================================================
     * @hidden
     */
    /**
     * Returns a `Promise` which can be used to execute code after number of
     * milliseconds.
     *
     * @param   ms  Sleep duration in ms
     * @return      Promise
     */
    function sleep(ms) {
        return new Promise((resolve, _reject) => {
            setTimeout(resolve, ms);
        });
    }
    /**
     * Maps time period names to their numeric representations in milliseconds.
     *
     * @ignore Exclude from docs
     */
    let timeUnitDurations = {
        millisecond: 1,
        second: 1000,
        minute: 60000,
        hour: 3600000,
        day: 86400000,
        week: 604800000,
        month: 365.242 / 12 * 86400000,
        year: 31536000000
    };
    /**
     * Returns the next time unit that goes after source `unit`.
     *
     * E.g. "hour" is the next unit after "minute", etc.
     *
     * @ignore Exclude from docs
     * @param unit  Source time unit
     * @return Next time unit
     */
    function getNextUnit(unit) {
        switch (unit) {
            case "year":
                return;
            case "month":
                return "year";
            case "week":
                return "month";
            case "day":
                return "month"; // not a mistake
            case "hour":
                return "day";
            case "minute":
                return "hour";
            case "second":
                return "minute";
            case "millisecond":
                return "second";
        }
    }
    /**
     * Returns number of milliseconds in the `count` of time `unit`.
     *
     * Available units: "millisecond", "second", "minute", "hour", "day", "week",
     * "month", and "year".
     *
     * @param unit   Time unit
     * @param count  Number of units
     * @return Milliseconds
     */
    function getDuration(unit, count) {
        if (count == null) {
            count = 1;
        }
        return timeUnitDurations[unit] * count;
    }
    /**
     * @ignore
     */
    function getIntervalDuration(interval) {
        if (interval) {
            return timeUnitDurations[interval.timeUnit] * interval.count;
        }
        return 0;
    }
    function getDateIntervalDuration(interval, date, firstDateOfWeek, utc, timezone) {
        const unit = interval.timeUnit;
        const count = interval.count;
        if (unit == "hour" || unit == "minute" || unit == "second" || unit == "millisecond") {
            return timeUnitDurations[interval.timeUnit] * interval.count;
        }
        else {
            const firstTime = round(new Date(date.getTime()), unit, count, firstDateOfWeek, utc, undefined, timezone).getTime();
            let lastTime = firstTime + count * getDuration(unit) * 1.05;
            lastTime = round(new Date(lastTime), unit, 1, firstDateOfWeek, utc, undefined, timezone).getTime();
            return lastTime - firstTime;
        }
    }
    /**
     * Returns current `Date` object.
     *
     * @return Current date
     */
    function now() {
        return new Date();
    }
    /**
     * Returns current timestamp.
     *
     * @return Current timestamp
     */
    function getTime() {
        return now().getTime();
    }
    /**
     * Returns a copy of the `Date` object.
     *
     * @param date  Source date
     * @return Copy
     */
    function copy(date) {
        return new Date(date.getTime()); // todo: check if this is ok. new Date(date) used to strip milliseconds on FF in v3
    }
    /**
     * Checks if the `unit` part of two `Date` objects do not match. Two dates
     * represent a "range" of time, rather the same time date.
     *
     * @param timeOne  timestamp
     * @param timeTwo  timestamp
     * @param unit     Time unit to check
     * @return Range?
     */
    function checkChange(timeOne, timeTwo, unit, utc, timezone) {
        // quick
        if ((timeTwo - timeOne) > getDuration(unit, 1.2)) {
            return true;
        }
        let dateOne = new Date(timeOne);
        let dateTwo = new Date(timeTwo);
        if (timezone) {
            dateOne = timezone.convertLocal(dateOne);
            dateTwo = timezone.convertLocal(dateTwo);
        }
        let timeZoneOffset1 = 0;
        let timeZoneOffset2 = 0;
        if (!utc && unit != "millisecond") {
            timeZoneOffset1 = dateOne.getTimezoneOffset();
            dateOne.setUTCMinutes(dateOne.getUTCMinutes() - timeZoneOffset1);
            timeZoneOffset2 = dateTwo.getTimezoneOffset();
            dateTwo.setUTCMinutes(dateTwo.getUTCMinutes() - timeZoneOffset2);
        }
        let changed = false;
        switch (unit) {
            case "year":
                if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                    changed = true;
                }
                break;
            case "month":
                if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                    changed = true;
                }
                else if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                    changed = true;
                }
                break;
            case "day":
                if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                    changed = true;
                }
                else if (dateOne.getUTCDate() != dateTwo.getUTCDate()) {
                    changed = true;
                }
                break;
            case "hour":
                if (dateOne.getUTCHours() != dateTwo.getUTCHours()) {
                    changed = true;
                }
                break;
            case "minute":
                if (dateOne.getUTCMinutes() != dateTwo.getUTCMinutes()) {
                    changed = true;
                }
                break;
            case "second":
                if (dateOne.getUTCSeconds() != dateTwo.getUTCSeconds()) {
                    changed = true;
                }
                break;
            case "millisecond":
                if (dateOne.getTime() != dateTwo.getTime()) {
                    changed = true;
                }
                break;
        }
        if (changed) {
            return changed;
        }
        let nextUnit = getNextUnit(unit);
        if (nextUnit) {
            return checkChange(timeOne, timeTwo, nextUnit, utc, timezone);
        }
        else {
            return false;
        }
    }
    /**
     * Adds `count` of time `unit` to the source date. Returns a modified `Date` object.
     *
     * @param date   Source date
     * @param unit   Time unit
     * @param count  Number of units to add
     * @return Modified date
     */
    function add(date, unit, count, utc, timezone) {
        let timeZoneOffset = 0;
        if (!utc && unit != "millisecond") {
            timeZoneOffset = date.getTimezoneOffset();
            if (timezone) {
                timeZoneOffset -= timezone.offsetUTC(date);
            }
            date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
        }
        switch (unit) {
            case "day":
                let day = date.getUTCDate();
                date.setUTCDate(day + count);
                break;
            case "second":
                let seconds = date.getUTCSeconds();
                date.setUTCSeconds(seconds + count);
                break;
            case "millisecond":
                let milliseconds = date.getUTCMilliseconds();
                date.setUTCMilliseconds(milliseconds + count);
                break;
            case "hour":
                let hours = date.getUTCHours();
                date.setUTCHours(hours + count);
                break;
            case "minute":
                let minutes = date.getUTCMinutes();
                date.setUTCMinutes(minutes + count);
                break;
            case "year":
                let year = date.getUTCFullYear();
                date.setUTCFullYear(year + count);
                break;
            case "month":
                const endDays = date.getUTCDate();
                const startDays = new Date(date.getUTCFullYear(), date.getUTCMonth(), 0).getUTCDate();
                let month = date.getUTCMonth();
                if (endDays > startDays) {
                    date.setUTCMonth(month + count, startDays);
                }
                else {
                    date.setUTCMonth(month + count);
                }
                break;
            case "week":
                let wday = date.getUTCDate();
                date.setUTCDate(wday + count * 7);
                break;
        }
        if (!utc && unit != "millisecond") {
            date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
            if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
                let newTimeZoneOffset = date.getTimezoneOffset();
                if (timezone) {
                    newTimeZoneOffset += timezone.offsetUTC(date);
                }
                if (newTimeZoneOffset != timeZoneOffset) {
                    let diff = newTimeZoneOffset - timeZoneOffset;
                    date.setUTCMinutes(date.getUTCMinutes() + diff);
                    // solves issues if new time falls back to old time zone
                    if (date.getTimezoneOffset() != newTimeZoneOffset) {
                        date.setUTCMinutes(date.getUTCMinutes() - diff);
                    }
                }
            }
        }
        return date;
    }
    /**
     * @ignore
     */
    function roun(time, unit, count, root, firstTime) {
        let firstDate;
        if (firstTime != null) {
            firstDate = new Date(firstTime);
        }
        return round(new Date(time), unit, count, root.locale.firstDayOfWeek, root.utc, firstDate, root.timezone).getTime();
    }
    /**
     * "Rounds" the date to specific time unit.
     *
     * @param date             Source date
     * @param unit             Time unit
     * @param count            Number of units to round to
     * @param firstDateOfWeek  First day of week
     * @param utc              Use UTC timezone
     * @param firstDate        First date to round to
     * @param roundMinutes     Minutes to round to (some timezones use non-whole hour)
     * @param timezone         Use specific named timezone when rounding
     * @return New date
     */
    function round(date, unit, count, firstDateOfWeek, utc, firstDate, timezone) {
        if (!timezone || utc) {
            let timeZoneOffset = 0;
            if (!utc && unit != "millisecond") {
                timeZoneOffset = date.getTimezoneOffset();
                date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
            }
            switch (unit) {
                case "day":
                    let day = date.getUTCDate();
                    if (count > 1) {
                        //	day = Math.floor(day / count) * count;
                        if (firstDate) {
                            firstDate = round(firstDate, "day", 1);
                            let difference = date.getTime() - firstDate.getTime();
                            let unitCount = Math.floor(difference / getDuration("day") / count);
                            let duration = getDuration("day", unitCount * count);
                            date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));
                        }
                    }
                    else {
                        date.setUTCDate(day);
                    }
                    date.setUTCHours(0, 0, 0, 0);
                    break;
                case "second":
                    let seconds = date.getUTCSeconds();
                    if (count > 1) {
                        seconds = Math.floor(seconds / count) * count;
                    }
                    date.setUTCSeconds(seconds, 0);
                    break;
                case "millisecond":
                    if (count == 1) {
                        return date; // much better for perf!
                    }
                    let milliseconds = date.getUTCMilliseconds();
                    milliseconds = Math.floor(milliseconds / count) * count;
                    date.setUTCMilliseconds(milliseconds);
                    break;
                case "hour":
                    let hours = date.getUTCHours();
                    if (count > 1) {
                        hours = Math.floor(hours / count) * count;
                    }
                    date.setUTCHours(hours, 0, 0, 0);
                    break;
                case "minute":
                    let minutes = date.getUTCMinutes();
                    if (count > 1) {
                        minutes = Math.floor(minutes / count) * count;
                    }
                    date.setUTCMinutes(minutes, 0, 0);
                    break;
                case "month":
                    let month = date.getUTCMonth();
                    if (count > 1) {
                        month = Math.floor(month / count) * count;
                    }
                    date.setUTCMonth(month, 1);
                    date.setUTCHours(0, 0, 0, 0);
                    break;
                case "year":
                    let year = date.getUTCFullYear();
                    if (count > 1) {
                        year = Math.floor(year / count) * count;
                    }
                    date.setUTCFullYear(year, 0, 1);
                    date.setUTCHours(0, 0, 0, 0);
                    break;
                case "week":
                    if (count > 1) {
                        if (firstDate) {
                            firstDate = round(firstDate, "week", 1);
                            let difference = date.getTime() - firstDate.getTime();
                            let unitCount = Math.floor(difference / getDuration("week") / count);
                            let duration = getDuration("week", unitCount * count);
                            date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));
                        }
                    }
                    let wday = date.getUTCDate();
                    let weekDay = date.getUTCDay();
                    if (!isNumber(firstDateOfWeek)) {
                        firstDateOfWeek = 1;
                    }
                    if (weekDay >= firstDateOfWeek) {
                        wday = wday - weekDay + firstDateOfWeek;
                    }
                    else {
                        wday = wday - (7 + weekDay) + firstDateOfWeek;
                    }
                    date.setUTCDate(wday);
                    date.setUTCHours(0, 0, 0, 0);
                    break;
            }
            if (!utc && unit != "millisecond") {
                date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
                if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
                    let newTimeZoneOffset = date.getTimezoneOffset();
                    if (newTimeZoneOffset != timeZoneOffset) {
                        let diff = newTimeZoneOffset - timeZoneOffset;
                        date.setUTCMinutes(date.getUTCMinutes() + diff);
                    }
                }
            }
            return date;
        }
        else {
            if (isNaN(date.getTime())) {
                return date;
            }
            let tzoffset = timezone.offsetUTC(date);
            let timeZoneOffset = date.getTimezoneOffset();
            let parsedDate = timezone.parseDate(date);
            let year = parsedDate.year;
            let month = parsedDate.month;
            let day = parsedDate.day;
            let hour = parsedDate.hour;
            let minute = parsedDate.minute;
            let second = parsedDate.second;
            let millisecond = parsedDate.millisecond;
            let weekday = parsedDate.weekday;
            let offsetDif = tzoffset - timeZoneOffset;
            switch (unit) {
                case "day":
                    if (count > 1 && firstDate) {
                        firstDate = round(firstDate, "day", 1, firstDateOfWeek, utc, undefined, timezone);
                        let difference = date.getTime() - firstDate.getTime();
                        let unitCount = Math.floor(difference / getDuration("day") / count);
                        let duration = getDuration("day", unitCount * count);
                        date.setTime(firstDate.getTime() + duration);
                        parsedDate = timezone.parseDate(date);
                        year = parsedDate.year;
                        month = parsedDate.month;
                        day = parsedDate.day;
                    }
                    hour = 0;
                    minute = offsetDif;
                    second = 0;
                    millisecond = 0;
                    break;
                case "second":
                    minute += offsetDif;
                    if (count > 1) {
                        second = Math.floor(second / count) * count;
                    }
                    millisecond = 0;
                    break;
                case "millisecond":
                    minute += offsetDif;
                    if (count > 1) {
                        millisecond = Math.floor(millisecond / count) * count;
                    }
                    break;
                case "hour":
                    if (count > 1) {
                        hour = Math.floor(hour / count) * count;
                    }
                    minute = offsetDif;
                    second = 0;
                    millisecond = 0;
                    break;
                case "minute":
                    if (count > 1) {
                        minute = Math.floor(minute / count) * count;
                    }
                    minute += offsetDif;
                    second = 0;
                    millisecond = 0;
                    break;
                case "month":
                    if (count > 1) {
                        month = Math.floor(month / count) * count;
                    }
                    day = 1;
                    hour = 0;
                    minute = offsetDif;
                    second = 0;
                    millisecond = 0;
                    break;
                case "year":
                    if (count > 1) {
                        year = Math.floor(year / count) * count;
                    }
                    month = 0;
                    day = 1;
                    hour = 0;
                    minute = offsetDif;
                    second = 0;
                    millisecond = 0;
                    break;
                case "week":
                    if (!isNumber(firstDateOfWeek)) {
                        firstDateOfWeek = 1;
                    }
                    if (weekday >= firstDateOfWeek) {
                        day = day - weekday + firstDateOfWeek;
                    }
                    else {
                        day = day - (7 + weekday) + firstDateOfWeek;
                    }
                    hour = 0;
                    minute = offsetDif;
                    second = 0;
                    millisecond = 0;
                    break;
            }
            date = new Date(year, month, day, hour, minute, second, millisecond);
            let newTimeZoneOffset = date.getTimezoneOffset();
            let newTzoffset = timezone.offsetUTC(date);
            let newDiff = newTzoffset - newTimeZoneOffset;
            if (newDiff != offsetDif) {
                date.setTime(date.getTime() + (newDiff - offsetDif) * 60000);
            }
            return date;
        }
    }
    /**
     * @ignore
     */
    function chooseInterval(index, duration, gridCount, intervals) {
        let gridInterval = intervals[index];
        let intervalDuration = getIntervalDuration(gridInterval);
        let lastIndex = intervals.length - 1;
        if (index >= lastIndex) {
            return Object.assign({}, intervals[lastIndex]);
        }
        let count = Math.ceil(duration / intervalDuration);
        if (duration < intervalDuration && index > 0) {
            return Object.assign({}, intervals[index - 1]);
        }
        if (count <= gridCount) {
            return Object.assign({}, intervals[index]);
        }
        else {
            if (index + 1 < intervals.length) {
                return chooseInterval(index + 1, duration, gridCount, intervals);
            }
            else {
                return Object.assign({}, intervals[index]);
            }
        }
    }
    /**
     * @ignore
     */
    function getUnitValue(date, unit) {
        switch (unit) {
            case "day":
                return date.getDate();
            case "second":
                return date.getSeconds();
            case "millisecond":
                return date.getMilliseconds();
            case "hour":
                return date.getHours();
            case "minute":
                return date.getMinutes();
            case "month":
                return date.getMonth();
            case "year":
                return date.getFullYear();
            case "week":
                return getWeek(date);
        }
    }

    var Time = /*#__PURE__*/Object.freeze({
        __proto__: null,
        add: add,
        checkChange: checkChange,
        chooseInterval: chooseInterval,
        copy: copy,
        getDateIntervalDuration: getDateIntervalDuration,
        getDuration: getDuration,
        getIntervalDuration: getIntervalDuration,
        getNextUnit: getNextUnit,
        getTime: getTime,
        getUnitValue: getUnitValue,
        now: now,
        roun: roun,
        round: round,
        sleep: sleep,
        timeUnitDurations: timeUnitDurations
    });

    /**
     * A base class for all series.
     */
    class Series extends Component {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_aggregatesCalculated", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_selectionAggregatesCalculated", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_dataProcessed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_psi", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_pei", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * A chart series belongs to.
             */
            Object.defineProperty(this, "chart", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * List of bullets to use for the series.
             *
             * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info
             */
            Object.defineProperty(this, "bullets", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new List()
            });
            /**
             * A [[Container]] series' bullets are stored in.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "bulletsContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Container.new(this._root, { width: p100, height: p100, position: "absolute" })
            });
        }
        _afterNew() {
            this.valueFields.push("value", "customValue");
            super._afterNew();
            this.setPrivate("customData", {});
            this._disposers.push(this.bullets.events.onAll((change) => {
                if (change.type === "clear") {
                    this._handleBullets(this.dataItems);
                }
                else if (change.type === "push") {
                    this._handleBullets(this.dataItems);
                }
                else if (change.type === "setIndex") {
                    this._handleBullets(this.dataItems);
                }
                else if (change.type === "insertIndex") {
                    this._handleBullets(this.dataItems);
                }
                else if (change.type === "removeIndex") {
                    this._handleBullets(this.dataItems);
                }
                else if (change.type === "moveIndex") {
                    this._handleBullets(this.dataItems);
                }
                else {
                    throw new Error("Unknown IListEvent type");
                }
            }));
        }
        _dispose() {
            this.bulletsContainer.dispose(); // can be in a different parent
            super._dispose();
        }
        startIndex() {
            let len = this.dataItems.length;
            return Math.min(this.getPrivate("startIndex", 0), len);
        }
        endIndex() {
            let len = this.dataItems.length;
            return Math.min(this.getPrivate("endIndex", len), len);
        }
        _handleBullets(dataItems) {
            each$1(dataItems, (dataItem) => {
                const bullets = dataItem.bullets;
                if (bullets) {
                    each$1(bullets, (bullet) => {
                        bullet.dispose();
                    });
                    dataItem.bullets = undefined;
                }
            });
            this.markDirtyValues();
        }
        /**
         * Looks up and returns a data item by its ID.
         *
         * @param   id  ID
         * @return      Data item
         */
        getDataItemById(id) {
            return find(this.dataItems, (dataItem) => {
                return dataItem.get("id") == id;
            });
        }
        _makeBullets(dataItem) {
            if (this._shouldMakeBullet(dataItem)) {
                dataItem.bullets = [];
                this.bullets.each((bulletFunction) => {
                    this._makeBullet(dataItem, bulletFunction);
                });
            }
        }
        _shouldMakeBullet(_dataItem) {
            return true;
        }
        _makeBullet(dataItem, bulletFunction, index) {
            const bullet = bulletFunction(this._root, this, dataItem);
            if (bullet) {
                bullet._index = index;
                this._makeBulletReal(dataItem, bullet);
            }
            return bullet;
        }
        _makeBulletReal(dataItem, bullet) {
            let sprite = bullet.get("sprite");
            if (sprite) {
                sprite._setDataItem(dataItem);
                sprite.setRaw("position", "absolute");
                this.bulletsContainer.children.push(sprite);
            }
            bullet.series = this;
            dataItem.bullets.push(bullet);
        }
        /**
         * Adds bullet directly to a data item.
         *
         * Please note: method accepts [[Bullet]] instance as a paramter, not a
         * reference to a function.
         *
         * You should add Bullet instance, not a method like you do it on series.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/#Adding_directly_to_data_item} for more info
         * @since 5.6.0
         *
         * @param  dataItem  Target data item
         * @param  bullet    Bullet instance
         */
        addBullet(dataItem, bullet) {
            if (!dataItem.bullets) {
                dataItem.bullets = [];
            }
            if (bullet) {
                this._makeBulletReal(dataItem, bullet);
            }
        }
        _clearDirty() {
            super._clearDirty();
            this._aggregatesCalculated = false;
            this._selectionAggregatesCalculated = false;
        }
        _prepareChildren() {
            super._prepareChildren();
            let startIndex = this.startIndex();
            let endIndex = this.endIndex();
            if (this.isDirty("name")) {
                this.updateLegendValue();
            }
            if (this.isDirty("heatRules")) {
                this._valuesDirty = true;
            }
            if (this.isPrivateDirty("baseValueSeries")) {
                const baseValueSeries = this.getPrivate("baseValueSeries");
                if (baseValueSeries) {
                    this._disposers.push(baseValueSeries.onPrivate("startIndex", () => {
                        this.markDirtyValues();
                    }));
                }
            }
            const calculateAggregates = this.get("calculateAggregates");
            if (calculateAggregates) {
                if (this._valuesDirty && !this._dataProcessed) {
                    if (!this._aggregatesCalculated) {
                        this._calculateAggregates(0, this.dataItems.length);
                        this._aggregatesCalculated = true;
                        if (startIndex != 0) {
                            this._psi = undefined;
                        }
                    }
                }
                if ((this._psi != startIndex || this._pei != endIndex || this.isPrivateDirty("adjustedStartIndex")) && !this._selectionAggregatesCalculated) {
                    if (startIndex === 0 && endIndex === this.dataItems.length && this._aggregatesCalculated) ;
                    else {
                        this._calculateAggregates(startIndex, endIndex);
                    }
                    this._selectionAggregatesCalculated = true;
                }
            }
            if (this.isDirty("tooltip")) {
                let tooltip = this.get("tooltip");
                if (tooltip) {
                    tooltip.hide(0);
                    tooltip.set("tooltipTarget", this);
                }
            }
            if (this.isDirty("fill") || this.isDirty("stroke")) {
                let markerRectangle;
                const legendDataItem = this.get("legendDataItem");
                if (legendDataItem) {
                    markerRectangle = legendDataItem.get("markerRectangle");
                    if (markerRectangle) {
                        if (this.isVisible()) {
                            if (this.isDirty("stroke")) {
                                let stroke = this.get("stroke");
                                markerRectangle.set("stroke", stroke);
                            }
                            if (this.isDirty("fill")) {
                                let fill = this.get("fill");
                                markerRectangle.set("fill", fill);
                            }
                        }
                    }
                }
                this.updateLegendMarker(undefined);
            }
            if (this.bullets.length > 0) {
                let startIndex = this.startIndex();
                let endIndex = this.endIndex();
                if (endIndex < this.dataItems.length) {
                    endIndex++;
                }
                for (let i = startIndex; i < endIndex; i++) {
                    let dataItem = this.dataItems[i];
                    if (!dataItem.bullets) {
                        this._makeBullets(dataItem);
                    }
                }
            }
        }
        /**
         * @ignore
         */
        _adjustStartIndex(index) {
            return index;
        }
        _calculateAggregates(startIndex, endIndex) {
            let fields = this._valueFields;
            if (!fields) {
                throw new Error("No value fields are set for the series.");
            }
            const sum = {};
            const absSum = {};
            const count = {};
            const low = {};
            const high = {};
            const open = {};
            const close = {};
            const average = {};
            const previous = {};
            each$1(fields, (key) => {
                sum[key] = 0;
                absSum[key] = 0;
                count[key] = 0;
            });
            each$1(fields, (key) => {
                let change = key + "Change";
                let changePercent = key + "ChangePercent";
                let changePrevious = key + "ChangePrevious";
                let changePreviousPercent = key + "ChangePreviousPercent";
                let changeSelection = key + "ChangeSelection";
                let changeSelectionPercent = key + "ChangeSelectionPercent";
                let openKey = "valueY";
                if (key == "valueX" || key == "openValueX" || key == "lowValueX" || key == "highValueX") {
                    openKey = "valueX";
                }
                const baseValueSeries = this.getPrivate("baseValueSeries");
                const adjustedStartIndex = this.getPrivate("adjustedStartIndex", startIndex);
                for (let i = adjustedStartIndex; i < endIndex; i++) {
                    const dataItem = this.dataItems[i];
                    if (dataItem) {
                        let value = dataItem.get(key);
                        if (value != null) {
                            count[key]++;
                            sum[key] += value;
                            absSum[key] += Math.abs(value);
                            average[key] = sum[key] / count[key];
                            if (low[key] > value || low[key] == null) {
                                low[key] = value;
                            }
                            if (high[key] < value || high[key] == null) {
                                high[key] = value;
                            }
                            close[key] = value;
                            if (open[key] == null) {
                                open[key] = value;
                                previous[key] = value;
                                if (baseValueSeries) {
                                    open[openKey] = baseValueSeries._getBase(openKey);
                                }
                            }
                            if (startIndex === 0) {
                                dataItem.setRaw((change), value - open[openKey]);
                                dataItem.setRaw((changePercent), (value - open[openKey]) / open[openKey] * 100);
                            }
                            dataItem.setRaw((changePrevious), value - previous[openKey]);
                            dataItem.setRaw((changePreviousPercent), (value - previous[openKey]) / previous[openKey] * 100);
                            dataItem.setRaw((changeSelection), value - open[openKey]);
                            dataItem.setRaw((changeSelectionPercent), (value - open[openKey]) / open[openKey] * 100);
                            previous[key] = value;
                        }
                    }
                }
                if (endIndex < this.dataItems.length - 1) {
                    const dataItem = this.dataItems[endIndex];
                    if (dataItem) {
                        let value = dataItem.get(key);
                        dataItem.setRaw((changePrevious), value - previous[openKey]);
                        dataItem.setRaw((changePreviousPercent), (value - previous[openKey]) / previous[openKey] * 100);
                        dataItem.setRaw((changeSelection), value - open[openKey]);
                        dataItem.setRaw((changeSelectionPercent), (value - open[openKey]) / open[openKey] * 100);
                    }
                }
                if (startIndex > 0) {
                    startIndex--;
                }
                delete previous[key];
                for (let i = startIndex; i < adjustedStartIndex; i++) {
                    const dataItem = this.dataItems[i];
                    if (dataItem) {
                        let value = dataItem.get(key);
                        if (previous[key] == null) {
                            previous[key] = value;
                        }
                        if (value != null) {
                            dataItem.setRaw((changePrevious), value - previous[openKey]);
                            dataItem.setRaw((changePreviousPercent), (value - previous[openKey]) / previous[openKey] * 100);
                            dataItem.setRaw((changeSelection), value - open[openKey]);
                            dataItem.setRaw((changeSelectionPercent), (value - open[openKey]) / open[openKey] * 100);
                            previous[key] = value;
                        }
                    }
                }
            });
            each$1(fields, (key) => {
                this.setPrivate((key + "AverageSelection"), average[key]);
                this.setPrivate((key + "CountSelection"), count[key]);
                this.setPrivate((key + "SumSelection"), sum[key]);
                this.setPrivate((key + "AbsoluteSumSelection"), absSum[key]);
                this.setPrivate((key + "LowSelection"), low[key]);
                this.setPrivate((key + "HighSelection"), high[key]);
                this.setPrivate((key + "OpenSelection"), open[key]);
                this.setPrivate((key + "CloseSelection"), close[key]);
            });
            if (startIndex === 0 && endIndex === this.dataItems.length) {
                each$1(fields, (key) => {
                    this.setPrivate((key + "Average"), average[key]);
                    this.setPrivate((key + "Count"), count[key]);
                    this.setPrivate((key + "Sum"), sum[key]);
                    this.setPrivate((key + "AbsoluteSum"), absSum[key]);
                    this.setPrivate((key + "Low"), low[key]);
                    this.setPrivate((key + "High"), high[key]);
                    this.setPrivate((key + "Open"), open[key]);
                    this.setPrivate((key + "Close"), close[key]);
                });
            }
        }
        _updateChildren() {
            super._updateChildren();
            this._psi = this.startIndex();
            this._pei = this.endIndex();
            if (this.isDirty("visible")) {
                this.bulletsContainer.set("visible", this.get("visible"));
            }
            // Apply heat rules
            const rules = this.get("heatRules");
            if (this._valuesDirty && rules && rules.length > 0) {
                each$1(rules, (rule) => {
                    const minValue = rule.minValue || this.getPrivate((rule.dataField + "Low")) || 0;
                    const maxValue = rule.maxValue || this.getPrivate((rule.dataField + "High")) || 0;
                    each$1(rule.target._entities, (target) => {
                        const value = target.dataItem.get(rule.dataField);
                        if (!isNumber(value)) {
                            if (rule.neutral) {
                                target.set(rule.key, rule.neutral);
                            }
                            const states = target.states;
                            if (states) {
                                const defaultState = states.lookup("default");
                                if (defaultState && rule.neutral) {
                                    defaultState.set(rule.key, rule.neutral);
                                }
                            }
                            if (!rule.customFunction) {
                                return;
                            }
                        }
                        if (rule.customFunction) {
                            rule.customFunction.call(this, target, minValue, maxValue, value);
                        }
                        else {
                            let percent;
                            if (rule.logarithmic) {
                                percent = (Math.log(value) * Math.LOG10E - Math.log(minValue) * Math.LOG10E) / ((Math.log(maxValue) * Math.LOG10E - Math.log(minValue) * Math.LOG10E));
                            }
                            else {
                                percent = (value - minValue) / (maxValue - minValue);
                            }
                            if (isNumber(value) && (!isNumber(percent) || Math.abs(percent) == Infinity)) {
                                percent = 0.5;
                            }
                            // fixes problems if all values are the same
                            let propertyValue;
                            if (isNumber(rule.min)) {
                                propertyValue = rule.min + (rule.max - rule.min) * percent;
                            }
                            else if (rule.min instanceof Color) {
                                propertyValue = Color.interpolate(percent, rule.min, rule.max);
                            }
                            else if (rule.min instanceof Percent) {
                                propertyValue = percentInterpolate(percent, rule.min, rule.max);
                            }
                            target.set(rule.key, propertyValue);
                            const states = target.states;
                            if (states) {
                                const defaultState = states.lookup("default");
                                if (defaultState) {
                                    defaultState.set(rule.key, propertyValue);
                                }
                            }
                        }
                    });
                });
            }
            if (this.get("visible")) {
                let count = this.dataItems.length;
                let startIndex = this.startIndex();
                let endIndex = this.endIndex();
                if (endIndex < count) {
                    endIndex++;
                }
                if (startIndex > 0) {
                    startIndex--;
                }
                for (let i = 0; i < startIndex; i++) {
                    this._hideBullets(this.dataItems[i]);
                }
                for (let i = startIndex; i < endIndex; i++) {
                    this._positionBullets(this.dataItems[i]);
                }
                for (let i = endIndex; i < count; i++) {
                    this._hideBullets(this.dataItems[i]);
                }
            }
        }
        _positionBullets(dataItem) {
            if (dataItem.bullets) {
                each$1(dataItem.bullets, (bullet) => {
                    this._positionBullet(bullet);
                    const sprite = bullet.get("sprite");
                    if (bullet.get("dynamic")) {
                        if (sprite) {
                            sprite._markDirtyKey("fill");
                            sprite.markDirtySize();
                        }
                        if (sprite instanceof Container) {
                            sprite.walkChildren((child) => {
                                child._markDirtyKey("fill");
                                child.markDirtySize();
                                if (child instanceof Label) {
                                    child.text.markDirtyText();
                                }
                            });
                        }
                    }
                    if (sprite instanceof Label && sprite.get("populateText")) {
                        sprite.text.markDirtyText();
                    }
                });
            }
        }
        _hideBullets(dataItem) {
            if (dataItem.bullets) {
                each$1(dataItem.bullets, (bullet) => {
                    let sprite = bullet.get("sprite");
                    if (sprite) {
                        sprite.setPrivate("visible", false);
                    }
                });
            }
        }
        _positionBullet(_bullet) {
        }
        _placeBulletsContainer(chart) {
            chart.bulletsContainer.children.moveValue(this.bulletsContainer);
        }
        _removeBulletsContainer() {
            const bulletsContainer = this.bulletsContainer;
            if (bulletsContainer.parent) {
                bulletsContainer.parent.children.removeValue(bulletsContainer);
            }
        }
        /**
         * @ignore
         */
        disposeDataItem(dataItem) {
            //super.disposeDataItem(dataItem); // does nothing
            const bullets = dataItem.bullets;
            if (bullets) {
                each$1(bullets, (bullet) => {
                    bullet.dispose();
                });
            }
        }
        _getItemReaderLabel() {
            return "";
        }
        /**
         * Shows series's data item.
         *
         * @param   dataItem  Data item
         * @param   duration  Animation duration in milliseconds
         * @return            Promise
         */
        showDataItem(dataItem, duration) {
            const _super = Object.create(null, {
                showDataItem: { get: () => super.showDataItem }
            });
            return __awaiter(this, void 0, void 0, function* () {
                const promises = [_super.showDataItem.call(this, dataItem, duration)];
                const bullets = dataItem.bullets;
                if (bullets) {
                    each$1(bullets, (bullet) => {
                        const sprite = bullet.get("sprite");
                        if (sprite) {
                            promises.push(sprite.show(duration));
                        }
                    });
                }
                yield Promise.all(promises);
            });
        }
        /**
         * Hides series's data item.
         *
         * @param   dataItem  Data item
         * @param   duration  Animation duration in milliseconds
         * @return            Promise
         */
        hideDataItem(dataItem, duration) {
            const _super = Object.create(null, {
                hideDataItem: { get: () => super.hideDataItem }
            });
            return __awaiter(this, void 0, void 0, function* () {
                const promises = [_super.hideDataItem.call(this, dataItem, duration)];
                const bullets = dataItem.bullets;
                if (bullets) {
                    each$1(bullets, (bullet) => {
                        const sprite = bullet.get("sprite");
                        if (sprite) {
                            promises.push(sprite.hide(duration));
                        }
                    });
                }
                yield Promise.all(promises);
            });
        }
        _sequencedShowHide(show, duration) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.get("sequencedInterpolation")) {
                    if (!isNumber(duration)) {
                        duration = this.get("interpolationDuration", 0);
                    }
                    if (duration > 0) {
                        const startIndex = this.startIndex();
                        const endIndex = this.endIndex();
                        yield Promise.all(map(this.dataItems, (dataItem, i) => __awaiter(this, void 0, void 0, function* () {
                            let realDuration = duration || 0;
                            if (i < startIndex - 10 || i > endIndex + 10) {
                                realDuration = 0;
                            }
                            //let delay = this.get("sequencedDelay", 0) * i + realDuration * (i - startIndex) / (endIndex - startIndex);
                            let delay = this.get("sequencedDelay", 0) + realDuration / (endIndex - startIndex);
                            yield sleep(delay * (i - startIndex));
                            if (show) {
                                yield this.showDataItem(dataItem, realDuration);
                            }
                            else {
                                yield this.hideDataItem(dataItem, realDuration);
                            }
                        })));
                    }
                    else {
                        yield Promise.all(map(this.dataItems, (dataItem) => {
                            if (show) {
                                return this.showDataItem(dataItem, 0);
                            }
                            else {
                                return this.hideDataItem(dataItem, 0);
                            }
                        }));
                    }
                }
            });
        }
        /**
         * @ignore
         */
        updateLegendValue(dataItem) {
            if (dataItem) {
                const legendDataItem = dataItem.get("legendDataItem");
                if (legendDataItem) {
                    const valueLabel = legendDataItem.get("valueLabel");
                    if (valueLabel) {
                        const text = valueLabel.text;
                        let txt = "";
                        valueLabel._setDataItem(dataItem);
                        txt = this.get("legendValueText", text.get("text", ""));
                        valueLabel.set("text", txt);
                        text.markDirtyText();
                    }
                    const label = legendDataItem.get("label");
                    if (label) {
                        const text = label.text;
                        let txt = "";
                        label._setDataItem(dataItem);
                        txt = this.get("legendLabelText", text.get("text", ""));
                        label.set("text", txt);
                        text.markDirtyText();
                    }
                }
            }
        }
        /**
         * @ignore
         */
        updateLegendMarker(_dataItem) {
        }
        _onHide() {
            super._onHide();
            const tooltip = this.getTooltip();
            if (tooltip) {
                tooltip.hide();
            }
        }
        /**
         * @ignore
         */
        hoverDataItem(_dataItem) { }
        /**
         * @ignore
         */
        unhoverDataItem(_dataItem) { }
        /**
         * @ignore
         */
        _getBase(key) {
            const dataItem = this.dataItems[this.startIndex()];
            if (dataItem) {
                return dataItem.get(key);
            }
            return 0;
        }
    }
    Object.defineProperty(Series, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Series"
    });
    Object.defineProperty(Series, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Component.classNames.concat([Series.className])
    });

    /**
     * A universal legend control.
     *
     * @important
     * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/} for more info
     */
    class Legend extends Series {
        constructor() {
            super(...arguments);
            /**
             * List of all [[Container]] elements for legend items.
             *
             * @default new ListTemplate<Container>
             */
            Object.defineProperty(this, "itemContainers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Container._new(this._root, {
                    themeTags: mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item"]),
                    themeTagsSelf: mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]),
                    background: RoundedRectangle.new(this._root, {
                        themeTags: mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item", "background"]),
                        themeTagsSelf: mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"])
                    })
                }, [this.itemContainers.template]))
            });
            /**
             * List of legend marker elements.
             *
             * @default new ListTemplate<Container>
             */
            Object.defineProperty(this, "markers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Container._new(this._root, {
                    themeTags: mergeTags(this.markers.template.get("themeTags", []), ["legend", "marker"])
                }, [this.markers.template]))
            });
            /**
             * List of legend label elements.
             *
             * @default new ListTemplate<Label>
             */
            Object.defineProperty(this, "labels", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Label._new(this._root, {
                    themeTags: mergeTags(this.labels.template.get("themeTags", []), ["legend", "label"])
                }, [this.labels.template]))
            });
            /**
             * List of legend value label elements.
             *
             * @default new ListTemplate<label>
             */
            Object.defineProperty(this, "valueLabels", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Label._new(this._root, {
                    themeTags: mergeTags(this.valueLabels.template.get("themeTags", []), ["legend", "label", "value"])
                }, [this.valueLabels.template]))
            });
            /**
             * List of rectangle elements used for default legend markers.
             *
             * @default new ListTemplate<RoundedRectangle>
             */
            Object.defineProperty(this, "markerRectangles", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {
                    themeTags: mergeTags(this.markerRectangles.template.get("themeTags", []), ["legend", "marker", "rectangle"])
                }, [this.markerRectangles.template]))
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["legend"]);
            this.fields.push("name", "stroke", "fill");
            super._afterNew();
        }
        /**
         * @ignore
         */
        makeItemContainer(dataItem) {
            const itemContainer = this.children.push(this.itemContainers.make());
            itemContainer._setDataItem(dataItem);
            this.itemContainers.push(itemContainer);
            itemContainer.states.create("disabled", {});
            return itemContainer;
        }
        /**
         * @ignore
         */
        makeMarker() {
            const marker = this.markers.make();
            this.markers.push(marker);
            marker.states.create("disabled", {});
            return marker;
        }
        /**
         * @ignore
         */
        makeLabel() {
            const label = this.labels.make();
            label.states.create("disabled", {});
            return label;
        }
        /**
         * @ignore
         */
        makeValueLabel() {
            const valueLabel = this.valueLabels.make();
            valueLabel.states.create("disabled", {});
            return valueLabel;
        }
        /**
         * @ignore
         */
        makeMarkerRectangle() {
            const markerRectangle = this.markerRectangles.make();
            markerRectangle.states.create("disabled", {});
            return markerRectangle;
        }
        processDataItem(dataItem) {
            super.processDataItem(dataItem);
            const itemContainer = this.makeItemContainer(dataItem);
            const nameField = this.get("nameField");
            const fillField = this.get("fillField");
            const strokeField = this.get("strokeField");
            if (itemContainer) {
                const clickTarget = this.get("clickTarget", "itemContainer");
                const item = dataItem.dataContext;
                if (item && item.set) {
                    item.set("legendDataItem", dataItem);
                }
                itemContainer._setDataItem(dataItem);
                dataItem.set("itemContainer", itemContainer);
                const marker = this.makeMarker();
                if (marker) {
                    itemContainer.children.push(marker);
                    marker._setDataItem(dataItem);
                    dataItem.set("marker", marker);
                    const useDefaultMarker = this.get("useDefaultMarker");
                    const markerRectangle = marker.children.push(this.makeMarkerRectangle());
                    let fill = dataItem.get("fill");
                    let stroke = dataItem.get("stroke");
                    dataItem.set("markerRectangle", markerRectangle);
                    if (item && item.get) {
                        fill = item.get(fillField, fill);
                        stroke = item.get(strokeField, stroke);
                    }
                    if (!stroke) {
                        stroke = fill;
                    }
                    if (!useDefaultMarker) {
                        if (item && item.createLegendMarker) {
                            item.createLegendMarker();
                        }
                    }
                    else {
                        if (item.on) {
                            item.on(fillField, () => {
                                markerRectangle.set("fill", item.get(fillField));
                            });
                            item.on(strokeField, () => {
                                markerRectangle.set("stroke", item.get(strokeField));
                            });
                        }
                    }
                    markerRectangle.setAll({ fill, stroke });
                    // this solves if template field is set on slice
                    const component = item.component;
                    if (component && component.updateLegendMarker) {
                        component.updateLegendMarker(item);
                    }
                }
                const label = this.makeLabel();
                if (label) {
                    itemContainer.children.push(label);
                    label._setDataItem(dataItem);
                    dataItem.set("label", label);
                    label.text.on("text", () => {
                        itemContainer.setRaw("ariaLabel", label.text._getText() + (this.get("clickTarget") !== "none" ? "; " + this._t("Press ENTER to toggle") : ""));
                        itemContainer.markDirtyAccessibility();
                    });
                    if (item && item.get) {
                        dataItem.set("name", item.get(nameField));
                    }
                    let name = dataItem.get("name");
                    if (name) {
                        label.set("text", name);
                    }
                }
                const valueLabel = this.makeValueLabel();
                if (valueLabel) {
                    itemContainer.children.push(valueLabel);
                    valueLabel._setDataItem(dataItem);
                    dataItem.set("valueLabel", valueLabel);
                }
                if (item && item.show) {
                    item.on("visible", (visible) => {
                        itemContainer.set("disabled", !visible);
                    });
                    if (!item.get("visible")) {
                        itemContainer.set("disabled", true);
                    }
                    if (clickTarget != "none") {
                        let clickContainer = itemContainer;
                        if (clickTarget == "marker") {
                            clickContainer = marker;
                        }
                        this._addClickEvents(clickContainer, item, dataItem);
                    }
                }
                // Sort children
                this.children.values.sort((a, b) => {
                    const targetA = a.dataItem.dataContext;
                    const targetB = b.dataItem.dataContext;
                    if (targetA && targetB) {
                        const indexA = this.data.indexOf(targetA);
                        const indexB = this.data.indexOf(targetB);
                        if (indexA > indexB) {
                            return 1;
                        }
                        else if (indexA < indexB) {
                            return -1;
                        }
                    }
                    return 0;
                });
                if (item && item.updateLegendValue) {
                    item.updateLegendValue();
                }
            }
        }
        _addClickEvents(container, item, dataItem) {
            container.set("cursorOverStyle", "pointer");
            container.events.on("pointerover", () => {
                const component = item.component;
                if (component && component.hoverDataItem) {
                    component.hoverDataItem(item);
                }
            });
            container.events.on("pointerout", () => {
                const component = item.component;
                if (component && component.hoverDataItem) {
                    component.unhoverDataItem(item);
                }
            });
            container.events.on("click", () => {
                const labelText = dataItem.get("label").text._getText();
                if (item.show && item.isHidden && (item.isHidden() || item.get("visible") === false)) {
                    item.show();
                    container.set("disabled", false);
                    this._root.readerAlert(this._t("%1 shown", this._root.locale, labelText));
                }
                else if (item.hide) {
                    item.hide();
                    container.set("disabled", true);
                    this._root.readerAlert(this._t("%1 hidden", this._root.locale, labelText));
                }
            });
        }
        /**
         * @ignore
         */
        disposeDataItem(dataItem) {
            super.disposeDataItem(dataItem);
            const dataContext = dataItem.dataContext;
            if (dataContext && dataContext.get) {
                const di = dataContext.get("legendDataItem");
                if (di == dataItem) {
                    dataContext.set("legendDataItem", undefined);
                }
            }
            let itemContainer = dataItem.get("itemContainer");
            if (itemContainer) {
                this.itemContainers.removeValue(itemContainer);
                itemContainer.dispose();
            }
            let marker = dataItem.get("marker");
            if (marker) {
                this.markers.removeValue(marker);
                marker.dispose();
            }
            let markerRectangle = dataItem.get("markerRectangle");
            if (markerRectangle) {
                this.markerRectangles.removeValue(markerRectangle);
                markerRectangle.dispose();
            }
            let label = dataItem.get("label");
            if (label) {
                this.labels.removeValue(label);
                label.dispose();
            }
            let valueLabel = dataItem.get("valueLabel");
            if (valueLabel) {
                this.valueLabels.removeValue(valueLabel);
                valueLabel.dispose();
            }
        }
    }
    Object.defineProperty(Legend, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Legend"
    });
    Object.defineProperty(Legend, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Series.classNames.concat([Legend.className])
    });

    /** @ignore */ /** */
    /**
     * @ignore
     */
    function segmentedLine(display, segments) {
        for (let s = 0, len = segments.length; s < len; s++) {
            const groups = segments[s];
            if (groups.length > 0) {
                let firstGroup = groups[0];
                if (firstGroup.length > 0) {
                    let firstPoint = firstGroup[0];
                    display.moveTo(firstPoint.x, firstPoint.y);
                    for (let g = 0, len = groups.length; g < len; g++) {
                        line(display, groups[g]);
                    }
                }
            }
        }
    }
    /**
     * @ignore
     */
    function line(display, points) {
        for (let p = 0, len = points.length; p < len; p++) {
            const point = points[p];
            display.lineTo(point.x, point.y);
        }
    }

    /**
     * Draws a line.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     * @important
     */
    class Line extends Graphics {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("points") || this.isDirty("segments") || this._sizeDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear) {
                const points = this.get("points");
                const segments = this.get("segments");
                if (points && points.length > 0) {
                    let point = points[0];
                    this._display.moveTo(point.x, point.y);
                    segmentedLine(this._display, [[points]]);
                }
                else if (segments) {
                    segmentedLine(this._display, segments);
                }
                else if (!this.get("draw")) {
                    let w = this.width();
                    let h = this.height();
                    this._display.moveTo(0, 0);
                    this._display.lineTo(w, h);
                }
            }
        }
    }
    Object.defineProperty(Line, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Line"
    });
    Object.defineProperty(Line, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Line.className])
    });

    /**
     * Displays an image.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/images/} for more info
     * @important
     */
    class Picture extends Sprite {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_display", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._root._renderer.makePicture(undefined)
            });
        }
        _changed() {
            super._changed();
            if (this.isDirty("width")) {
                const width = this.get("width");
                this._display.width = isNumber(width) ? width : undefined;
            }
            if (this.isDirty("height")) {
                const height = this.get("height");
                this._display.height = isNumber(height) ? height : undefined;
            }
            if (this.isDirty("shadowColor")) {
                this._display.clear();
                const shadowColor = this.get("shadowColor");
                this._display.shadowColor = shadowColor == null ? undefined : shadowColor;
            }
            if (this.isDirty("shadowBlur")) {
                this._display.clear();
                this._display.shadowBlur = this.get("shadowBlur");
            }
            if (this.isDirty("shadowOffsetX")) {
                this._display.clear();
                this._display.shadowOffsetX = this.get("shadowOffsetX");
            }
            if (this.isDirty("shadowOffsetY")) {
                this._display.clear();
                this._display.shadowOffsetY = this.get("shadowOffsetY");
            }
            if (this.isDirty("shadowOpacity")) {
                this._display.clear();
                this._display.shadowOpacity = this.get("shadowOpacity");
            }
            if (this.isDirty("src") || this.isDirty("cors")) {
                this._display.clear();
                this._load();
            }
        }
        _load() {
            const src = this.get("src");
            if (src) {
                const image = new Image();
                image.crossOrigin = this.get("cors", "anonymous");
                image.src = src;
                const events = this.events;
                image.decode().then(() => {
                    this._display.image = image;
                    this._updateSize();
                    if (!events.isDisposed() && events.isEnabled("loaded")) {
                        events.dispatch("loaded", { type: "loaded", target: this });
                    }
                }).catch((_error) => {
                    if (!events.isDisposed() && events.isEnabled("loaderror")) {
                        events.dispatch("loaderror", { type: "loaderror", target: this });
                    }
                });
            }
        }
        _updateSize() {
            super._updateSize();
            const image = this._display.image;
            if (image) {
                let w = this.getPrivate("width", this.get("width"));
                let h = this.getPrivate("height", this.get("height"));
                const r = image.width && image.height ? image.width / image.height : 0;
                if (isNumber(w) && isNumber(h)) {
                    this._display.width = w;
                    this._display.height = h;
                }
                else if (isNumber(w) && r) {
                    h = w / r;
                }
                else if (isNumber(h) && r) {
                    w = h * r;
                }
                else {
                    w = image.width;
                    h = image.height;
                }
                if (isNumber(w)) {
                    this._display.width = w;
                }
                if (isNumber(h)) {
                    this._display.height = h;
                }
                this.markDirtyBounds();
                this.markDirty();
            }
        }
    }
    Object.defineProperty(Picture, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Picture"
    });
    Object.defineProperty(Picture, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Sprite.classNames.concat([Picture.className])
    });

    /**
     * @ignore
     */
    class RadialText extends Text {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_display", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._root._renderer.makeRadialText("", this.textStyle)
            });
        }
        _afterNew() {
            super._afterNew();
        }
        _beforeChanged() {
            super._beforeChanged();
            this._display.clear();
            if (this.isDirty("textType")) {
                this._display.textType = this.get("textType");
                this.markDirtyBounds();
            }
            if (this.isDirty("radius")) {
                this._display.radius = this.get("radius");
                this.markDirtyBounds();
            }
            if (this.isDirty("startAngle")) {
                this._display.startAngle = (this.get("startAngle", 0) + 90) * RADIANS;
                this.markDirtyBounds();
            }
            if (this.isDirty("inside")) {
                this._display.inside = this.get("inside");
                this.markDirtyBounds();
            }
            if (this.isDirty("orientation")) {
                this._display.orientation = this.get("orientation");
                this.markDirtyBounds();
            }
            if (this.isDirty("kerning")) {
                this._display.kerning = this.get("kerning");
                this.markDirtyBounds();
            }
        }
    }
    Object.defineProperty(RadialText, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RadialText"
    });
    Object.defineProperty(RadialText, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Text.classNames.concat([RadialText.className])
    });

    // import * as $object from "../util/Object";
    class RadialLabel extends Label {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_flipped", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        _afterNew() {
            this._textKeys.push("textType", "kerning");
            super._afterNew();
        }
        _makeText() {
            this._text = this.children.push(RadialText.new(this._root, {}));
        }
        /**
         * Returns base radius in pixels.
         *
         * @return Base radius
         */
        baseRadius() {
            const radiusPrivate = this.getPrivate("radius", 0);
            const innerRadiusPrivate = this.getPrivate("innerRadius", 0);
            const baseRadius = this.get("baseRadius", 0);
            return innerRadiusPrivate + relativeToValue(baseRadius, radiusPrivate - innerRadiusPrivate);
        }
        /**
         * Returns radius adjustment in pixels.
         *
         * @return Radius
         */
        radius() {
            const inside = this.get("inside", false);
            return this.baseRadius() + this.get("radius", 0) * (inside ? -1 : 1);
        }
        _updateChildren() {
            super._updateChildren();
            if (this.isDirty("baseRadius") || this.isPrivateDirty("radius") || this.isPrivateDirty("innerRadius") || this.isDirty("labelAngle") || this.isDirty("radius") || this.isDirty("inside") || this.isDirty("orientation") || this.isDirty("textType")) {
                const textType = this.get("textType", "adjusted");
                const inside = this.get("inside", false);
                const orientation = this.get("orientation");
                let labelAngle = normalizeAngle(this.get("labelAngle", 0));
                this._text.set("startAngle", this.get("labelAngle", 0));
                this._text.set("inside", inside);
                const sin$1 = sin(labelAngle);
                const cos$1 = cos(labelAngle);
                let baseRadius = this.baseRadius();
                let radius = this.radius();
                this._display.angle = 0;
                if (textType == "circular") {
                    this.setAll({
                        paddingTop: 0,
                        paddingBottom: 0,
                        paddingLeft: 0,
                        paddingRight: 0
                    });
                    this.setRaw("x", undefined);
                    this.setRaw("y", undefined);
                    // Circular labels are handled and positioned differently
                    this._text.set("orientation", orientation);
                    this._text.set("radius", radius);
                }
                else {
                    if (baseRadius == 0) {
                        labelAngle = 0;
                        radius = 0;
                    }
                    // Positioning of radial/regular labels are teh same
                    let x = radius * cos$1;
                    let y = radius * sin$1;
                    if (textType == "radial") {
                        this.setRaw("x", x);
                        this.setRaw("y", y);
                        if ((labelAngle < 90) || (labelAngle > 270) || orientation != "auto") {
                            this._display.angle = labelAngle; // + 90;
                            this._flipped = false;
                        }
                        else {
                            this._display.angle = labelAngle + 180;
                            this._flipped = true;
                        }
                        this._dirty.rotation = false;
                    }
                    else if (textType == "adjusted") {
                        this.setRaw("centerX", p50);
                        this.setRaw("centerY", p50);
                        this.setRaw("x", x);
                        this.setRaw("y", y);
                    }
                    else if (textType == "regular") {
                        this.setRaw("x", x);
                        this.setRaw("y", y);
                    }
                }
                this.markDirtyPosition();
                this.markDirtyBounds();
            }
        }
        _updatePosition() {
            const textType = this.get("textType", "regular");
            const inside = this.get("inside", false);
            let dx = 0;
            let dy = 0;
            let labelAngle = this.get("labelAngle", 0);
            let bounds = this.localBounds();
            let w = bounds.right - bounds.left;
            let h = bounds.bottom - bounds.top;
            if (textType == "radial") {
                if (this._flipped) {
                    let centerX = this.get("centerX");
                    if (centerX instanceof Percent) {
                        w = w * (1 - centerX.value * 2);
                    }
                    dx = w * cos(labelAngle);
                    dy = w * sin(labelAngle);
                }
            }
            else if (!inside && textType == "adjusted") {
                dx = w / 2 * cos(labelAngle);
                dy = h / 2 * sin(labelAngle);
            }
            this.setRaw("dx", dx);
            this.setRaw("dy", dy);
            super._updatePosition();
        }
        /**
         * @ignore
         */
        get text() {
            return this._text;
        }
    }
    Object.defineProperty(RadialLabel, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RadialLabel"
    });
    Object.defineProperty(RadialLabel, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Label.classNames.concat([RadialLabel.className])
    });

    /**
     * Draws a triangle.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     * @important
     */
    class Triangle extends Graphics {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear && !this.get("draw")) {
                this._draw();
            }
        }
        _draw() {
            const w = this.width();
            const h = this.height();
            const display = this._display;
            display.moveTo(-w / 2, h / 2);
            display.lineTo(0, -h / 2);
            display.lineTo(w / 2, h / 2);
            display.lineTo(-w / 2, h / 2);
            display.closePath();
        }
        _updateSize() {
            this.markDirty();
            this._clear = true;
        }
    }
    Object.defineProperty(Triangle, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Triangle"
    });
    Object.defineProperty(Triangle, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Triangle.className])
    });

    /**
     * A control that allows zooming chart's axes, or other uses requiring range
     * selection.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/scrollbars/} for more info
     */
    class Scrollbar extends Container {
        constructor() {
            super(...arguments);
            /**
             * A thumb elment - a draggable square between the grips, used for panning
             * the selection.
             */
            Object.defineProperty(this, "thumb", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._makeThumb()
            });
            /**
             * Start grip button.
             */
            Object.defineProperty(this, "startGrip", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._makeButton()
            });
            /**
             * End grip button.
             */
            Object.defineProperty(this, "endGrip", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._makeButton()
            });
            Object.defineProperty(this, "_thumbBusy", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_startDown", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_endDown", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_thumbDown", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_gripDown", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _addOrientationClass() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["scrollbar", this._settings.orientation]);
            if (!this._settings.background) {
                this._settings.background = RoundedRectangle.new(this._root, {
                    themeTags: mergeTags(this._settings.themeTags, ["main", "background"])
                });
            }
        }
        _makeButton() {
            return this.children.push(Button.new(this._root, {
                themeTags: ["resize", "button", this.get("orientation")], icon: Graphics.new(this._root, {
                    themeTags: ["icon"]
                })
            }));
        }
        _makeThumb() {
            return this.children.push(RoundedRectangle.new(this._root, {
                themeTags: ["thumb", this.get("orientation")]
            }));
        }
        _handleAnimation(animation) {
            if (animation) {
                this._disposers.push(animation.events.on("stopped", () => {
                    this.setPrivateRaw("isBusy", false);
                    this._thumbBusy = false;
                }));
            }
        }
        _afterNew() {
            this._addOrientationClass();
            super._afterNew();
            const startGrip = this.startGrip;
            const endGrip = this.endGrip;
            const thumb = this.thumb;
            const background = this.get("background");
            if (background) {
                this._disposers.push(background.events.on("click", (event) => {
                    this.setPrivateRaw("isBusy", true);
                    const point = this._display.toLocal(event.point);
                    const w = this.width();
                    const h = this.height();
                    const orientation = this.get("orientation");
                    let newMiddle;
                    if (orientation == "vertical") {
                        newMiddle = (point.y - thumb.height() / 2) / h;
                    }
                    else {
                        newMiddle = (point.x - thumb.width() / 2) / w;
                    }
                    let newCoordinate;
                    let key;
                    if (orientation == "vertical") {
                        newCoordinate = newMiddle * h;
                        key = "y";
                    }
                    else {
                        newCoordinate = newMiddle * w;
                        key = "x";
                    }
                    const duration = this.get("animationDuration", 0);
                    if (duration > 0) {
                        this._thumbBusy = true;
                        this._handleAnimation(this.thumb.animate({ key: key, to: newCoordinate, duration: duration, easing: this.get("animationEasing") }));
                    }
                    else {
                        this.thumb.set(key, newCoordinate);
                        this._root.events.once("frameended", () => {
                            this.setPrivateRaw("isBusy", false);
                        });
                    }
                }));
            }
            this._disposers.push(thumb.events.on("dblclick", (event) => {
                if (!isLocalEvent(event.originalEvent, this)) {
                    return;
                }
                const duration = this.get("animationDuration", 0);
                const easing = this.get("animationEasing");
                this.animate({ key: "start", to: 0, duration: duration, easing: easing });
                this.animate({ key: "end", to: 1, duration: duration, easing: easing });
            }));
            this._disposers.push(startGrip.events.on("pointerdown", () => {
                this.setPrivateRaw("isBusy", true);
                this._startDown = true;
                this._gripDown = "start";
            }));
            this._disposers.push(endGrip.events.on("pointerdown", () => {
                this.setPrivateRaw("isBusy", true);
                this._endDown = true;
                this._gripDown = "end";
            }));
            this._disposers.push(thumb.events.on("pointerdown", () => {
                this.setPrivateRaw("isBusy", true);
                this._thumbDown = true;
                this._gripDown = undefined;
            }));
            this._disposers.push(startGrip.events.on("globalpointerup", () => {
                if (this._startDown) {
                    this.setPrivateRaw("isBusy", false);
                    this._released();
                }
                this._startDown = false;
            }));
            this._disposers.push(endGrip.events.on("globalpointerup", () => {
                if (this._endDown) {
                    this.setPrivateRaw("isBusy", false);
                    this._released();
                }
                this._endDown = false;
            }));
            this._disposers.push(thumb.events.on("globalpointerup", () => {
                if (this._thumbDown) {
                    this.setPrivateRaw("isBusy", false);
                    this._released();
                }
                this._thumbDown = false;
            }));
            this._disposers.push(startGrip.on("x", () => {
                this._updateThumb();
            }));
            this._disposers.push(endGrip.on("x", () => {
                this._updateThumb();
            }));
            this._disposers.push(startGrip.on("y", () => {
                this._updateThumb();
            }));
            this._disposers.push(endGrip.on("y", () => {
                this._updateThumb();
            }));
            this._disposers.push(thumb.events.on("positionchanged", () => {
                this._updateGripsByThumb();
            }));
            if (this.get("orientation") == "vertical") {
                startGrip.set("x", 0);
                endGrip.set("x", 0);
                this._disposers.push(thumb.adapters.add("y", (value) => {
                    return Math.max(Math.min(Number(value), this.height() - thumb.height()), 0);
                }));
                this._disposers.push(thumb.adapters.add("x", (_value) => {
                    return this.width() / 2;
                }));
                this._disposers.push(startGrip.adapters.add("x", (_value) => {
                    return this.width() / 2;
                }));
                this._disposers.push(endGrip.adapters.add("x", (_value) => {
                    return this.width() / 2;
                }));
                this._disposers.push(startGrip.adapters.add("y", (value) => {
                    return Math.max(Math.min(Number(value), this.height()), 0);
                }));
                this._disposers.push(endGrip.adapters.add("y", (value) => {
                    return Math.max(Math.min(Number(value), this.height()), 0);
                }));
            }
            else {
                startGrip.set("y", 0);
                endGrip.set("y", 0);
                this._disposers.push(thumb.adapters.add("x", (value) => {
                    return Math.max(Math.min(Number(value), this.width() - thumb.width()), 0);
                }));
                this._disposers.push(thumb.adapters.add("y", (_value) => {
                    return this.height() / 2;
                }));
                this._disposers.push(startGrip.adapters.add("y", (_value) => {
                    return this.height() / 2;
                }));
                this._disposers.push(endGrip.adapters.add("y", (_value) => {
                    return this.height() / 2;
                }));
                this._disposers.push(startGrip.adapters.add("x", (value) => {
                    return Math.max(Math.min(Number(value), this.width()), 0);
                }));
                this._disposers.push(endGrip.adapters.add("x", (value) => {
                    return Math.max(Math.min(Number(value), this.width()), 0);
                }));
            }
        }
        _updateChildren() {
            super._updateChildren();
            if (this.isDirty("end") || this.isDirty("start") || this._sizeDirty) {
                this.updateGrips();
            }
        }
        _changed() {
            super._changed();
            if (this.isDirty("start") || this.isDirty("end")) {
                const eventType = "rangechanged";
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, { type: eventType, target: this, start: this.get("start", 0), end: this.get("end", 1), grip: this._gripDown });
                }
            }
        }
        _released() {
            const eventType = "released";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, { type: eventType, target: this });
            }
        }
        /**
         * @ignore
         */
        updateGrips() {
            const startGrip = this.startGrip;
            const endGrip = this.endGrip;
            const orientation = this.get("orientation");
            const height = this.height();
            const width = this.width();
            if (orientation == "vertical") {
                startGrip.set("y", height * this.get("start", 0));
                endGrip.set("y", height * this.get("end", 1));
            }
            else {
                startGrip.set("x", width * this.get("start", 0));
                endGrip.set("x", width * this.get("end", 1));
            }
            const valueFunction = this.getPrivate("positionTextFunction");
            const from = Math.round(this.get("start", 0) * 100);
            const to = Math.round(this.get("end", 0) * 100);
            let fromValue;
            let toValue;
            if (valueFunction) {
                fromValue = valueFunction.call(this, this.get("start", 0));
                toValue = valueFunction.call(this, this.get("end", 0));
            }
            else {
                fromValue = from + "%";
                toValue = to + "%";
            }
            startGrip.set("ariaLabel", this._t("From %1", undefined, fromValue));
            startGrip.set("ariaValueNow", "" + from);
            startGrip.set("ariaValueText", from + "%");
            startGrip.set("ariaValueMin", "0");
            startGrip.set("ariaValueMax", "100");
            endGrip.set("ariaLabel", this._t("To %1", undefined, toValue));
            endGrip.set("ariaValueNow", "" + to);
            endGrip.set("ariaValueText", to + "%");
            endGrip.set("ariaValueMin", "0");
            endGrip.set("ariaValueMax", "100");
        }
        _updateThumb() {
            const thumb = this.thumb;
            const startGrip = this.startGrip;
            const endGrip = this.endGrip;
            const height = this.height();
            const width = this.width();
            let x0 = startGrip.x();
            let x1 = endGrip.x();
            let y0 = startGrip.y();
            let y1 = endGrip.y();
            let start = 0;
            let end = 1;
            if (this.get("orientation") == "vertical") {
                if (isNumber(y0) && isNumber(y1)) {
                    if (!this._thumbBusy && !thumb.isDragging()) {
                        thumb.set("height", y1 - y0);
                        thumb.set("y", y0);
                    }
                    start = y0 / height;
                    end = y1 / height;
                }
            }
            else {
                if (isNumber(x0) && isNumber(x1)) {
                    if (!this._thumbBusy && !thumb.isDragging()) {
                        thumb.set("width", x1 - x0);
                        thumb.set("x", x0);
                    }
                    start = x0 / width;
                    end = x1 / width;
                }
            }
            if (this.getPrivate("isBusy") && (this.get("start") != start || this.get("end") != end)) {
                this.set("start", start);
                this.set("end", end);
            }
            const valueFunction = this.getPrivate("positionTextFunction");
            const from = Math.round(this.get("start", 0) * 100);
            const to = Math.round(this.get("end", 0) * 100);
            let fromValue;
            let toValue;
            if (valueFunction) {
                fromValue = valueFunction.call(this, this.get("start", 0));
                toValue = valueFunction.call(this, this.get("end", 0));
            }
            else {
                fromValue = from + "%";
                toValue = to + "%";
            }
            thumb.set("ariaLabel", this._t("From %1 to %2", undefined, fromValue, toValue));
            thumb.set("ariaValueNow", "" + from);
            thumb.set("ariaValueText", from + "%");
        }
        _updateGripsByThumb() {
            const thumb = this.thumb;
            const startGrip = this.startGrip;
            const endGrip = this.endGrip;
            if (this.get("orientation") == "vertical") {
                const thumbSize = thumb.height();
                startGrip.set("y", thumb.y());
                endGrip.set("y", thumb.y() + thumbSize);
            }
            else {
                const thumbSize = thumb.width();
                startGrip.set("x", thumb.x());
                endGrip.set("x", thumb.x() + thumbSize);
            }
        }
    }
    Object.defineProperty(Scrollbar, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Scrollbar"
    });
    Object.defineProperty(Scrollbar, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Scrollbar.className])
    });

    /**
     * A control that allows zooming chart's axes, or other uses requiring range
     * selection.
     */
    class Slider extends Scrollbar {
        _afterNew() {
            this._addOrientationClass();
            super._afterNew();
            this.endGrip.setPrivate("visible", false);
            this.thumb.setPrivate("visible", false);
        }
        /**
         * @ignore
         */
        updateGrips() {
            super.updateGrips();
            const startGrip = this.startGrip;
            this.endGrip.setAll({ x: startGrip.x(), y: startGrip.y() });
            this.setRaw("end", this.get("start"));
        }
    }
    Object.defineProperty(Slider, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Slider"
    });
    Object.defineProperty(Slider, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Scrollbar.classNames.concat([Slider.className])
    });

    /**
     * Draws a slice shape.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     */
    class Slice extends Graphics {
        constructor() {
            super(...arguments);
            /**
             * @ignore
             */
            Object.defineProperty(this, "ix", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            /**
             * @ignore
             */
            Object.defineProperty(this, "iy", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_generator", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: arc()
            });
        }
        _getTooltipPoint() {
            let tooltipX = this.get("tooltipX");
            let tooltipY = this.get("tooltipY");
            let x = 0;
            let y = 0;
            if (isNumber(tooltipX)) {
                x = tooltipX;
            }
            if (isNumber(tooltipY)) {
                y = tooltipY;
            }
            let radius = this.get("radius", 0);
            let innerRadius = this.get("innerRadius", 0);
            let dRadius = this.get("dRadius", 0);
            let dInnerRadius = this.get("dInnerRadius", 0);
            radius += dRadius;
            innerRadius += dInnerRadius;
            if (innerRadius < 0) {
                innerRadius = radius + innerRadius;
            }
            if (tooltipX instanceof Percent) {
                x = this.ix * (innerRadius + (radius - innerRadius) * tooltipX.value);
            }
            if (tooltipY instanceof Percent) {
                y = this.iy * (innerRadius + (radius - innerRadius) * tooltipY.value);
            }
            if (this.get("arc") >= 360 && innerRadius == 0) {
                x = 0;
                y = 0;
            }
            return { x, y };
        }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("radius") || this.isDirty("arc") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("dRadius") || this.isDirty("dInnerRadius") || this.isDirty("cornerRadius") || this.isDirty("shiftRadius")) {
                this._clear = true;
            }
        }
        _changed() {
            super._changed();
            if (this._clear) {
                let startAngle = this.get("startAngle", 0);
                let arc = this.get("arc", 0);
                const generator = this._generator;
                if (arc < 0) {
                    startAngle = startAngle + arc;
                    arc = arc * -1;
                }
                if (arc > 0.1) { // this fixes bug with full circle when arc is very small
                    generator.cornerRadius(this.get("cornerRadius", 0));
                }
                generator.context(this._display);
                let radius = this.get("radius", 0);
                let innerRadius = this.get("innerRadius", 0);
                let dRadius = this.get("dRadius", 0);
                let dInnerRadius = this.get("dInnerRadius", 0);
                radius += dRadius;
                innerRadius += dInnerRadius;
                if (innerRadius < 0) {
                    innerRadius = radius + innerRadius;
                }
                generator({ innerRadius: innerRadius, outerRadius: radius, startAngle: (startAngle + 90) * RADIANS, endAngle: (startAngle + arc + 90) * RADIANS });
                let middleAngle = startAngle + arc / 2;
                this.ix = cos(middleAngle);
                this.iy = sin(middleAngle);
                const shiftRadius = this.get("shiftRadius", 0);
                this.setRaw("dx", this.ix * shiftRadius);
                this.setRaw("dy", this.iy * shiftRadius);
                this.markDirtyPosition();
            }
        }
    }
    Object.defineProperty(Slice, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Slice"
    });
    Object.defineProperty(Slice, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Slice.className])
    });

    /**
     * A base class for all charts.
     */
    class Chart extends Container {
        constructor() {
            super(...arguments);
            /**
             * A [[Container]] chart places its elements in.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "chartContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Container.new(this._root, { width: p100, height: p100, interactiveChildren: false }))
            });
            /**
             * A [[Container]] chart places its bullets in.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "bulletsContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Container.new(this._root, { interactiveChildren: false, isMeasured: false, position: "absolute", width: p100, height: p100 })
            });
        }
    }
    Object.defineProperty(Chart, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Chart"
    });
    Object.defineProperty(Chart, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([Chart.className])
    });

    /**
     * A base class for all series-based charts.
     */
    class SerialChart extends Chart {
        constructor() {
            super(...arguments);
            /**
             * A [[Container]] where chart will store all series.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "seriesContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Container.new(this._root, { width: p100, height: p100, isMeasured: false })
            });
            /**
             * A list of chart's series.
             */
            Object.defineProperty(this, "series", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListAutoDispose()
            });
        }
        _afterNew() {
            super._afterNew();
            this._disposers.push(this.series);
            const children = this.seriesContainer.children;
            this._disposers.push(this.series.events.onAll((change) => {
                if (change.type === "clear") {
                    each$1(change.oldValues, (series) => {
                        this._removeSeries(series);
                    });
                    const colors = this.get("colors");
                    if (colors) {
                        colors.reset();
                    }
                    const patterns = this.get("patterns");
                    if (patterns) {
                        patterns.reset();
                    }
                }
                else if (change.type === "push") {
                    children.moveValue(change.newValue);
                    this._processSeries(change.newValue);
                }
                else if (change.type === "setIndex") {
                    children.setIndex(change.index, change.newValue);
                    this._processSeries(change.newValue);
                }
                else if (change.type === "insertIndex") {
                    children.insertIndex(change.index, change.newValue);
                    this._processSeries(change.newValue);
                }
                else if (change.type === "removeIndex") {
                    this._removeSeries(change.oldValue);
                }
                else if (change.type === "moveIndex") {
                    children.moveValue(change.value, change.newIndex);
                    this._processSeries(change.value);
                }
                else {
                    throw new Error("Unknown IListEvent type");
                }
            }));
        }
        _processSeries(series) {
            series.chart = this;
            series._placeBulletsContainer(this);
        }
        _removeSeries(series) {
            if (!series.isDisposed()) {
                this.seriesContainer.children.removeValue(series);
                series._removeBulletsContainer();
            }
        }
    }
    Object.defineProperty(SerialChart, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SerialChart"
    });
    Object.defineProperty(SerialChart, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Chart.classNames.concat([SerialChart.className])
    });

    /**
     * Draws a tick element (mostly used on axes).
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
     */
    class Tick extends Line {
    }
    Object.defineProperty(Tick, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Tick"
    });
    Object.defineProperty(Tick, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Line.classNames.concat([Tick.className])
    });

    /**
     * A tool that displays button for zoomable targets.
     *
     * @since 5.8.0
     * @important
     */
    class ZoomTools extends Container {
        constructor() {
            super(...arguments);
            /**
             * A [[Button]] for home.
             */
            Object.defineProperty(this, "homeButton", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Button.new(this._root, { width: 35, height: 35, themeTags: ["home"] }))
            });
            /**
             * A [[Button]] for zoom in.
             */
            Object.defineProperty(this, "plusButton", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Button.new(this._root, { width: 35, height: 35, themeTags: ["plus"] }))
            });
            /**
             * A [[Button]] for zoom out.
             */
            Object.defineProperty(this, "minusButton", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Button.new(this._root, { width: 35, height: 35, themeTags: ["minus"] }))
            });
            Object.defineProperty(this, "_disposer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_targetDisposer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _afterNew() {
            super._afterNew();
            this.set("position", "absolute");
            this.set("layout", this._root.verticalLayout);
            this.addTag("zoomtools");
            this.plusButton.setAll({
                icon: Graphics.new(this._root, { themeTags: ["icon"] }),
                layout: undefined
            });
            this.minusButton.setAll({
                icon: Graphics.new(this._root, { themeTags: ["icon"] }),
                layout: undefined
            });
            this.homeButton.setAll({
                icon: Graphics.new(this._root, { themeTags: ["icon"] }),
                layout: undefined
            });
        }
        _prepareChildren() {
            super._prepareChildren();
            if (this.isDirty("target")) {
                const target = this.get("target");
                const previous = this._prevSettings.target;
                if (target) {
                    if (target instanceof ZoomableContainer) {
                        this._targetDisposer = this.addDisposer(target.contents.on("scale", (scale) => {
                            if (scale == target.get("minZoomLevel")) {
                                this.minusButton.set("disabled", true);
                            }
                            else {
                                this.minusButton.set("disabled", false);
                            }
                            if (scale == target.get("maxZoomLevel")) {
                                this.plusButton.set("disabled", true);
                            }
                            else {
                                this.plusButton.set("disabled", false);
                            }
                        }));
                        this.root.events.once("frameended", () => {
                            if (target.get("scale") == target.get("minZoomLevel")) {
                                this.minusButton.set("disabled", true);
                            }
                        });
                    }
                    this._disposer = new MultiDisposer([
                        this.plusButton.events.on("click", () => {
                            target.zoomIn();
                        }),
                        this.minusButton.events.on("click", () => {
                            target.zoomOut();
                        }),
                        this.homeButton.events.on("click", () => {
                            target.goHome();
                        })
                    ]);
                }
                if (previous) {
                    if (this._disposer) {
                        this._disposer.dispose();
                    }
                    if (this._targetDisposer) {
                        this._targetDisposer.dispose();
                    }
                }
            }
        }
    }
    Object.defineProperty(ZoomTools, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ZoomTools"
    });
    Object.defineProperty(ZoomTools, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([ZoomTools.className])
    });

    /**
     * Grain pattern.
     *
     * Allows to add grain (noise) effect to your [[Graphics]] objects.
     *
     * Note, grain pattern does not support `fill` and `color` setting.
     * Use `colors` setting to define colors of a grain pixels.
     *
     * Note, rotation setting is not supported by this pattern.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/#Grain_patterns} for more info
     * @since 5.5.0
     */
    class GrainPattern extends Pattern {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "canvas", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: document.createElement("canvas")
            });
            Object.defineProperty(this, "context", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.canvas.getContext("2d")
            });
            Object.defineProperty(this, "_clearGrain", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        _beforeChanged() {
            //document.body.appendChild(this.canvas); // temp
            this.canvas.width = this.get("width", 200);
            this.canvas.height = this.get("height", 200);
            if (this.isDirty("size") || this.isDirty("density") || this.isDirty("minOpacity") || this.isDirty("maxOpacity") || this.isDirty("colors") || this.isDirty("horizontalGap") || this.isDirty("verticalGap")) {
                this._clearGrain = true;
            }
            super._beforeChanged();
        }
        _changed() {
            super._changed();
            if (this._clearGrain) {
                const width = this.get("width", 200);
                const height = this.get("height", 200);
                const patternData = this.context.getImageData(0, 0, width, height);
                const size = Math.max(1, this.get("size", 1));
                const minOpacity = this.get("minOpacity", 0);
                const maxOpacity = this.get("maxOpacity", 0.3);
                const colors = this.get("colors", [this.get("color", Color.fromHex(0x000000))]);
                const cols = width / size;
                const rows = height / size;
                const density = this.get("density", 1);
                const horizontalGap = this.get("horizontalGap", 0) + 1;
                const verticalGap = this.get("verticalGap", 0) + 1;
                for (let r = 0; r < rows; r++) {
                    if (verticalGap > 0) {
                        if (r / verticalGap != Math.round(r / verticalGap)) {
                            continue;
                        }
                    }
                    for (let c = 0; c < cols; c++) {
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        const alpha = (minOpacity + Math.random() * (maxOpacity - minOpacity)) * 255;
                        const rnd = Math.random();
                        if (horizontalGap > 0) {
                            if (c / horizontalGap != Math.round(c / horizontalGap)) {
                                continue;
                            }
                        }
                        if (rnd < density) {
                            this._setRectData(c, r, size, width, patternData.data, color.r, color.g, color.b, alpha);
                        }
                    }
                }
                this.context.putImageData(patternData, 0, 0);
                this._pattern = this.context.createPattern(this.canvas, "repeat");
            }
            this._clearGrain = false;
        }
        _checkDirtyFill() {
            return false;
        }
        _setRectData(col, row, size, width, data, rc, gc, bc, ac) {
            for (var c = col * size; c < col * size + size; c++) {
                for (var r = row * size; r < row * size + size; r++) {
                    var i = (r * width + c) * 4;
                    data[i] = rc;
                    data[i + 1] = gc;
                    data[i + 2] = bc;
                    data[i + 3] = ac;
                }
            }
        }
    }
    Object.defineProperty(GrainPattern, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "GrainPattern"
    });
    Object.defineProperty(GrainPattern, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Pattern.classNames.concat([GrainPattern.className])
    });

    /**
     * Radial gradient.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info
     */
    class RadialGradient extends Gradient {
        /**
         * @ignore
         */
        getFill(target) {
            const bounds = this.getBounds(target);
            let x = 0;
            let y = 0;
            let l = bounds.left || 0;
            let r = bounds.right || 0;
            let t = bounds.top || 0;
            let b = bounds.bottom || 0;
            const width = r - l;
            const height = b - t;
            let radius = target.get("radius");
            if (isNumber(radius)) {
                x = 0;
                y = 0;
            }
            else {
                radius = Math.min(width, height) / 2;
                x = width / 2;
                y = height / 2;
            }
            let ux = this.get("x");
            let uy = this.get("y");
            if (ux != null) {
                x = relativeToValue(ux, width);
            }
            if (uy != null) {
                y = relativeToValue(uy, height);
            }
            const gradient = this._root._renderer.createRadialGradient(x, y, 0, x, y, radius);
            const stops = this.get("stops");
            if (stops) {
                let i = 0;
                each$1(stops, (stop) => {
                    let offset = stop.offset;
                    if (!isNumber(offset)) {
                        offset = i / (stops.length - 1);
                    }
                    let opacity = stop.opacity;
                    if (!isNumber(opacity)) {
                        opacity = 1;
                    }
                    let color = stop.color;
                    if (color) {
                        const lighten = stop.lighten;
                        if (lighten) {
                            color = Color.lighten(color, lighten);
                        }
                        const brighten = stop.brighten;
                        if (brighten) {
                            color = Color.brighten(color, brighten);
                        }
                        gradient.addColorStop(offset, 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + opacity + ')');
                    }
                    i++;
                });
            }
            return gradient;
        }
    }
    Object.defineProperty(RadialGradient, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RadialGradient"
    });
    Object.defineProperty(RadialGradient, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Gradient.classNames.concat([RadialGradient.className])
    });

    /**
     * Circle pattern.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
     */
    class CirclePattern extends Pattern {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("gap")) {
                this._clear = true;
            }
        }
        _draw() {
            super._draw();
            const checkered = this.get("checkered", false);
            const centered = this.get("centered", true);
            const gap = this.get("gap", 0);
            const rotation = this.get("rotation", 0);
            let w = this.get("width", 100);
            let h = this.get("height", 100);
            let radius = this.get("radius", 3);
            let cellW = radius * 2 + gap;
            let cellH = radius * 2 + gap;
            let cols = Math.round(w / cellW);
            let rows = Math.round(h / cellH);
            cellW = w / cols;
            cellH = h / rows;
            if (rotation != 0) {
                // @todo this is probably not right
                this._display.x = cellW * cos(rotation);
                this._display.y = cellH * sin(rotation);
            }
            const color = this.get("color");
            const colorOpacity = this.get("colorOpacity");
            if (color || colorOpacity) {
                this._display.beginFill(color, colorOpacity);
            }
            for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {
                for (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {
                    if (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {
                        let x = c * cellW;
                        let y = r * cellH;
                        if (centered) {
                            x += cellW + gap / 2;
                            y += cellH + gap / 2;
                        }
                        this._display.drawCircle(x - radius, y - radius, radius);
                    }
                }
            }
            if (checkered) {
                w = w / 2 - gap * 2;
                h = h / 2 - gap * 2;
            }
            else {
                w -= gap;
                h -= gap;
            }
            if (color || colorOpacity) {
                this._display.endFill();
            }
        }
    }
    Object.defineProperty(CirclePattern, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CirclePattern"
    });
    Object.defineProperty(CirclePattern, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Pattern.classNames.concat([CirclePattern.className])
    });

    /**
     * Line pattern.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
     */
    class LinePattern extends Pattern {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("gap")) {
                this._clear = true;
            }
        }
        _draw() {
            super._draw();
            const w = this.get("width", 100);
            const h = this.get("height", 100);
            const gap = this.get("gap", 0);
            const strokeWidth = this.get("strokeWidth", 1);
            if (!gap) {
                this._display.moveTo(0, 0);
                this._display.lineTo(w, 0);
            }
            else {
                let step = gap + strokeWidth;
                let count = h / step;
                for (let i = -count; i < count * 2; i++) {
                    const y = Math.round(i * step - step / 2) + 0.5;
                    this._display.moveTo(-w, y);
                    this._display.lineTo(w * 2, y);
                }
            }
            this._display.lineStyle(strokeWidth, this.get("color"), this.get("colorOpacity"));
            let strokeDasharray = this.get("strokeDasharray");
            if (isNumber(strokeDasharray)) {
                if (strokeDasharray < 0.5) {
                    strokeDasharray = [0];
                }
                else {
                    strokeDasharray = [strokeDasharray];
                }
            }
            this._display.setLineDash(strokeDasharray);
            const strokeDashoffset = this.get("strokeDashoffset");
            if (strokeDashoffset) {
                this._display.setLineDashOffset(strokeDashoffset);
            }
            this._display.endStroke();
        }
    }
    Object.defineProperty(LinePattern, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "LinePattern"
    });
    Object.defineProperty(LinePattern, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Pattern.classNames.concat([LinePattern.className])
    });

    /**
     * Rectangle pattern.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
     */
    class RectanglePattern extends Pattern {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("gap")) {
                this._clear = true;
            }
        }
        _draw() {
            super._draw();
            const checkered = this.get("checkered", false);
            const centered = this.get("centered", true);
            const gap = this.get("gap", 0);
            const rotation = this.get("rotation", 0);
            let w = this.get("width", 100);
            let h = this.get("height", 100);
            let rectW = this.get("maxWidth", 5);
            let rectH = this.get("maxHeight", 5);
            const display = this._display;
            let cellW = rectW + gap;
            let cellH = rectH + gap;
            let cols = Math.round(w / cellW);
            let rows = Math.round(h / cellH);
            cellW = w / cols;
            cellH = h / rows;
            if (rotation != 0) {
                // @todo this is probably not right
                display.x = cellW / 2 * cos(rotation);
                display.y = -cellH / 2 * sin(rotation);
            }
            for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {
                for (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {
                    if (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {
                        let x = c * cellW;
                        let y = r * cellH;
                        if (centered) {
                            x += (cellW - rectW) / 2;
                            y += (cellH - rectH) / 2;
                        }
                        display.drawRect(x, y, rectW, rectH);
                    }
                }
            }
            if (checkered) {
                w = w / 2 - gap * 2;
                h = h / 2 - gap * 2;
            }
            else {
                w -= gap;
                h -= gap;
            }
            const color = this.get("color");
            const colorOpacity = this.get("colorOpacity");
            if (color || colorOpacity) {
                // this._display.lineStyle(strokeWidth, stroke, colorOpacity);
                // this._display.endStroke();
                display.beginFill(color, colorOpacity);
                display.endFill();
            }
        }
    }
    Object.defineProperty(RectanglePattern, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RectanglePattern"
    });
    Object.defineProperty(RectanglePattern, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Pattern.classNames.concat([RectanglePattern.className])
    });

    /**
     * A pattern that uses an SVG path.
     *
     * @since 5.2.33
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
     */
    class PathPattern extends Pattern {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("svgPath")) {
                this._clear = true;
            }
        }
        _draw() {
            super._draw();
            // const checkered = this.get("checkered", false);
            // const centered = this.get("centered", true);
            // const gap = this.get("gap", 0);
            // const rotation = this.get("rotation", 0);
            // let w = this.get("width", 100);
            // let h = this.get("height", 100);
            // let rectW = this.get("maxWidth", 5);
            // let rectH = this.get("maxHeight", 5);
            // let cellW = rectW + gap;
            // let cellH = rectH + gap;
            // let cols = Math.round(w / cellW);
            // let rows = Math.round(h / cellH);
            // cellW = w / cols;
            // cellH = h / rows;
            // if (rotation != 0) {
            // 	// @todo this is probably not right
            // 	this._display.x = cellW / 2 * $math.cos(rotation);
            // 	this._display.y = -cellH / 2 * $math.sin(rotation);
            // }
            // for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {
            // 	for (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {
            // 		if (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {
            // 			let x = c * cellW;
            // 			let y = r * cellH;
            // 			if (centered) {
            // 				x += (cellW - rectW) / 2;
            // 				y += (cellH - rectH) / 2;
            // 			}
            // 			this._display.drawRect(x, y, rectW, rectH);
            // 		}
            // 	}
            // }
            // if (checkered) {
            // 	w = w / 2 - gap * 2;
            // 	h = h / 2 - gap * 2;
            // }
            // else {
            // 	w -= gap;
            // 	h -= gap;
            // }
            const svgPath = this.get("svgPath");
            if (svgPath != null) {
                this._display.svgPath(svgPath);
            }
            const color = this.get("color");
            const colorOpacity = this.get("colorOpacity");
            if (color || colorOpacity) {
                // this._display.lineStyle(strokeWidth, stroke, colorOpacity);
                // this._display.endStroke();
                this._display.beginFill(color, colorOpacity);
                this._display.endFill();
            }
        }
    }
    Object.defineProperty(PathPattern, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PathPattern"
    });
    Object.defineProperty(PathPattern, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Pattern.classNames.concat([PathPattern.className])
    });

    /**
     * An object which holds list of [[Pattern]] objects and can serve them up in
     * an interative way.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/#Pattern_sets} for more info
     * @since 5.10.0
     */
    class PatternSet extends Entity {
        _afterNew() {
            // Applying themes because pattern set will not have parent
            super._afterNewApplyThemes();
            if (this.get("patterns", []).length === 0) {
                const color = this.get("color", this.root.interfaceColors.get("stroke"));
                this.set("patterns", [
                    this.getLinePattern({
                        width: 1000,
                        height: 1000,
                        rotation: 45,
                        strokeWidth: 1,
                        //gap: 6,
                        color: color
                    }),
                    this.getRectanglePattern({
                        width: 10,
                        height: 10,
                        rotation: 0,
                        maxWidth: 4,
                        maxHeight: 4,
                        color: color
                    }),
                    this.getLinePattern({
                        width: 1000,
                        height: 1000,
                        rotation: -45,
                        strokeWidth: 1,
                        gap: 6,
                        color: color
                    }),
                    this.getCirclePattern({
                        width: 11,
                        height: 11,
                        radius: 2,
                        color: color
                    }),
                    this.getLinePattern({
                        width: 6,
                        height: 6,
                        rotation: 90,
                        strokeWidth: 1,
                        color: color
                    }),
                    this.getRectanglePattern({
                        width: 14,
                        height: 14,
                        rotation: 45,
                        gap: 4,
                        maxWidth: 6,
                        maxHeight: 6,
                        checkered: true,
                        color: color
                    }),
                    this.getLinePattern({
                        width: 6,
                        height: 6,
                        rotation: 0,
                        strokeWidth: 1,
                        color: color
                    }),
                    this.getRectanglePattern({
                        width: 15,
                        height: 15,
                        rotation: 0,
                        gap: 5,
                        maxWidth: 5,
                        maxHeight: 5,
                        checkered: true,
                        color: color
                    }),
                    this.getLinePattern({
                        width: 1000,
                        height: 1000,
                        rotation: 45,
                        strokeWidth: 2,
                        gap: 3,
                        strokeDasharray: [4, 2],
                        color: color
                    }),
                    this.getCirclePattern({
                        width: 20,
                        height: 20,
                        radius: 3,
                        gap: 4,
                        checkered: true,
                        color: color
                    }),
                    this.getLinePattern({
                        width: 1000,
                        height: 1000,
                        rotation: -45,
                        strokeWidth: 2,
                        gap: 3,
                        strokeDasharray: [4, 2],
                        color: color
                    }),
                    this.getRectanglePattern({
                        width: 10,
                        height: 10,
                        rotation: 0,
                        gap: 1,
                        maxWidth: 9,
                        maxHeight: 9,
                        color: color
                    }),
                    this.getLinePattern({
                        width: 1000,
                        height: 1000,
                        rotation: -45,
                        strokeWidth: 2,
                        gap: 1,
                        color: color
                    }),
                    this.getLinePattern({
                        width: 1000,
                        height: 1000,
                        rotation: 45,
                        strokeWidth: 2,
                        gap: 1,
                        color: color
                    }),
                    this.getLinePattern({
                        width: 1000,
                        height: 1000,
                        rotation: 0,
                        strokeWidth: 3,
                        gap: 1,
                        color: color
                    }),
                    this.getLinePattern({
                        width: 1000,
                        height: 1000,
                        rotation: 90,
                        strokeWidth: 3,
                        gap: 1,
                        color: color
                    }),
                ]);
            }
            this._dirty["patterns"] = false;
        }
        _beforeChanged() {
            if (this.isDirty("patterns")) {
                this.reset();
            }
        }
        /**
         * Returns a [[Pattern]] at specific index.
         *
         * @param   index  Index
         * @return         Color
         */
        getIndex(index) {
            const patterns = this.get("patterns", []);
            if ((index < patterns.length) && patterns[index] !== null) {
                return patterns[index];
            }
            if (index > (patterns.length - 1)) {
                const adjustedIndex = index - Math.floor(index * (index / patterns.length));
                return patterns[adjustedIndex];
            }
            return patterns[index];
        }
        /**
         * Returns next [[Color]] in the list.
         *
         * If the list is out of colors, new ones are generated dynamically.
         */
        next() {
            let currentStep = this.getPrivate("currentStep", this.get("startIndex", 0));
            this.setPrivate("currentStep", currentStep + this.get("step", 1));
            return this.getIndex(currentStep);
        }
        /**
         * Resets counter to the start of the list, so the next call for `next()` will
         * return the first pattern.
         */
        reset() {
            this.setPrivate("currentStep", this.get("startIndex", 0));
        }
        /**
         * Returns a [[LinePattern].
         *
         * @param   settings  Pattern settings
         * @return            Pattern object
         */
        getLinePattern(settings) {
            let pattern = LinePattern.new(this.root, settings);
            return pattern;
        }
        /**
         * Returns a [[RectanglePattern].
         *
         * @param   settings  Pattern settings
         * @return            Pattern object
         */
        getRectanglePattern(settings) {
            let pattern = RectanglePattern.new(this.root, settings);
            return pattern;
        }
        /**
         * Returns a [[CirclePattern].
         *
         * @param   settings  Pattern settings
         * @return            Pattern object
         */
        getCirclePattern(settings) {
            let pattern = CirclePattern.new(this.root, settings);
            return pattern;
        }
    }
    Object.defineProperty(PatternSet, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "PatternSet"
    });
    Object.defineProperty(PatternSet, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([PatternSet.className])
    });

    /**
     * An object which holds list of colors and can generate new ones.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info
     */
    class ColorSet extends Entity {
        //protected _currentPass: number = 0;
        _afterNew() {
            // Applying themes because color set will not have parent
            super._afterNewApplyThemes();
            this._dirty["colors"] = false;
        }
        _beforeChanged() {
            if (this.isDirty("colors")) {
                this.reset();
            }
        }
        /**
         * @ignore
         */
        generateColors() {
            this.setPrivate("currentPass", this.getPrivate("currentPass", 0) + 1);
            const pass = this.getPrivate("currentPass");
            const colors = this.get("colors", [this.get("baseColor", Color.fromHex(0xff0000))]);
            if (!this.getPrivate("numColors")) {
                this.setPrivate("numColors", colors.length);
            }
            //const len = colors.length;
            const len = this.getPrivate("numColors");
            //const start = len - this.getPrivate("numColors")!;
            const start = 0;
            const passOptions = this.get("passOptions");
            const reuse = this.get("reuse");
            for (let i = start; i < len; i++) {
                if (reuse) {
                    colors.push(colors[i]);
                }
                else {
                    const hsl = colors[i].toHSL();
                    let h = hsl.h + (passOptions.hue || 0) * pass;
                    while (h > 1)
                        h -= 1;
                    let s = hsl.s + (passOptions.saturation || 0) * pass;
                    //if (s > 1) s -= Math.floor(s);
                    if (s > 1)
                        s = 1;
                    if (s < 0)
                        s = 0;
                    let l = hsl.l + (passOptions.lightness || 0) * pass;
                    //if (l > 1) l -= Math.floor(l);
                    while (l > 1)
                        l -= 1;
                    colors.push(Color.fromHSL(h, s, l));
                }
            }
        }
        /**
         * Returns a [[Color]] at specific index.
         *
         * If there's no color at this index, a new color is generated.
         *
         * @param   index  Index
         * @return         Color
         */
        getIndex(index) {
            const colors = this.get("colors", []);
            const saturation = this.get("saturation");
            if (index >= colors.length) {
                this.generateColors();
                return this.getIndex(index);
            }
            return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];
        }
        /**
         * Returns next [[Color]] in the list.
         *
         * If the list is out of colors, new ones are generated dynamically.
         */
        next() {
            let currentStep = this.getPrivate("currentStep", this.get("startIndex", 0));
            this.setPrivate("currentStep", currentStep + this.get("step", 1));
            return this.getIndex(currentStep);
        }
        /**
         * Resets counter to the start of the list, so the next call for `next()` will
         * return the first color.
         */
        reset() {
            this.setPrivate("currentStep", this.get("startIndex", 0));
            this.setPrivate("currentPass", 0);
        }
    }
    Object.defineProperty(ColorSet, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ColorSet"
    });
    Object.defineProperty(ColorSet, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([ColorSet.className])
    });

    /**
     * Tool to parse JSON string into structured data.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info
     * @important
     */
    class JSONParser {
        /**
         * Parses JSON string.
         *
         * @param   input    JSON
         * @param   options  Options
         * @return           Data
         */
        static parse(input, options) {
            options = this._applyDefaults(options);
            try {
                if (isString(input)) {
                    let data = JSON.parse(input);
                    if (options.reverse && isArray(data)) {
                        data.reverse();
                    }
                    return data;
                }
                else if (isArray(input) || isObject(input)) {
                    return input;
                }
                else {
                    throw ("Unable to parse JSON data");
                }
            }
            catch (e) {
                return undefined;
            }
        }
        static _applyDefaults(options) {
            const normalized = {};
            const defaults = {
                reverse: false
            };
            if (!options) {
                options = {};
            }
            each(defaults, (key, val) => {
                normalized[key] = options[key] || val;
            });
            return normalized;
        }
    }
    /**
     * Tool to parse JSON string into structured data.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info
     * @important
     */
    class CSVParser {
        /**
         * Parses CSV string.
         *
         * @param   input    CSV
         * @param   options  Options
         * @return           Data
         */
        static parse(input, options) {
            options = this._applyDefaults(options);
            // Get CSV data as array
            let data = this.CSVToArray(input, options.delimiter);
            // Init resuling array
            let res = [], cols = [], col, i;
            // Skip rows
            for (i = 0; i < options.skipRows; i++) {
                data.shift();
            }
            // First row holds column names?
            if (options.useColumnNames) {
                cols = data.shift();
                // Normalize column names
                for (let x = 0; x < cols.length; x++) {
                    // trim
                    col = cols[x] != null ? cols[x].replace(/^\s+|\s+$/gm, "") : "";
                    // Check for empty
                    if ("" === col) {
                        col = "col" + x;
                    }
                    cols[x] = col;
                }
            }
            // Iterate through the result set
            let row;
            while (true) {
                row = options.reverse ? data.pop() : data.shift();
                if (!row) {
                    break;
                }
                if (options.skipEmpty && row.length === 1 && row[0] === "") {
                    continue;
                }
                let dataPoint = {};
                for (i = 0; i < row.length; i++) {
                    col = undefined === cols[i] ? "col" + i : cols[i];
                    dataPoint[col] = row[i];
                }
                res.push(dataPoint);
            }
            return res;
        }
        /**
         * @ignore
         */
        static CSVToArray(data, delimiter) {
            // Check to see if the delimiter is defined. If not,
            // then default to comma.
            delimiter = (delimiter || ',');
            // Create a regular expression to parse the CSV values.
            let objPattern = new RegExp((
            // Delimiters.
            "(\\" + delimiter + "|\\r?\\n|\\r|^)" +
                // Quoted fields.
                "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
                // Standard fields.
                "([^\"\\" + delimiter + "\\r\\n]*))"), "gi");
            // Create an array to hold our data. Give the array
            // a default empty first row.
            let arrData = [
                []
            ];
            // Create an array to hold our individual pattern
            // matching groups.
            let arrMatches = null;
            // Keep looping over the regular expression matches
            // until we can no longer find a match.
            while (true) {
                arrMatches = objPattern.exec(data);
                if (!arrMatches) {
                    break;
                }
                // Get the delimiter that was found.
                let strMatchedDelimiter = arrMatches[1];
                // Check to see if the given delimiter has a length
                // (is not the start of string) and if it matches
                // field delimiter. If id does not, then we know
                // that this delimiter is a row delimiter.
                if (strMatchedDelimiter.length &&
                    (strMatchedDelimiter !== delimiter)) {
                    // Since we have reached a new row of data,
                    // add an empty row to our data array.
                    arrData.push([]);
                }
                // Now that we have our delimiter out of the way,
                // let's check to see which kind of value we
                // captured (quoted or unquoted).
                let strMatchedValue;
                if (arrMatches[2]) {
                    // We found a quoted value. When we capture
                    // this value, unescape any double quotes.
                    strMatchedValue = arrMatches[2].replace(new RegExp("\"\"", "g"), "\"");
                }
                else {
                    // We found a non-quoted value.
                    strMatchedValue = arrMatches[3];
                }
                // Now that we have our value string, let's add
                // it to the data array.
                arrData[arrData.length - 1].push(strMatchedValue);
            }
            // Return the parsed data.
            return (arrData);
        }
        static _applyDefaults(options) {
            const normalized = {};
            const defaults = {
                delimiter: ",",
                reverse: false,
                skipRows: 0,
                skipEmpty: true,
                useColumnNames: false
            };
            if (!options) {
                options = {};
            }
            each(defaults, (key, val) => {
                normalized[key] = options[key] || val;
            });
            return normalized;
        }
    }

    /**
     * A tool that can process the data before it is being used in charts.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Pre_processing_data} for more info
     * @important
     */
    class DataProcessor extends Entity {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_checkDates", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_checkNumbers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_checkColors", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_checkEmpty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_checkDeep", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        _afterNew() {
            super._afterNew();
            this._checkFeatures();
            this.on("dateFields", () => this._checkFeatures());
            this.on("dateFormat", () => this._checkFeatures());
            this.on("numericFields", () => this._checkFeatures());
            this.on("colorFields", () => this._checkFeatures());
            this.on("emptyAs", () => this._checkFeatures());
        }
        _checkFeatures() {
            if (this.isDirty("dateFields") || this.isDirty("dateFormat")) {
                this._checkDates = this.get("dateFields") && (this.get("dateFields").length > 0);
            }
            if (this.isDirty("numericFields")) {
                this._checkNumbers = this.get("numericFields") && (this.get("numericFields").length > 0);
            }
            if (this.isDirty("colorFields")) {
                this._checkColors = this.get("colorFields") && (this.get("colorFields").length > 0);
            }
            if (this.isDirty("emptyAs")) {
                this._checkEmpty = this.get("emptyAs") != null;
            }
            this._checkDeepFeatures();
        }
        _checkDeepFeatures() {
            const deepFields = [];
            each$1(["dateFields", "numericFields", "colorFields"], (where) => {
                each$1(this.get(where, []), (field) => {
                    const steps = field.split(".");
                    steps.pop();
                    while (steps.length > 0) {
                        deepFields.push(steps.join("."));
                        steps.pop();
                    }
                });
            });
            this._checkDeep = deepFields.length > 0;
            this.setPrivate("deepFields", deepFields);
        }
        /**
         * Processess entire array of data.
         *
         * NOTE: calling this will modify original array!
         */
        processMany(data) {
            if (isArray(data) && (this._checkDates || this._checkNumbers || this._checkColors || this._checkEmpty)) {
                each$1(data, (row) => {
                    this.processRow(row);
                });
            }
        }
        /**
         * Processes a row (object) of data.
         *
         * NOTE: calling this will modify values of the original object!
         */
        processRow(row, prefix = "") {
            each(row, (key, _value) => {
                const lookupKey = prefix + key;
                if (this._checkEmpty) {
                    row[key] = this._maybeToEmpty(row[key]);
                }
                if (this._checkNumbers) {
                    row[key] = this._maybeToNumber(lookupKey, row[key]);
                }
                if (this._checkDates) {
                    row[key] = this._maybeToDate(lookupKey, row[key]);
                }
                if (this._checkColors) {
                    row[key] = this._maybeToColor(lookupKey, row[key]);
                }
                if (this._checkDeep && this.getPrivate("deepFields", []).indexOf(lookupKey) !== -1 && isObject(row[key])) {
                    this.processRow(row[key], lookupKey + ".");
                }
            });
        }
        _maybeToNumber(field, value) {
            if (this.get("numericFields").indexOf(field) !== -1) {
                return toNumber(value);
            }
            return value;
        }
        _maybeToDate(field, value) {
            if (this.get("dateFields").indexOf(field) !== -1) {
                return this._root.dateFormatter.parse(value, this.get("dateFormat", "")).getTime();
            }
            return value;
        }
        _maybeToEmpty(value) {
            if ((value == null || value == "") && this.get("emptyAs") != null) {
                return this.get("emptyAs");
            }
            return value;
        }
        _maybeToColor(field, value) {
            if (this.get("colorFields").indexOf(field) !== -1) {
                return Color.fromAny(value);
            }
            return value;
        }
    }

    class SpriteResizer extends Container {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "rectangle", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Rectangle.new(this._root, { themeTags: ["rectangle"], fillOpacity: 0, fill: color(0xFFFFFF) }))
            });
            Object.defineProperty(this, "gripL", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._createGrip("left")
            });
            Object.defineProperty(this, "gripR", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._createGrip("right")
            });
            Object.defineProperty(this, "gripT", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._createGrip("top")
            });
            Object.defineProperty(this, "gripB", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this._createGrip("bottom")
            });
            Object.defineProperty(this, "_is", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_ix", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_iw", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_positionDP", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_isHover", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
        }
        _afterNew() {
            super._afterNew();
            this.addTag("resizer");
            this.set("visible", false);
            this.gripL.events.on("dragged", (e) => {
                this._resize(e.target, -1);
            });
            this.gripR.events.on("dragged", (e) => {
                this._resize(e.target, 1);
            });
            this.gripL.events.on("dragstart", (e) => {
                this._resizeStart(e.target);
            });
            this.gripR.events.on("dragstart", (e) => {
                this._resizeStart(e.target);
            });
            this.gripT.events.on("dragged", (e) => {
                this._rotate(e, 90);
            });
            this.gripB.events.on("dragged", (e) => {
                this._rotate(e, -90);
            });
            this.gripT.events.on("dragstart", (e) => {
                this._resizeStart(e.target);
            });
            this.gripB.events.on("dragstart", (e) => {
                this._resizeStart(e.target);
            });
        }
        _resizeStart(grip) {
            const sprite = this.get("sprite");
            if (sprite) {
                this._is = sprite.get("scale", 1);
                this._ix = grip.x();
                this._iw = this.width() / 2;
            }
        }
        _resize(grip, c) {
            const sprite = this.get("sprite");
            const spriteTemplate = this.get("spriteTemplate");
            if (sprite) {
                const scale = Math.max(0.01, this._is * (1 + c * (grip.x() - this._ix) / this._iw));
                if (spriteTemplate) {
                    spriteTemplate.set("scale", scale);
                }
                else {
                    sprite.set("scale", scale);
                }
                sprite.states.lookup("default").set("scale", scale);
                this._updatePositions();
            }
        }
        _rotate(e, delta) {
            const sprite = this.get("sprite");
            const spriteTemplate = this.get("spriteTemplate");
            if (sprite) {
                const parent = this.parent;
                if (parent) {
                    const rotationStep = this.get("rotationStep", 10);
                    let angle = Math.round(((getAngle({ x: this.x(), y: this.y() }, parent.toLocal(e.point)) + delta) / rotationStep)) * rotationStep;
                    if (spriteTemplate) {
                        spriteTemplate.set("rotation", angle);
                    }
                    else {
                        sprite.set("rotation", angle);
                    }
                    sprite.states.lookup("default").set("rotation", angle);
                    this._updatePositions();
                }
            }
        }
        _createGrip(themeTag) {
            const container = this.children.push(Container.new(this._root, {
                themeTags: ["grip", themeTag],
                setStateOnChildren: true,
                draggable: true
            }));
            container.children.push(RoundedRectangle.new(this._root, {
                themeTags: ["outline"],
                centerX: p50,
                centerY: p50
            }));
            container.children.push(RoundedRectangle.new(this._root, {
                centerX: p50,
                centerY: p50
            }));
            return container;
        }
        _updateChildren() {
            super._updateChildren();
            if (this.isDirty("sprite")) {
                const sprite = this.get("sprite");
                if (sprite) {
                    this.show(0);
                    this.setPrivate("visible", true);
                    this._updatePositions();
                    const parent = sprite.parent;
                    if (parent) {
                        parent.children.moveValue(this, 0);
                    }
                    this._positionDP = sprite.events.on("positionchanged", () => {
                        this._updatePositions();
                    });
                    this._positionDP = sprite.events.on("boundschanged", () => {
                        this._updatePositions();
                    });
                }
                else {
                    this.hide(0);
                    this.setPrivate("visible", false);
                    if (this._positionDP) {
                        this._positionDP.dispose();
                    }
                }
            }
            if (this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation")) {
                this._updatePositions();
            }
        }
        _updatePositions() {
            const sprite = this.get("sprite");
            if (sprite) {
                let bounds = sprite.localBounds();
                let scale = sprite.get("scale", 1);
                let d = 20;
                let w = (bounds.right - bounds.left) * scale + d;
                let h = (bounds.bottom - bounds.top) * scale + d;
                let a = sprite.get("rotation", 0);
                const rectangle = this.rectangle;
                let cx = sprite.get("centerX", p50);
                let cy = sprite.get("centerY", p50);
                let cxr = 0;
                if (cx instanceof Percent) {
                    cxr = cx.value;
                }
                let cyr = 0;
                if (cy instanceof Percent) {
                    cyr = cy.value;
                }
                rectangle.setAll({ centerX: cx, centerY: cy, width: w, height: h });
                this.setAll({ x: sprite.x() + d * (cxr - 0.5) * cos(a) - d * (cyr - 0.5) * sin(a), y: sprite.y() + d * (cyr - 0.5) * cos(a) + d * (cxr - 0.5) * sin(a), width: w, height: h, rotation: a });
                this.gripT.setAll({ x: (0.5 - cxr) * w, y: -cyr * h });
                this.gripB.setAll({ x: (0.5 - cxr) * w, y: (1 - cyr) * h });
                this.gripL.setAll({ x: -cxr * w, y: (0.5 - cyr) * h });
                this.gripR.setAll({ x: (1 - cxr) * w, y: (0.5 - cyr) * h });
                this.rectangle.setAll({ width: w, height: h });
            }
        }
    }
    Object.defineProperty(SpriteResizer, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SpriteResizer"
    });
    Object.defineProperty(SpriteResizer, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([SpriteResizer.className])
    });

    /**
     * A collection of network-related functions
     */
    /**
     * Loads an external file via its URL.
     *
     * Please note that this is an asynchronous function.
     *
     * It will not return the result, but rather a `Promise`.
     *
     * You can use the `await` notion, or `then()`.
     *
     * ```TypeScript
     * // Using await
     * let response = await Net.load( "http://www.my.com/data.json" );
     * console.log( response.response );
     *
     * // Using then()
     * Net.load( "http://www.my.com/data.json" ).then( ( response ) => {
     *   console.log( response.response );
     * } );
     * ```
     * ```JavaScript
     * // Using then()
     * Net.load( "http://www.my.com/data.json" ).then( function( response ) {
     *   console.log( response.response );
     * } );
     * ```
     *
     * @async
     * @see {@link https://www.amcharts.com/docs/v5/concepts/data/net-load-utility/} for more info
     * @param url      URL for the file to load
     * @param target   A target element that is requesting the net load
     * @param options  Request options
     * @return Result (Promise)
     */
    function load(url, target, options) {
        return new Promise((success, error) => {
            // Is return type Blob?
            let isBlob = options != null && options.responseType == "blob";
            // Create request and set up handlers
            let xhr = new XMLHttpRequest();
            xhr.onload = () => {
                if (xhr.status === 200) {
                    let response;
                    let blob;
                    if (isBlob) {
                        blob = xhr.response;
                        readBlob(blob).then((response) => {
                            let output = {
                                xhr: xhr,
                                error: false,
                                response: response,
                                blob: blob,
                                type: xhr.getResponseHeader("Content-Type"),
                                target: target
                            };
                            success(output);
                        });
                        return;
                    }
                    else {
                        response = xhr.responseText || xhr.response;
                    }
                    let output = {
                        xhr: xhr,
                        error: false,
                        response: response,
                        blob: blob,
                        type: xhr.getResponseHeader("Content-Type"),
                        target: target
                    };
                    success(output);
                }
                else {
                    error({
                        xhr: xhr,
                        error: true,
                        type: xhr.getResponseHeader("Content-Type"),
                        target: target
                    });
                }
            };
            xhr.onerror = () => {
                error({
                    xhr: xhr,
                    error: true,
                    type: xhr.getResponseHeader("Content-Type"),
                    target: target
                });
            };
            // Open request
            xhr.open("GET", url, true);
            if (options && options.withCredentials) {
                xhr.withCredentials = true;
            }
            // Process options
            if (options != null) {
                if (options.requestHeaders != null) {
                    for (let i = 0; i < options.requestHeaders.length; i++) {
                        let header = options.requestHeaders[i];
                        xhr.setRequestHeader(header.key, header.value);
                    }
                }
                if (options.responseType != null) {
                    xhr.responseType = options.responseType;
                }
            }
            // Send request
            xhr.send();
        });
    }
    /**
     * Returns textual representation of a Blob object.
     *
     * @param   blob  Target blob
     * @return        Text promise
     */
    function readBlob(blob) {
        return new Promise((success, error) => {
            const reader = new FileReader();
            reader.onload = _event => {
                success(reader.result);
            };
            reader.onerror = (e) => {
                error(e);
            };
            reader.readAsText(blob);
        });
    }

    var Net = /*#__PURE__*/Object.freeze({
        __proto__: null,
        load: load,
        readBlob: readBlob
    });

    var am5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ArrayDisposer: ArrayDisposer,
        get BlendMode () { return BlendMode; },
        Bullet: Bullet,
        Button: Button,
        CSVParser: CSVParser,
        CanvasLayer: CanvasLayer,
        CanvasRenderer: CanvasRenderer,
        Chart: Chart,
        Circle: Circle,
        CirclePattern: CirclePattern,
        Color: Color,
        ColorSet: ColorSet,
        Component: Component,
        Container: Container,
        CounterDisposer: CounterDisposer,
        DataItem: DataItem,
        DataProcessor: DataProcessor,
        DateFormatter: DateFormatter,
        Disposer: Disposer,
        DurationFormatter: DurationFormatter,
        EditableLabel: EditableLabel,
        Ellipse: Ellipse,
        Entity: Entity,
        Gradient: Gradient,
        GrainPattern: GrainPattern,
        Graphics: Graphics,
        GridLayout: GridLayout,
        HeatLegend: HeatLegend,
        HorizontalLayout: HorizontalLayout,
        InterfaceColors: InterfaceColors,
        JSONParser: JSONParser,
        JsonData: JsonData,
        Label: Label,
        Layout: Layout,
        Legend: Legend,
        Line: Line,
        LinePattern: LinePattern,
        LinearGradient: LinearGradient,
        ListData: ListData,
        ListTemplate: ListTemplate,
        Modal: Modal,
        MultiDisposer: MultiDisposer,
        MutableValueDisposer: MutableValueDisposer,
        NumberFormatter: NumberFormatter,
        PathPattern: PathPattern,
        Pattern: Pattern,
        PatternSet: PatternSet,
        Percent: Percent,
        Picture: Picture,
        PicturePattern: PicturePattern,
        PointedRectangle: PointedRectangle,
        Polygon: Polygon,
        RadialGradient: RadialGradient,
        RadialLabel: RadialLabel,
        RadialText: RadialText,
        Rectangle: Rectangle,
        RectanglePattern: RectanglePattern,
        Root: Root,
        RoundedRectangle: RoundedRectangle,
        Scrollbar: Scrollbar,
        SerialChart: SerialChart,
        Series: Series,
        Slice: Slice,
        Slider: Slider,
        Sprite: Sprite,
        SpriteResizer: SpriteResizer,
        Star: Star,
        Template: Template,
        Text: Text,
        TextFormatter: TextFormatter,
        Theme: Theme,
        Tick: Tick,
        Timezone: Timezone,
        Tooltip: Tooltip,
        Triangle: Triangle,
        VerticalLayout: VerticalLayout,
        ZoomTools: ZoomTools,
        ZoomableContainer: ZoomableContainer,
        addLicense: addLicense,
        array: Array$1,
        color: color,
        disposeAllRootElements: disposeAllRootElements,
        ease: Ease,
        getRootById: getRootById,
        math: Math$1,
        net: Net,
        object: Object$1,
        p0: p0,
        p100: p100,
        p50: p50,
        percent: percent,
        ready: ready,
        registry: registry,
        time: Time,
        type: Type,
        utils: Utils
    });

    /**
     * @ignore
     */
    class XYChartDefaultTheme extends Theme {
        setupDefaultRules() {
            super.setupDefaultRules();
            const ic = this._root.interfaceColors;
            const language = this._root.language;
            const r = this.rule.bind(this);
            /**
             * ========================================================================
             * charts/xy
             * ========================================================================
             */
            r("XYChart").setAll({
                colors: ColorSet.new(this._root, {}),
                paddingLeft: 20,
                paddingRight: 20,
                paddingTop: 16,
                paddingBottom: 16,
                panX: false,
                panY: false,
                wheelStep: 0.25,
                arrangeTooltips: true,
                pinchZoomX: false,
                pinchZoomY: false
            });
            r("XYSeries").setAll({
                legendLabelText: "{name}"
            });
            r("Rectangle", ["plotbackground", "xy", "background"]).setAll({
                fill: Color.fromHex(0x000000),
                fillOpacity: 0
            });
            /**
             * ------------------------------------------------------------------------
             * charts/xy: XYChartScrollbar
             * ------------------------------------------------------------------------
             */
            r("XYChart", ["scrollbar", "chart"]).setAll({
                paddingBottom: 0,
                paddingLeft: 0,
                paddingTop: 0,
                paddingRight: 0,
                colors: ColorSet.new(this._root, {
                    saturation: 0
                })
            });
            {
                const rule = r("Graphics", ["scrollbar", "overlay"]);
                rule.setAll({
                    fillOpacity: 0.5
                });
                setColor(rule, "fill", ic, "background");
            }
            // Class: RoundedRectangle
            r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({
                cornerRadiusTR: 0,
                cornerRadiusTL: 0,
                cornerRadiusBR: 0,
                cornerRadiusBL: 0,
                fillOpacity: 0,
                focusable: true
            });
            r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", { fillOpacity: 0.4 });
            r("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({
                cornerRadiusTL: 0,
                cornerRadiusBL: 0,
                cornerRadiusTR: 0,
                cornerRadiusBR: 0
            });
            r("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({
                cornerRadiusBL: 40,
                cornerRadiusBR: 40,
                cornerRadiusTL: 40,
                cornerRadiusTR: 40
            });
            r("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({
                strokeOpacity: 0,
                inside: true
            });
            r("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({
                strokeOpacity: 0,
                inside: true,
                minGridDistance: 5
            });
            r("AxisLabel", ["xy", "scrollbar", "x"]).setAll({
                opacity: 0.5,
                centerY: p100,
                minPosition: 0.01,
                maxPosition: 0.99,
                fontSize: "0.8em"
            });
            r("AxisLabel", ["category"]).setAll({
                text: "{category}",
                populateText: true
            });
            r("AxisLabel", ["x"]).setAll({
                centerY: 0
            });
            r("AxisLabel", ["x", "inside"]).setAll({
                centerY: p100
            });
            r("AxisLabel", ["x", "inside", "opposite"]).setAll({
                centerY: 0
            });
            r("AxisLabel", ["x", "opposite"]).setAll({
                centerY: p100
            });
            r("AxisLabel", ["y"]).setAll({
                centerX: p100
            });
            r("AxisLabel", ["y", "inside"]).setAll({
                centerX: 0
            });
            r("AxisLabel", ["y", "inside", "opposite"]).setAll({
                centerX: p100
            });
            r("AxisLabel", ["y", "opposite"]).setAll({
                centerX: 0
            });
            r("AxisLabel", ["minor"]).setAll({
                fontSize: "0.6em"
            });
            r("AxisLabel", ["xy", "scrollbar", "y"]).setAll({
                visible: false
            });
            // Class: Grid
            r("Grid", ["xy", "scrollbar", "y"]).setAll({
                visible: false
            });
            // Class: Grid
            r("Grid", ["xy", "scrollbar", "x"]).setAll({
                opacity: 0.5
            });
            /**
             * ------------------------------------------------------------------------
             * charts/xy: Cursor
             * ------------------------------------------------------------------------
             */
            r("XYCursor").setAll({
                behavior: "none",
                layer: 30,
                exportable: false,
                snapToSeriesBy: "xy",
                moveThreshold: 1
            });
            {
                const rule = r("Grid", ["cursor", "x"]);
                rule.setAll({
                    forceInactive: true,
                    strokeOpacity: 0.8,
                    strokeDasharray: [2, 2],
                    role: "slider",
                    ariaLabel: language.translate("Use left and right arrows to move selection")
                });
                setColor(rule, "stroke", ic, "alternativeBackground");
            }
            {
                const rule = r("Grid", ["cursor", "y"]);
                rule.setAll({
                    forceInactive: true,
                    strokeOpacity: 0.8,
                    strokeDasharray: [2, 2],
                    role: "slider",
                    ariaLabel: language.translate("Use up and down arrows to move selection")
                });
                setColor(rule, "stroke", ic, "alternativeBackground");
            }
            {
                const rule = r("Graphics", ["cursor", "selection"]);
                rule.setAll({
                    fillOpacity: 0.15,
                });
                setColor(rule, "fill", ic, "alternativeBackground");
            }
            /**
             * ------------------------------------------------------------------------
             * charts/xy: Axes
             * ------------------------------------------------------------------------
             */
            r("Axis").setAll({
                start: 0,
                end: 1,
                minZoomCount: 1,
                maxZoomCount: Infinity,
                maxZoomFactor: 1000,
                maxDeviation: 0.1,
                snapTooltip: true,
                tooltipLocation: 0.5,
                panX: true,
                panY: true,
                zoomX: true,
                zoomY: true,
                fixAxisSize: true
            });
            r("AxisLabel").setAll({
                location: 0.5,
                multiLocation: 0,
                centerX: p50,
                centerY: p50,
                paddingTop: 3,
                paddingBottom: 3,
                paddingLeft: 5,
                paddingRight: 5
            });
            // The following is deprecated following text measuring updates in 5.0.5
            // r("AxisLabel", ["y"]).setAll({
            // 	textAlign: "right"
            // });
            // r("AxisLabel", ["y", "opposite"]).setAll({
            // 	textAlign: "left"
            // });
            r("Container", ["axis", "header"]).setAll({
                layer: 30
            });
            r("Rectangle", ["axis", "header", "background"]).setAll({
                crisp: true
            });
            {
                const rule = r("AxisRenderer");
                rule.setAll({
                    crisp: true,
                    strokeOpacity: 0
                });
                setColor(rule, "stroke", ic, "grid");
            }
            r("AxisRendererX").setAll({
                minGridDistance: 120,
                opposite: false,
                inversed: false,
                cellStartLocation: 0,
                cellEndLocation: 1,
                width: p100
            });
            r("AxisRendererY").setAll({
                minGridDistance: 40,
                opposite: false,
                inversed: false,
                cellStartLocation: 0,
                cellEndLocation: 1,
                height: p100
            });
            {
                const rule = r("Rectangle", ["axis", "thumb"]);
                rule.setAll({
                    fillOpacity: 0
                });
                setColor(rule, "fill", ic, "alternativeBackground");
                rule.states.create("hover", { fillOpacity: 0.1 });
            }
            r("Rectangle", ["axis", "thumb", "x"]).setAll({
                cursorOverStyle: "ew-resize"
            });
            r("Rectangle", ["axis", "thumb", "y"]).setAll({
                cursorOverStyle: "ns-resize"
            });
            {
                const rule = r("Grid");
                rule.setAll({
                    location: 0,
                    strokeOpacity: 0.15,
                    crisp: true
                });
                setColor(rule, "stroke", ic, "grid");
            }
            {
                const rule = r("Grid", ["minor"]);
                rule.setAll({
                    location: 0,
                    strokeOpacity: 0.07,
                    crisp: true
                });
                setColor(rule, "stroke", ic, "grid");
            }
            r("Grid", ["base"]).setAll({
                strokeOpacity: 0.3
            });
            {
                const rule = r("Graphics", ["axis", "fill"]);
                rule.setAll({
                    visible: false,
                    isMeasured: false,
                    position: "absolute",
                    fillOpacity: 0.05,
                });
                setColor(rule, "fill", ic, "alternativeBackground");
            }
            r("Graphics", ["axis", "fill", "range"]).setAll({
                isMeasured: true
            });
            // hides all elements of series axis range
            r("Graphics", ["series", "fill", "range"]).setAll({
                visible: false,
                isMeasured: true
            });
            r("Grid", ["series", "range"]).setAll({
                visible: false
            });
            r("AxisTick", ["series", "range"]).setAll({
                visible: false
            });
            r("AxisLabel", ["series", "range"]).setAll({
                visible: false
            });
            {
                const rule = r("AxisTick");
                rule.setAll({
                    location: 0.5,
                    multiLocation: 0,
                    strokeOpacity: 1,
                    isMeasured: false,
                    position: "absolute",
                    visible: false
                });
                setColor(rule, "stroke", ic, "grid");
            }
            r("CategoryAxis").setAll({
                startLocation: 0,
                endLocation: 1,
                fillRule: (dataItem, index) => {
                    const axisFill = dataItem.get("axisFill");
                    if (axisFill) {
                        if (!isNumber(index) || index % 2 == 0) {
                            axisFill.setPrivate("visible", true);
                        }
                        else {
                            axisFill.setPrivate("visible", false);
                        }
                    }
                }
            });
            const gridIntervals = [
                { timeUnit: "millisecond", count: 1 },
                { timeUnit: "millisecond", count: 5 },
                { timeUnit: "millisecond", count: 10 },
                { timeUnit: "millisecond", count: 50 },
                { timeUnit: "millisecond", count: 100 },
                { timeUnit: "millisecond", count: 500 },
                { timeUnit: "second", count: 1 },
                { timeUnit: "second", count: 5 },
                { timeUnit: "second", count: 10 },
                { timeUnit: "second", count: 30 },
                { timeUnit: "minute", count: 1 },
                { timeUnit: "minute", count: 5 },
                { timeUnit: "minute", count: 10 },
                { timeUnit: "minute", count: 15 },
                { timeUnit: "minute", count: 30 },
                { timeUnit: "hour", count: 1 },
                { timeUnit: "hour", count: 3 },
                { timeUnit: "hour", count: 6 },
                { timeUnit: "hour", count: 12 },
                { timeUnit: "day", count: 1 },
                { timeUnit: "day", count: 2 },
                { timeUnit: "day", count: 3 },
                { timeUnit: "day", count: 4 },
                { timeUnit: "day", count: 5 },
                { timeUnit: "week", count: 1 },
                { timeUnit: "month", count: 1 },
                { timeUnit: "month", count: 2 },
                { timeUnit: "month", count: 3 },
                { timeUnit: "month", count: 6 },
                { timeUnit: "year", count: 1 },
                { timeUnit: "year", count: 2 },
                { timeUnit: "year", count: 5 },
                { timeUnit: "year", count: 10 },
                { timeUnit: "year", count: 50 },
                { timeUnit: "year", count: 100 },
                { timeUnit: "year", count: 200 },
                { timeUnit: "year", count: 500 },
                { timeUnit: "year", count: 1000 },
                { timeUnit: "year", count: 2000 },
                { timeUnit: "year", count: 5000 },
                { timeUnit: "year", count: 10000 },
                { timeUnit: "year", count: 100000 }
            ];
            const dateFormats = {
                "millisecond": language.translate("_date_millisecond"),
                "second": language.translate("_date_second"),
                "minute": language.translate("_date_minute"),
                "hour": language.translate("_date_hour"),
                "day": language.translate("_date_day"),
                "week": language.translate("_date_day"),
                "month": language.translate("_date_month"),
                "year": language.translate("_date_year")
            };
            const periodChangeDateFormats = {
                "millisecond": language.translate("_date_millisecond"),
                "second": language.translate("_date_second"),
                "minute": language.translate("_date_minute"),
                "hour": language.translate("_date_day"),
                "day": language.translate("_date_day"),
                "week": language.translate("_date_day"),
                "month": language.translate("_date_month") + " " + language.translate("_date_year"),
                "year": language.translate("_date_year")
            };
            const tooltipDateFormats = {
                "millisecond": language.translate("_date_millisecond_full"),
                "second": language.translate("_date_second_full"),
                "minute": language.translate("_date_minute_full"),
                "hour": language.translate("_date_hour_full"),
                "day": language.translate("_date_day_full"),
                "week": language.translate("_date_week_full"),
                "month": language.translate("_date_month_full"),
                "year": language.translate("_date_year")
            };
            r("CategoryDateAxis").setAll({
                markUnitChange: true,
                gridIntervals: copy$2(gridIntervals),
                dateFormats: copy$1(dateFormats),
                periodChangeDateFormats: copy$1(periodChangeDateFormats)
            });
            r("DateAxis").setAll({
                maxZoomFactor: null,
                strictMinMax: true,
                startLocation: 0,
                endLocation: 1,
                markUnitChange: true,
                groupData: false,
                groupCount: 500,
                gridIntervals: copy$2(gridIntervals),
                dateFormats: copy$1(dateFormats),
                periodChangeDateFormats: copy$1(periodChangeDateFormats),
                tooltipDateFormats: tooltipDateFormats,
                groupIntervals: [
                    { timeUnit: "millisecond", count: 1 },
                    { timeUnit: "millisecond", count: 10 },
                    { timeUnit: "millisecond", count: 100 },
                    { timeUnit: "second", count: 1 },
                    { timeUnit: "second", count: 10 },
                    { timeUnit: "minute", count: 1 },
                    { timeUnit: "minute", count: 10 },
                    { timeUnit: "hour", count: 1 },
                    { timeUnit: "day", count: 1 },
                    { timeUnit: "week", count: 1 },
                    { timeUnit: "month", count: 1 },
                    { timeUnit: "year", count: 1 }
                ],
                fillRule: (dataItem) => {
                    const axisFill = dataItem.get("axisFill");
                    if (axisFill) {
                        const axis = dataItem.component;
                        const value = dataItem.get("value");
                        const endValue = dataItem.get("endValue");
                        const intervalDuration = axis.intervalDuration();
                        const baseInterval = axis.getPrivate("baseInterval");
                        const gridInterval = axis.getPrivate("gridInterval", baseInterval);
                        let min = axis.getPrivate("min", 0);
                        min = round(new Date(min), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();
                        if (value != null && endValue != null) {
                            const val = Math.round(Math.round((value - min) / intervalDuration)) / 2;
                            if (val == Math.round(val)) {
                                axisFill.setPrivate("visible", true);
                            }
                            else {
                                axisFill.setPrivate("visible", false);
                            }
                        }
                    }
                }
            });
            r("GaplessDateAxis").setAll({
                fillRule: (dataItem) => {
                    const axisFill = dataItem.get("axisFill");
                    if (axisFill) {
                        const index = dataItem.get("index");
                        let visible = false;
                        if (!isNumber(index) || index % 2 == 0) {
                            visible = true;
                        }
                        axisFill.setPrivate("visible", visible);
                    }
                }
            });
            r("ValueAxis").setAll({
                baseValue: 0,
                logarithmic: false,
                strictMinMax: false,
                autoZoom: true,
                fillRule: (dataItem) => {
                    const axisFill = dataItem.get("axisFill");
                    if (axisFill) {
                        const axis = dataItem.component;
                        const value = dataItem.get("value");
                        const step = axis.getPrivate("step");
                        if (isNumber(value) && isNumber(step)) {
                            if (round$1(value / step / 2, 5) == Math.round(value / step / 2)) {
                                axisFill.setPrivate("visible", false);
                            }
                            else {
                                axisFill.setPrivate("visible", true);
                            }
                        }
                    }
                }
            });
            r("DurationAxis").setAll({
                baseUnit: "second"
            });
            /**
             * ------------------------------------------------------------------------
             * charts/xy: Series
             * ------------------------------------------------------------------------
             */
            r("XYSeries").setAll({
                maskBullets: true,
                stackToNegative: true,
                locationX: 0.5,
                locationY: 0.5,
                snapTooltip: false,
                openValueXGrouped: "open",
                openValueYGrouped: "open",
                valueXGrouped: "close",
                valueYGrouped: "close",
                seriesTooltipTarget: "series"
            });
            r("BaseColumnSeries").setAll({
                adjustBulletPosition: true
            });
            r("ColumnSeries").setAll({
                clustered: true
            });
            r("RoundedRectangle", ["series", "column"]).setAll({
                position: "absolute",
                isMeasured: false,
                width: percent(70),
                height: percent(70),
                strokeWidth: 1,
                strokeOpacity: 1,
                cornerRadiusBL: 0,
                cornerRadiusTL: 0,
                cornerRadiusBR: 0,
                cornerRadiusTR: 0,
                fillOpacity: 1,
                role: "figure"
            });
            r("LineSeries").setAll({
                connect: true,
                autoGapCount: 1.1,
                stackToNegative: false
            });
            r("Graphics", ["series", "stroke"]).setAll({
                position: "absolute",
                strokeWidth: 1,
                strokeOpacity: 1,
                isMeasured: false
            });
            r("Graphics", ["series", "fill"]).setAll({
                visible: false,
                fillOpacity: 0,
                position: "absolute",
                strokeWidth: 0,
                strokeOpacity: 0,
                isMeasured: false
            });
            r("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({
                draw: (display, sprite) => {
                    const parent = sprite.parent;
                    if (parent) {
                        const h = parent.height();
                        const w = parent.width();
                        display.moveTo(0, h / 2);
                        display.lineTo(w, h / 2);
                    }
                }
            });
            {
                const rule = r("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {});
                setColor(rule, "stroke", ic, "disabled");
            }
            r("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({
                draw: (display, sprite) => {
                    const parent = sprite.parent;
                    if (parent) {
                        const h = parent.height();
                        const w = parent.width();
                        display.moveTo(0, 0);
                        display.lineTo(w, 0);
                        display.lineTo(w, h);
                        display.lineTo(0, h);
                        display.lineTo(0, 0);
                    }
                }
            });
            {
                const rule = r("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {});
                setColor(rule, "stroke", ic, "disabled");
            }
            r("SmoothedXYLineSeries").setAll({
                tension: 0.5
            });
            r("SmoothedXLineSeries").setAll({
                tension: 0.5
            });
            r("SmoothedYLineSeries").setAll({
                tension: 0.5
            });
            r("Candlestick").setAll({
                position: "absolute",
                isMeasured: false,
                width: percent(50),
                height: percent(50),
                strokeWidth: 1,
                strokeOpacity: 1,
                cornerRadiusBL: 0,
                cornerRadiusTL: 0,
                cornerRadiusBR: 0,
                cornerRadiusTR: 0,
                fillOpacity: 1,
                role: "figure"
            });
            r("OHLC").setAll({
                width: percent(80),
                height: percent(80)
            });
            r("CandlestickSeries").setAll({
                lowValueXGrouped: "low",
                lowValueYGrouped: "low",
                highValueXGrouped: "high",
                highValueYGrouped: "high",
                openValueXGrouped: "open",
                openValueYGrouped: "open",
                valueXGrouped: "close",
                valueYGrouped: "close"
            });
            // These rules can be used for regular columns, too
            {
                const rule = r("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {});
                setColor(rule, "fill", ic, "positive");
                setColor(rule, "stroke", ic, "positive");
            }
            {
                const rule = r("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {});
                setColor(rule, "fill", ic, "negative");
                setColor(rule, "stroke", ic, "negative");
            }
            // Hollow
            r("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromOpen", { fillOpacity: 0 });
            r("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromOpen", { fillOpacity: 1 });
            {
                const rule = r("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", {});
                setColor(rule, "fill", ic, "positive");
                setColor(rule, "stroke", ic, "positive");
            }
            {
                const rule = r("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", {});
                setColor(rule, "fill", ic, "negative");
                setColor(rule, "stroke", ic, "negative");
            }
            // AXIS RANGE GRIP
            {
                const rule = r("RoundedRectangle", ["rangegrip"]);
                rule.setAll({
                    strokeOpacity: 0,
                    fillOpacity: 0,
                    strokeWidth: 1,
                    width: 12,
                    height: 12
                });
            }
            {
                const rule = r("Graphics", ["rangegrip", "button", "icon"]);
                rule.setAll({
                    interactive: false,
                    crisp: true,
                    strokeOpacity: 0.5,
                    draw: (display) => {
                        display.moveTo(0, 0.5);
                        display.lineTo(0, 12.5);
                        display.moveTo(2, 0.5);
                        display.lineTo(2, 12.5);
                        display.moveTo(4, 0.5);
                        display.lineTo(4, 12.5);
                    }
                });
                setColor(rule, "stroke", ic, "secondaryButtonText");
            }
            r("Button", ["rangegrip"]).setAll({
                draggable: true,
                paddingTop: 0,
                paddingBottom: 0
            });
            r("Button", ["rangegrip", "vertical"]).setAll({
                rotation: 90,
                cursorOverStyle: "ns-resize",
                centerX: p50
            });
            r("Button", ["rangegrip", "horizontal"]).setAll({
                cursorOverStyle: "ew-resize",
                centerX: p50
            });
            r("Button", ["rangegrip", "vertical", "left"]).setAll({
                centerY: p100
            });
            r("Button", ["rangegrip", "vertical", "right"]).setAll({
                centerY: 0
            });
            r("Button", ["rangegrip", "horizontal", "top"]).setAll({
                centerY: 0
            });
            r("Button", ["rangegrip", "horizontal", "bottom"]).setAll({
                centerY: p100
            });
        }
    }

    /**
     * Creates an XY chart.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/} for more info
     * @important
     */
    class XYChart extends SerialChart {
        constructor() {
            super(...arguments);
            /**
             * A list of horizontal axes.
             */
            Object.defineProperty(this, "xAxes", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListAutoDispose()
            });
            /**
             * A list of vertical axes.
             */
            Object.defineProperty(this, "yAxes", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListAutoDispose()
            });
            /**
             * A [[Container]] located on top of the chart, used to store top horizontal
             * axes.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "topAxesContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.chartContainer.children.push(Container.new(this._root, { width: p100, layout: this._root.verticalLayout }))
            });
            /**
             * A [[Container]] located in the middle the chart, used to store vertical axes
             * and plot area container.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "yAxesAndPlotContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.chartContainer.children.push(Container.new(this._root, { width: p100, height: p100, layout: this._root.horizontalLayout }))
            });
            /**
             * A [[Container]] located on bottom of the chart, used to store bottom
             * horizontal axes.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "bottomAxesContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.chartContainer.children.push(Container.new(this._root, { width: p100, layout: this._root.verticalLayout }))
            });
            /**
             * A [[Container]] located on left of the chart, used to store left-hand
             * vertical axes.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "leftAxesContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.yAxesAndPlotContainer.children.push(Container.new(this._root, { height: p100, layout: this._root.horizontalLayout }))
            });
            /**
             * A [[Container]] located in the middle of the chart, used to store plotContainer and topPlotContainer
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "plotsContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.yAxesAndPlotContainer.children.push(Container.new(this._root, { width: p100, height: p100, maskContent: false }))
            });
            /**
             * A [[Container]] located in the middle of the chart, used to store actual
             * plots (series).
             *
             * NOTE: `plotContainer` will automatically have its `background` preset. If
             * you need to modify background or outline for chart's plot area, you can
             * use `plotContainer.get("background")` for that.*
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "plotContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.plotsContainer.children.push(Container.new(this._root, { width: p100, height: p100 }))
            });
            /**
             * A [[Container]] used for any elements that need to be displayed over
             * regular `plotContainer`.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "topPlotContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.plotsContainer.children.push(Container.new(this._root, { width: p100, height: p100 }))
            });
            /**
             * A [[Container]] axis grid elements are stored in.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "gridContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.plotContainer.children.push(Container.new(this._root, { width: p100, height: p100, isMeasured: false }))
            });
            /**
             * A [[Container]] axis background grid elements are stored in.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "topGridContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Container.new(this._root, { width: p100, height: p100, isMeasured: false })
            });
            /**
             * A [[Container]] located on right of the chart, used to store right-hand
             * vertical axes.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "rightAxesContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.yAxesAndPlotContainer.children.push(Container.new(this._root, { height: p100, layout: this._root.horizontalLayout }))
            });
            /**
             * A [[Container]] axis headers are stored in.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info
             * @default Container.new()
             */
            Object.defineProperty(this, "axisHeadersContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.plotContainer.children.push(Container.new(this._root, {}))
            });
            /**
             * A button that is shown when chart is not fully zoomed out.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/zoom-and-pan/#Zoom_out_button} for more info
             * @default Button.new()
             */
            Object.defineProperty(this, "zoomOutButton", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.topPlotContainer.children.push(Button.new(this._root, {
                    themeTags: ["zoom"],
                    icon: Graphics.new(this._root, {
                        themeTags: ["button", "icon"]
                    })
                }))
            });
            Object.defineProperty(this, "_movePoint", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: { x: 0, y: 0 }
            });
            Object.defineProperty(this, "_wheelDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_otherCharts", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_movePoints", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_downStartX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_downEndX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_downStartY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_downEndY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _afterNew() {
            this._defaultThemes.push(XYChartDefaultTheme.new(this._root));
            super._afterNew();
            this._disposers.push(this.xAxes);
            this._disposers.push(this.yAxes);
            const root = this._root;
            let verticalLayout = this._root.verticalLayout;
            const zoomOutButton = this.zoomOutButton;
            zoomOutButton.events.on("click", () => {
                this.zoomOut();
            });
            zoomOutButton.hide(0);
            zoomOutButton.states.lookup("default").set("opacity", 1);
            this.chartContainer.set("layout", verticalLayout);
            const plotContainer = this.plotContainer;
            plotContainer.children.push(this.seriesContainer);
            this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer));
            this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer));
            plotContainer.children.push(this.topGridContainer);
            plotContainer.children.push(this.bulletsContainer);
            // Setting trasnparent background so that full body of the plot container
            // is interactive
            plotContainer.set("interactive", true);
            plotContainer.set("interactiveChildren", false);
            plotContainer.set("background", Rectangle.new(root, {
                themeTags: ["plotbackground", "xy", "background"]
            }));
            this._disposers.push(plotContainer.events.on("pointerdown", (event) => {
                this._handlePlotDown(event);
            }));
            this._disposers.push(plotContainer.events.on("globalpointerup", (event) => {
                this._handlePlotUp(event);
            }));
            this._disposers.push(plotContainer.events.on("globalpointermove", (event) => {
                this._handlePlotMove(event);
            }));
            this._maskGrid();
            this._setUpTouch();
        }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("pinchZoomX") || this.isDirty("pinchZoomY") || this.get("panX") || this.get("panY")) {
                this._setUpTouch();
            }
        }
        _setUpTouch() {
            if (!this.plotContainer._display.cancelTouch) {
                this.plotContainer._display.cancelTouch = (this.get("pinchZoomX") || this.get("pinchZoomY") || this.get("panX") || this.get("panY")) ? true : false;
            }
        }
        _maskGrid() {
            this.gridContainer.set("maskContent", true);
            this.topGridContainer.set("maskContent", true);
        }
        _removeSeries(series) {
            series._unstack();
            if (series._posXDp) {
                series._posXDp.dispose();
            }
            if (series._posYDp) {
                series._posYDp.dispose();
            }
            series.set("baseAxis", undefined);
            const xAxis = series.get("xAxis");
            if (xAxis) {
                remove(xAxis.series, series);
                xAxis.markDirtyExtremes();
            }
            const yAxis = series.get("yAxis");
            if (yAxis) {
                remove(yAxis.series, series);
                yAxis.markDirtyExtremes();
            }
            const cursor = this.get("cursor");
            if (cursor) {
                const snapToSeries = cursor.get("snapToSeries");
                if (snapToSeries) {
                    remove(snapToSeries, series);
                }
            }
            super._removeSeries(series);
        }
        /**
         * This method is invoked when mouse wheel is used over chart's plot
         * container, and handles zooming/pan.
         *
         * You can invoke this method manually, if you need to mimic chart's wheel
         * behavior over other elements of the chart.
         */
        handleWheel(event) {
            const wheelX = this.get("wheelX");
            const wheelY = this.get("wheelY");
            const plotContainer = this.plotContainer;
            const wheelEvent = event.originalEvent;
            // Ignore wheel event if it is happening on a non-chart element, e.g. if
            // some page element is over the chart.
            if (isLocalEvent(wheelEvent, this)) {
                wheelEvent.preventDefault();
            }
            else {
                return;
            }
            const plotPoint = plotContainer.toLocal(event.point);
            const wheelStep = this.get("wheelStep", 0.2);
            const shiftY = wheelEvent.deltaY / 100;
            const shiftX = wheelEvent.deltaX / 100;
            const wheelZoomPositionX = this.get("wheelZoomPositionX");
            const wheelZoomPositionY = this.get("wheelZoomPositionY");
            if ((wheelX === "zoomX" || wheelX === "zoomXY") && shiftX != 0) {
                this.xAxes.each((axis) => {
                    if (axis.get("zoomX")) {
                        let start = axis.get("start");
                        let end = axis.get("end");
                        let position = axis.fixPosition(plotPoint.x / plotContainer.width());
                        if (wheelZoomPositionX != null) {
                            position = wheelZoomPositionX;
                        }
                        let newStart = start - wheelStep * (end - start) * shiftX * position;
                        let newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                        if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                            this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                        }
                    }
                });
            }
            if ((wheelY === "zoomX" || wheelY === "zoomXY") && shiftY != 0) {
                this.xAxes.each((axis) => {
                    if (axis.get("zoomX")) {
                        let start = axis.get("start");
                        let end = axis.get("end");
                        let position = axis.fixPosition(plotPoint.x / plotContainer.width());
                        if (wheelZoomPositionX != null) {
                            position = wheelZoomPositionX;
                        }
                        let newStart = start - wheelStep * (end - start) * shiftY * position;
                        let newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                        if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                            this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                        }
                    }
                });
            }
            if ((wheelX === "zoomY" || wheelX === "zoomXY") && shiftX != 0) {
                this.yAxes.each((axis) => {
                    if (axis.get("zoomY")) {
                        let start = axis.get("start");
                        let end = axis.get("end");
                        let position = axis.fixPosition(plotPoint.y / plotContainer.height());
                        if (wheelZoomPositionY != null) {
                            position = wheelZoomPositionY;
                        }
                        let newStart = start - wheelStep * (end - start) * shiftX * position;
                        let newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                        if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                            this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                        }
                    }
                });
            }
            if ((wheelY === "zoomY" || wheelY === "zoomXY") && shiftY != 0) {
                this.yAxes.each((axis) => {
                    if (axis.get("zoomY")) {
                        let start = axis.get("start");
                        let end = axis.get("end");
                        let position = axis.fixPosition(plotPoint.y / plotContainer.height());
                        if (wheelZoomPositionY != null) {
                            position = wheelZoomPositionY;
                        }
                        let newStart = start - wheelStep * (end - start) * shiftY * position;
                        let newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                        if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                            this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                        }
                    }
                });
            }
            if ((wheelX === "panX" || wheelX === "panXY") && shiftX != 0) {
                this.xAxes.each((axis) => {
                    if (axis.get("panX")) {
                        let start = axis.get("start");
                        let end = axis.get("end");
                        let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;
                        let newStart = start + delta;
                        let newEnd = end + delta;
                        let se = this._fixWheel(newStart, newEnd);
                        newStart = se[0];
                        newEnd = se[1];
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                });
            }
            if ((wheelY === "panX" || wheelY === "panXY") && shiftY != 0) {
                this.xAxes.each((axis) => {
                    if (axis.get("panX")) {
                        let start = axis.get("start");
                        let end = axis.get("end");
                        let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;
                        let newStart = start + delta;
                        let newEnd = end + delta;
                        let se = this._fixWheel(newStart, newEnd);
                        newStart = se[0];
                        newEnd = se[1];
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                });
            }
            if ((wheelX === "panY" || wheelX === "panXY") && shiftX != 0) {
                this.yAxes.each((axis) => {
                    if (axis.get("panY")) {
                        let start = axis.get("start");
                        let end = axis.get("end");
                        let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;
                        let newStart = start + delta;
                        let newEnd = end + delta;
                        let se = this._fixWheel(newStart, newEnd);
                        newStart = se[0];
                        newEnd = se[1];
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                });
            }
            if ((wheelY === "panY" || wheelY === "panXY") && shiftY != 0) {
                this.yAxes.each((axis) => {
                    if (axis.get("panY")) {
                        let start = axis.get("start");
                        let end = axis.get("end");
                        let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;
                        let newStart = start - delta;
                        let newEnd = end - delta;
                        let se = this._fixWheel(newStart, newEnd);
                        newStart = se[0];
                        newEnd = se[1];
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                });
            }
        }
        _handleSetWheel() {
            const wheelX = this.get("wheelX");
            const wheelY = this.get("wheelY");
            const plotContainer = this.plotContainer;
            if (wheelX !== "none" || wheelY !== "none") {
                this._wheelDp = plotContainer.events.on("wheel", (event) => {
                    const wheelEvent = event.originalEvent;
                    if ((wheelX !== "none" && Math.abs(wheelEvent.deltaX) != 0) || (wheelY !== "none" && Math.abs(wheelEvent.deltaY) != 0)) {
                        this.handleWheel(event);
                    }
                });
                this._disposers.push(this._wheelDp);
            }
            else {
                if (this._wheelDp) {
                    this._wheelDp.dispose();
                }
            }
        }
        _getWheelSign(axis) {
            let sign = 1;
            if (axis.get("renderer").get("inversed")) {
                sign = -1;
            }
            return sign;
        }
        _fixWheel(start, end) {
            const diff = end - start;
            if (start < 0) {
                start = 0;
                end = start + diff;
            }
            if (end > 1) {
                end = 1;
                start = end - diff;
            }
            return [start, end];
        }
        _handlePlotDown(event) {
            const originalEvent = event.originalEvent;
            if (originalEvent.button == 2) {
                return;
            }
            const plotContainer = this.plotContainer;
            let local = plotContainer.toLocal(event.point);
            if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
                const pointerId = originalEvent.pointerId;
                if (pointerId) {
                    if (keys(plotContainer._downPoints).length > 0) {
                        const xAxis = this.xAxes.getIndex(0);
                        const yAxis = this.yAxes.getIndex(0);
                        if (xAxis) {
                            this._downStartX = xAxis.get("start", 0);
                            this._downEndX = xAxis.get("end", 1);
                        }
                        if (yAxis) {
                            this._downStartY = yAxis.get("start", 0);
                            this._downEndY = yAxis.get("end", 1);
                        }
                    }
                }
            }
            if (this.get("panX") || this.get("panY")) {
                if (local.x >= 0 && local.y >= 0 && local.x <= plotContainer.width() && local.y <= this.height()) {
                    //this._downPoint = local;
                    this._downPoint = { x: originalEvent.clientX, y: originalEvent.clientY };
                    const panX = this.get("panX");
                    const panY = this.get("panY");
                    if (panX) {
                        this.xAxes.each((axis) => {
                            axis._panStart = axis.get("start");
                            axis._panEnd = axis.get("end");
                        });
                    }
                    if (panY) {
                        this.yAxes.each((axis) => {
                            axis._panStart = axis.get("start");
                            axis._panEnd = axis.get("end");
                        });
                    }
                    const eventType = "panstarted";
                    if (this.events.isEnabled(eventType)) {
                        this.events.dispatch(eventType, { type: eventType, target: this, originalEvent: event.originalEvent });
                    }
                }
            }
        }
        _handleWheelAnimation(animation) {
            if (animation) {
                animation.events.on("stopped", () => {
                    this._dispatchWheelAnimation();
                });
            }
            else {
                this._dispatchWheelAnimation();
            }
        }
        _dispatchWheelAnimation() {
            const eventType = "wheelended";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, { type: eventType, target: this });
            }
        }
        _handlePlotUp(event) {
            const downPoint = this._downPoint;
            if (downPoint) {
                if (this.get("panX") || this.get("panY")) {
                    if (event.originalEvent.clientX == downPoint.x && event.originalEvent.clientY == downPoint.y) {
                        const eventType = "pancancelled";
                        if (this.events.isEnabled(eventType)) {
                            this.events.dispatch(eventType, { type: eventType, target: this, originalEvent: event.originalEvent });
                        }
                    }
                    const eventType = "panended";
                    if (this.events.isEnabled(eventType)) {
                        this.events.dispatch(eventType, { type: eventType, target: this, originalEvent: event.originalEvent });
                    }
                }
            }
            // TODO: handle multitouch
            this._downPoint = undefined;
            this.xAxes.each((xAxis) => {
                xAxis._isPanning = false;
            });
            this.yAxes.each((yAxis) => {
                yAxis._isPanning = false;
            });
        }
        _handlePlotMove(event) {
            const plotContainer = this.plotContainer;
            if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
                const touchEvent = event.originalEvent;
                const pointerId = touchEvent.pointerId;
                if (pointerId) {
                    this._movePoints[pointerId] = event.point;
                    if (keys(plotContainer._downPoints).length > 1) {
                        this._handlePinch();
                        return;
                    }
                }
            }
            let downPoint = this._downPoint;
            if (downPoint) {
                downPoint = plotContainer.toLocal(this._root.documentPointToRoot(downPoint));
                let local = plotContainer.toLocal(event.point);
                const panX = this.get("panX");
                const panY = this.get("panY");
                if (panX) {
                    let scrollbarX = this.get("scrollbarX");
                    if (scrollbarX) {
                        scrollbarX.events.disableType("rangechanged");
                    }
                    this.xAxes.each((axis) => {
                        if (axis.get("panX")) {
                            axis._isPanning = true;
                            //const maxDeviation = axis.get("maxDeviation", 0);
                            let panStart = axis._panStart;
                            let panEnd = axis._panEnd;
                            let difference = (panEnd - panStart);
                            let deltaX = difference * (downPoint.x - local.x) / plotContainer.width();
                            if (axis.get("renderer").get("inversed")) {
                                deltaX *= -1;
                            }
                            let start = panStart + deltaX;
                            let end = panEnd + deltaX;
                            if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {
                                axis.set("start", start);
                                axis.set("end", end);
                            }
                        }
                    });
                    if (scrollbarX) {
                        scrollbarX.events.enableType("rangechanged");
                    }
                }
                if (panY) {
                    let scrollbarY = this.get("scrollbarY");
                    if (scrollbarY) {
                        scrollbarY.events.disableType("rangechanged");
                    }
                    this.yAxes.each((axis) => {
                        if (axis.get("panY")) {
                            axis._isPanning = true;
                            //const maxDeviation = axis.get("maxDeviation", 0);
                            let panStart = axis._panStart;
                            let panEnd = axis._panEnd;
                            let difference = (panEnd - panStart);
                            let deltaY = difference * (downPoint.y - local.y) / plotContainer.height();
                            if (axis.get("renderer").get("inversed")) {
                                deltaY *= -1;
                            }
                            let start = panStart - deltaY;
                            let end = panEnd - deltaY;
                            if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {
                                axis.set("start", start);
                                axis.set("end", end);
                            }
                        }
                    });
                    if (scrollbarY) {
                        scrollbarY.events.enableType("rangechanged");
                    }
                }
            }
        }
        _handlePinch() {
            const plotContainer = this.plotContainer;
            let i = 0;
            let downPoints = [];
            let movePoints = [];
            each(plotContainer._downPoints, (k, point) => {
                downPoints[i] = point;
                let movePoint = this._movePoints[k];
                if (movePoint) {
                    movePoints[i] = movePoint;
                }
                i++;
            });
            if (downPoints.length > 1 && movePoints.length > 1) {
                const w = plotContainer.width();
                const h = plotContainer.height();
                let downPoint0 = downPoints[0];
                let downPoint1 = downPoints[1];
                let movePoint0 = movePoints[0];
                let movePoint1 = movePoints[1];
                if (downPoint0 && downPoint1 && movePoint0 && movePoint1) {
                    movePoint0 = plotContainer.toLocal(movePoint0);
                    movePoint1 = plotContainer.toLocal(movePoint1);
                    downPoint0 = plotContainer.toLocal(downPoint0);
                    downPoint1 = plotContainer.toLocal(downPoint1);
                    if (this.get("pinchZoomX")) {
                        const downStartX = this._downStartX;
                        const downEndX = this._downEndX;
                        if (downStartX != null && downEndX != null) {
                            if (downPoint0.x > downPoint1.x) {
                                [downPoint0, downPoint1] = [downPoint1, downPoint0];
                                [movePoint0, movePoint1] = [movePoint1, movePoint0];
                            }
                            let downPos0 = downStartX + (downPoint0.x / w) * (downEndX - downStartX);
                            let downPos1 = downStartX + (downPoint1.x / w) * (downEndX - downStartX);
                            let movePos0 = downStartX + (movePoint0.x / w) * (downEndX - downStartX);
                            let movePos1 = downStartX + (movePoint1.x / w) * (downEndX - downStartX);
                            let initialDistance = Math.max(0.001, downPos1 - downPos0);
                            let currentDistance = Math.max(0.001, movePos1 - movePos0);
                            let d = initialDistance / currentDistance;
                            let s = downStartX * d + downPos0 - movePos0 * d;
                            let e = downEndX * d + downPos1 - movePos1 * d;
                            this.xAxes.each((xAxis) => {
                                let sa = xAxis.fixPosition(s);
                                let ea = xAxis.fixPosition(e);
                                xAxis.zoom(sa, ea, 0);
                            });
                        }
                    }
                    if (this.get("pinchZoomY")) {
                        const downStartY = this._downStartY;
                        const downEndY = this._downEndY;
                        if (downStartY != null && downEndY != null) {
                            if (downPoint0.y < downPoint1.y) {
                                [downPoint0, downPoint1] = [downPoint1, downPoint0];
                                [movePoint0, movePoint1] = [movePoint1, movePoint0];
                            }
                            let downPos0 = downStartY + (1 - downPoint0.y / h) * (downEndY - downStartY);
                            let downPos1 = downStartY + (1 - downPoint1.y / h) * (downEndY - downStartY);
                            let movePos0 = downStartY + (1 - movePoint0.y / h) * (downEndY - downStartY);
                            let movePos1 = downStartY + (1 - movePoint1.y / h) * (downEndY - downStartY);
                            let initialDistance = Math.max(0.001, downPos1 - downPos0);
                            let currentDistance = Math.max(0.001, movePos1 - movePos0);
                            let d = initialDistance / currentDistance;
                            let s = downStartY * d + downPos0 - movePos0 * d;
                            let e = downEndY * d + downPos1 - movePos1 * d;
                            this.yAxes.each((yAxis) => {
                                let sa = yAxis.fixPosition(s);
                                let ea = yAxis.fixPosition(e);
                                yAxis.zoom(sa, ea, 0);
                            });
                        }
                    }
                }
            }
        }
        _handleCursorPosition() {
            const cursor = this.get("cursor");
            if (cursor) {
                const cursorPoint = cursor.getPrivate("point");
                let snapToSeries = cursor.get("snapToSeries");
                if (cursor._downPoint) {
                    snapToSeries = undefined;
                }
                if (snapToSeries && cursorPoint) {
                    const snapToSeriesBy = cursor.get("snapToSeriesBy");
                    const dataItems = [];
                    each$1(snapToSeries, (series) => {
                        if (!series.isHidden() && !series.isHiding()) {
                            if (snapToSeriesBy != "x!" && snapToSeriesBy != "y!") {
                                const startIndex = series.startIndex();
                                const endIndex = series.endIndex();
                                for (let i = startIndex; i < endIndex; i++) {
                                    const dataItem = series.dataItems[i];
                                    if (dataItem && !dataItem.isHidden()) {
                                        dataItems.push(dataItem);
                                    }
                                }
                            }
                            else {
                                const tooltipDataItem = series.get("tooltipDataItem");
                                if (tooltipDataItem) {
                                    dataItems.push(tooltipDataItem);
                                }
                            }
                        }
                    });
                    let minDistance = Infinity;
                    let closestItem;
                    each$1(dataItems, (dataItem) => {
                        const point = dataItem.get("point");
                        if (point) {
                            let distance = 0;
                            if (snapToSeriesBy == "x" || snapToSeriesBy == "x!") {
                                distance = Math.abs(cursorPoint.x - point.x);
                            }
                            else if (snapToSeriesBy == "y" || snapToSeriesBy == "y!") {
                                distance = Math.abs(cursorPoint.y - point.y);
                            }
                            else {
                                distance = Math.hypot(cursorPoint.x - point.x, cursorPoint.y - point.y);
                            }
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestItem = dataItem;
                            }
                        }
                    });
                    each$1(snapToSeries, (series) => {
                        const tooltip = series.get("tooltip");
                        if (tooltip) {
                            tooltip._setDataItem(undefined);
                        }
                    });
                    if (closestItem) {
                        let series = closestItem.component;
                        series.showDataItemTooltip(closestItem);
                        series.setRaw("tooltipDataItem", closestItem);
                        const point = closestItem.get("point");
                        if (point) {
                            // removing x and y to solve #72225
                            cursor.handleMove(series.toGlobal({ x: point.x - series.x(), y: point.y - series.y() }), true);
                        }
                    }
                }
            }
        }
        _updateCursor() {
            let cursor = this.get("cursor");
            if (cursor) {
                cursor.updateCursor();
            }
        }
        _addCursor(cursor) {
            this.plotContainer.children.push(cursor);
        }
        _prepareChildren() {
            super._prepareChildren();
            this.series.each((series) => {
                this._colorize(series);
            });
            if (this.isDirty("wheelX") || this.isDirty("wheelY")) {
                this._handleSetWheel();
            }
            if (this.isDirty("cursor")) {
                const previous = this._prevSettings.cursor;
                const cursor = this.get("cursor");
                if (cursor !== previous) {
                    this._disposeProperty("cursor");
                    if (previous) {
                        previous.dispose();
                    }
                    if (cursor) {
                        cursor._setChart(this);
                        this._addCursor(cursor);
                        this._pushPropertyDisposer("cursor", cursor.events.on("selectended", () => {
                            this._handleCursorSelectEnd();
                        }));
                    }
                    //this.setRaw("cursor", cursor) // to reset previous value
                    this._prevSettings.cursor = cursor;
                }
            }
            if (this.isDirty("scrollbarX")) {
                const previous = this._prevSettings.scrollbarX;
                const scrollbarX = this.get("scrollbarX");
                if (scrollbarX !== previous) {
                    this._disposeProperty("scrollbarX");
                    if (previous) {
                        previous.dispose();
                    }
                    if (scrollbarX) {
                        if (!scrollbarX.parent) {
                            this.topAxesContainer.children.push(scrollbarX);
                        }
                        this._pushPropertyDisposer("scrollbarX", scrollbarX.events.on("rangechanged", (e) => {
                            this._handleScrollbar(this.xAxes, e.start, e.end, e.grip);
                        }));
                        this._pushPropertyDisposer("scrollbarX", scrollbarX.events.on("released", () => {
                            this.xAxes.each((axis) => {
                                if (axis.get("zoomable")) {
                                    this._handleAxisSelection(axis);
                                }
                            });
                        }));
                        // Used to populate `ariaLabel` with meaningful values
                        scrollbarX.setPrivate("positionTextFunction", (position) => {
                            const axis = this.xAxes.getIndex(0);
                            return axis ? axis.getTooltipText(position, false) || "" : "";
                        });
                    }
                    this._prevSettings.scrollbarX = scrollbarX;
                }
            }
            if (this.isDirty("scrollbarY")) {
                const previous = this._prevSettings.scrollbarY;
                const scrollbarY = this.get("scrollbarY");
                if (scrollbarY !== previous) {
                    this._disposeProperty("scrollbarY");
                    if (previous) {
                        previous.dispose();
                    }
                    if (scrollbarY) {
                        if (!scrollbarY.parent) {
                            this.rightAxesContainer.children.push(scrollbarY);
                        }
                        this._pushPropertyDisposer("scrollbarY", scrollbarY.events.on("rangechanged", (e) => {
                            this._handleScrollbar(this.yAxes, e.start, e.end, e.grip);
                        }));
                        this._pushPropertyDisposer("scrollbarY", scrollbarY.events.on("released", () => {
                            this.yAxes.each((axis) => {
                                if (axis.get("zoomable")) {
                                    this._handleAxisSelection(axis);
                                }
                            });
                        }));
                        // Used to populate `ariaLabel` with meaningful values
                        scrollbarY.setPrivate("positionTextFunction", (position) => {
                            const axis = this.yAxes.getIndex(0);
                            return axis ? axis.getTooltipText(position, false) || "" : "";
                        });
                    }
                    this._prevSettings.scrollbarY = scrollbarY;
                }
            }
            this._handleZoomOut();
        }
        _processSeries(series) {
            super._processSeries(series);
            const xAxis = series.get("xAxis");
            const yAxis = series.get("yAxis");
            move(xAxis.series, series);
            move(yAxis.series, series);
            series._posXDp = series.addDisposer(xAxis.events.on("positionchanged", () => {
                series._fixPosition();
            }));
            series._posXDp = series.addDisposer(yAxis.events.on("positionchanged", () => {
                series._fixPosition();
            }));
            if (!series.get("baseAxis")) {
                if (yAxis.isType("CategoryAxis") || yAxis.isType("DateAxis")) {
                    series.set("baseAxis", yAxis);
                }
                else {
                    series.set("baseAxis", xAxis);
                }
            }
            if (series.get("stacked")) {
                series._markDirtyKey("stacked");
                each$1(series.dataItems, (dataItem) => {
                    dataItem.set("stackToItemY", undefined);
                    dataItem.set("stackToItemX", undefined);
                });
            }
            series._markDirtyAxes();
            yAxis.markDirtyExtremes();
            xAxis.markDirtyExtremes();
            xAxis._seriesAdded = true;
            yAxis._seriesAdded = true;
            this._colorize(series);
        }
        _colorize(series) {
            const colorSet = this.get("colors");
            if (colorSet) {
                if (series.get("fill") == null) {
                    const color = colorSet.next();
                    series._setSoft("stroke", color);
                    series._setSoft("fill", color);
                }
            }
            const patternSet = this.get("patterns");
            if (patternSet) {
                if (series.get("fillPattern") == null) {
                    const pattern = patternSet.next();
                    series._setSoft("fillPattern", pattern);
                }
            }
        }
        _handleCursorSelectEnd() {
            const cursor = this.get("cursor");
            const behavior = cursor.get("behavior");
            const downPositionX = cursor.getPrivate("downPositionX", 0);
            const downPositionY = cursor.getPrivate("downPositionY", 0);
            const positionX = Math.min(1, Math.max(0, cursor.getPrivate("positionX", 0.5)));
            const positionY = Math.min(1, Math.max(0, cursor.getPrivate("positionY", 0.5)));
            this.xAxes.each((axis) => {
                if (behavior === "zoomX" || behavior === "zoomXY") {
                    let position0 = axis.toAxisPosition(downPositionX);
                    let position1 = axis.toAxisPosition(positionX);
                    axis.zoom(position0, position1);
                }
                axis.setPrivate("updateScrollbar", true);
            });
            this.yAxes.each((axis) => {
                if (behavior === "zoomY" || behavior === "zoomXY") {
                    let position0 = axis.toAxisPosition(downPositionY);
                    let position1 = axis.toAxisPosition(positionY);
                    axis.zoom(position0, position1);
                }
                axis.setPrivate("updateScrollbar", true);
            });
        }
        _handleScrollbar(axes, start, end, priority) {
            axes.each((axis) => {
                let axisStart = axis.fixPosition(start);
                let axisEnd = axis.fixPosition(end);
                let zoomAnimation = axis.zoom(axisStart, axisEnd, undefined, priority);
                const updateScrollbar = "updateScrollbar";
                axis.setPrivateRaw(updateScrollbar, false);
                if (zoomAnimation) {
                    zoomAnimation.events.on("stopped", () => {
                        axis.setPrivateRaw(updateScrollbar, true);
                    });
                }
                else {
                    axis.setPrivateRaw(updateScrollbar, true);
                }
            });
        }
        _processAxis(axes, container) {
            return axes.events.onAll((change) => {
                if (change.type === "clear") {
                    each$1(change.oldValues, (axis) => {
                        this._removeAxis(axis);
                    });
                }
                else if (change.type === "push") {
                    container.children.push(change.newValue);
                    change.newValue.processChart(this);
                }
                else if (change.type === "setIndex") {
                    container.children.setIndex(change.index, change.newValue);
                    change.newValue.processChart(this);
                }
                else if (change.type === "insertIndex") {
                    container.children.insertIndex(change.index, change.newValue);
                    change.newValue.processChart(this);
                }
                else if (change.type === "removeIndex") {
                    this._removeAxis(change.oldValue);
                }
                else if (change.type === "moveIndex") {
                    container.children.moveValue(change.value, change.newIndex);
                    change.value.processChart(this);
                }
                else {
                    throw new Error("Unknown IListEvent type");
                }
            });
        }
        _removeAxis(axis) {
            if (!axis.isDisposed()) {
                const axisParent = axis.parent;
                if (axisParent) {
                    axisParent.children.removeValue(axis);
                }
                const gridContainer = axis.gridContainer;
                const gridParent = gridContainer.parent;
                if (gridParent) {
                    gridParent.children.removeValue(gridContainer);
                }
                const topGridContainer = axis.topGridContainer;
                const topGridParent = topGridContainer.parent;
                if (topGridParent) {
                    topGridParent.children.removeValue(topGridContainer);
                }
            }
        }
        _updateChartLayout() {
            const left = this.leftAxesContainer.width();
            const right = this.rightAxesContainer.width();
            const bottomAxesContainer = this.bottomAxesContainer;
            bottomAxesContainer.set("paddingLeft", left);
            bottomAxesContainer.set("paddingRight", right);
            const topAxesContainer = this.topAxesContainer;
            topAxesContainer.set("paddingLeft", left);
            topAxesContainer.set("paddingRight", right);
        }
        /**
         * @ignore
         */
        processAxis(axis) {
            var cursor = this.get("cursor");
            if (cursor) {
                this.addDisposer(axis.on("start", () => {
                    this._updateCursor();
                }));
                this.addDisposer(axis.on("end", () => {
                    this._updateCursor();
                }));
            }
        }
        _handleAxisSelection(axis, force) {
            let start = axis.fixPosition(axis.get("start", 0));
            let end = axis.fixPosition(axis.get("end", 1));
            if (start > end) {
                [start, end] = [end, start];
            }
            if (this.xAxes.indexOf(axis) != -1) {
                if (force || axis.getPrivate("updateScrollbar")) {
                    let scrollbarX = this.get("scrollbarX");
                    if (scrollbarX && (!scrollbarX.getPrivate("isBusy") || force)) {
                        scrollbarX.setRaw("start", start);
                        scrollbarX.setRaw("end", end);
                        scrollbarX.updateGrips();
                    }
                }
            }
            else if (this.yAxes.indexOf(axis) != -1) {
                if (force || axis.getPrivate("updateScrollbar")) {
                    let scrollbarY = this.get("scrollbarY");
                    if (scrollbarY && (!scrollbarY.getPrivate("isBusy") || force)) {
                        scrollbarY.setRaw("start", start);
                        scrollbarY.setRaw("end", end);
                        scrollbarY.updateGrips();
                    }
                }
            }
            this._handleZoomOut();
        }
        _handleZoomOut() {
            let zoomOutButton = this.zoomOutButton;
            if (zoomOutButton && zoomOutButton.parent) {
                let visible = false;
                this.xAxes.each((axis) => {
                    if (round$1(axis.get("start", 0), 6) != 0 || round$1(axis.get("end", 1), 6) != 1) {
                        visible = true;
                    }
                });
                this.yAxes.each((axis) => {
                    if (round$1(axis.get("start", 0), 6) != 0 || round$1(axis.get("end", 1), 6) != 1) {
                        visible = true;
                    }
                });
                if (visible) {
                    if (zoomOutButton.isHidden()) {
                        zoomOutButton.show();
                    }
                }
                else {
                    zoomOutButton.hide();
                }
            }
        }
        /**
         * Checks if point is within plot area.
         *
         * @param   point  Reference point
         * @return         Is within plot area?
         */
        inPlot(point) {
            const plotContainer = this.plotContainer;
            const otherCharts = this.getPrivate("otherCharts", this._otherCharts);
            const global = plotContainer.toGlobal(point);
            if (point.x >= -0.5 && point.y >= -0.5 && point.x <= plotContainer.width() + 0.5 && point.y <= plotContainer.height() + 0.5) {
                return true;
            }
            if (otherCharts) {
                for (let i = otherCharts.length - 1; i >= 0; i--) {
                    const chart = otherCharts[i];
                    if (chart != this) {
                        const chartPlotContainer = chart.plotContainer;
                        const documentPoint = this._root.rootPointToDocument(global);
                        const chartRoot = chart._root.documentPointToRoot(documentPoint);
                        const local = chartPlotContainer.toLocal(chartRoot);
                        if (local.x >= -0.1 && local.y >= -0.1 && local.x <= chartPlotContainer.width() + 0.1 && local.y <= chartPlotContainer.height() + 0.1) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        /**
         * @ignore
         */
        arrangeTooltips() {
            const plotContainer = this.plotContainer;
            const w = plotContainer.width();
            const h = plotContainer.height();
            const hh = this.height();
            let plotT = plotContainer._display.toGlobal({ x: 0, y: 0 });
            let plotB = plotContainer._display.toGlobal({ x: w, y: h });
            const tooltips = [];
            let sum = 0;
            let minDistance = Infinity;
            let movePoint = this._movePoint;
            let maxTooltipDistance = this.get("maxTooltipDistance");
            let maxTooltipDistanceBy = this.get("maxTooltipDistanceBy", "xy");
            let closest;
            let closestPoint;
            if (isNumber(maxTooltipDistance)) {
                this.series.each((series) => {
                    if (!series.isHidden()) {
                        const tooltip = series.get("tooltip");
                        if (tooltip) {
                            let point = tooltip.get("pointTo");
                            if (point) {
                                let distance = Math.hypot(movePoint.x - point.x, movePoint.y - point.y);
                                if (maxTooltipDistanceBy == "x") {
                                    distance = Math.abs(movePoint.x - point.x);
                                }
                                else if (maxTooltipDistanceBy == "y") {
                                    distance = Math.abs(movePoint.y - point.y);
                                }
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closest = series;
                                    closestPoint = point;
                                }
                            }
                        }
                    }
                });
            }
            const tooltipSeries = [];
            this.series.each((series) => {
                const tooltip = series.get("tooltip");
                if (tooltip && !tooltip.get("forceHidden")) {
                    let hidden = false;
                    let point = tooltip.get("pointTo");
                    if (point) {
                        if (maxTooltipDistance >= 0) {
                            let point = tooltip.get("pointTo");
                            if (point && closestPoint) {
                                if (series != closest) {
                                    let distance = Math.hypot(closestPoint.x - point.x, closestPoint.y - point.y);
                                    if (maxTooltipDistanceBy == "x") {
                                        distance = Math.abs(closestPoint.x - point.x);
                                    }
                                    else if (maxTooltipDistanceBy == "y") {
                                        distance = Math.abs(closestPoint.y - point.y);
                                    }
                                    if (distance > maxTooltipDistance) {
                                        hidden = true;
                                    }
                                }
                            }
                        }
                        else if (maxTooltipDistance == -1) {
                            if (series != closest) {
                                hidden = true;
                            }
                        }
                        if (!this.inPlot(this._tooltipToLocal(point)) || !tooltip.dataItem) {
                            hidden = true;
                        }
                        else {
                            if (!hidden) {
                                sum += point.y;
                            }
                        }
                        if (hidden || series.isHidden() || series.isHiding()) {
                            tooltip.hide(0);
                        }
                        else {
                            tooltip.show();
                            tooltips.push(tooltip);
                            tooltipSeries.push(series);
                        }
                    }
                }
            });
            this.setPrivate("tooltipSeries", tooltipSeries);
            if (this.get("arrangeTooltips")) {
                const tooltipContainer = this._root.tooltipContainer;
                const count = tooltips.length;
                const average = sum / count;
                if (average > h / 2 + plotT.y) {
                    tooltips.sort((a, b) => compareNumber(b.get("pointTo").y, a.get("pointTo").y));
                    let prevY = plotB.y;
                    each$1(tooltips, (tooltip) => {
                        let height = tooltip.height();
                        let centerY = tooltip.get("centerY");
                        if (centerY instanceof Percent) {
                            height *= centerY.value;
                        }
                        height += tooltip.get("marginBottom", 0);
                        tooltip.set("bounds", { left: plotT.x, top: plotT.y, right: plotB.x, bottom: prevY });
                        tooltip.setPrivate("customData", { left: plotT.x, top: plotT.y, right: plotB.x, bottom: prevY });
                        prevY = Math.min(prevY - height, tooltip._fy - height);
                        if (tooltip.parent == tooltipContainer) {
                            tooltipContainer.children.moveValue(tooltip, 0);
                        }
                    });
                    if (prevY < 0) {
                        tooltips.reverse();
                        let prevBottom = prevY;
                        each$1(tooltips, (tooltip) => {
                            let bounds = tooltip.get("bounds");
                            if (bounds) {
                                let top = bounds.top - prevY;
                                let bottom = bounds.bottom - prevY;
                                if (top < prevBottom) {
                                    top = prevBottom;
                                    bottom = top + tooltip.height();
                                }
                                tooltip.set("bounds", { left: bounds.left, top: top, right: bounds.right, bottom: bottom });
                                prevBottom = bounds.bottom - prevY + tooltip.get("marginBottom", 0);
                            }
                        });
                    }
                }
                else {
                    tooltips.reverse();
                    tooltips.sort((a, b) => compareNumber(a.get("pointTo").y, b.get("pointTo").y));
                    let prevY = 0;
                    each$1(tooltips, (tooltip) => {
                        let height = tooltip.height();
                        let centerY = tooltip.get("centerY");
                        if (centerY instanceof Percent) {
                            height *= centerY.value;
                        }
                        height += tooltip.get("marginBottom", 0);
                        tooltip.set("bounds", { left: plotT.x, top: prevY, right: plotB.x, bottom: Math.max(plotT.y + hh, prevY + height) });
                        if (tooltip.parent == tooltipContainer) {
                            tooltipContainer.children.moveValue(tooltip, 0);
                        }
                        prevY = Math.max(prevY + height, tooltip._fy + height);
                    });
                    if (prevY > hh) {
                        tooltips.reverse();
                        let prevBottom = hh;
                        each$1(tooltips, (tooltip) => {
                            let bounds = tooltip.get("bounds");
                            if (bounds) {
                                let top = bounds.top - (hh - prevY);
                                let bottom = bounds.bottom - (hh - prevY);
                                if (bottom > prevBottom) {
                                    bottom = prevBottom;
                                    top = bottom - tooltip.height();
                                }
                                tooltip.set("bounds", { left: bounds.left, top: top, right: bounds.right, bottom: bottom });
                                prevBottom = bottom - tooltip.height() - tooltip.get("marginBottom", 0);
                            }
                        });
                    }
                }
            }
        }
        _tooltipToLocal(point) {
            return this.plotContainer.toLocal(point);
        }
        /**
         * Fully zooms out the chart.
         */
        zoomOut() {
            this.xAxes.each((axis) => {
                axis.setPrivate("updateScrollbar", true);
                axis.zoom(0, 1);
            });
            this.yAxes.each((axis) => {
                axis.setPrivate("updateScrollbar", true);
                axis.zoom(0, 1);
            });
        }
        _dispose() {
            super._dispose();
            // Explicitly disposing cursor to avoid memory leak of cursor adding
            // keyboard events after parent chart has been disposed
            const cursor = this.get("cursor");
            if (cursor) {
                cursor.dispose();
            }
        }
    }
    Object.defineProperty(XYChart, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "XYChart"
    });
    Object.defineProperty(XYChart, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: SerialChart.classNames.concat([XYChart.className])
    });

    /**
     * Creates a scrollbar with chart preview in it.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/scrollbars/#Scrollbar_with_chart_preview} for more info
     * @important
     */
    class XYChartScrollbar extends Scrollbar {
        constructor() {
            super(...arguments);
            /**
             * An instance of an [[XYChart]] that is used to plot chart preview in
             * scrollbar.
             */
            Object.defineProperty(this, "chart", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(XYChart.new(this._root, {
                    themeTags: ["chart"],
                    interactive: false,
                    interactiveChildren: false,
                    panX: false,
                    panY: false,
                    wheelX: "none",
                    wheelY: "none"
                }))
            });
            /**
             * A graphics element that is displayed over inactive portion of the
             * scrollbarpreview, to dim it down.
             */
            Object.defineProperty(this, "overlay", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Graphics.new(this._root, {
                    themeTags: ["overlay"],
                    interactive: false
                }))
            });
        }
        _afterNew() {
            this._addOrientationClass();
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["scrollbar", "xy", "chart", this._settings.orientation]);
            const children = this.children;
            children.moveValue(this.thumb);
            children.moveValue(this.startGrip);
            children.moveValue(this.endGrip);
            this.thumb.set("opacity", 0);
            this.thumb.states.create("hover", { opacity: 0.2 });
            const plotContainer = this.chart.plotContainer;
            plotContainer.set("interactive", false);
            plotContainer.remove("background");
            plotContainer.children.removeValue(this.chart.zoomOutButton);
            super._afterNew();
        }
        _updateThumb() {
            super._updateThumb();
            this.overlay.set("draw", (display) => {
                const startGrip = this.startGrip;
                const endGrip = this.endGrip;
                let x0 = startGrip.x();
                let y0 = startGrip.y();
                let x1 = endGrip.x();
                let y1 = endGrip.y();
                const h = this.height();
                const w = this.width();
                if (x0 > x1) {
                    [x0, x1] = [x1, x0];
                }
                if (y0 > y1) {
                    [y0, y1] = [y1, y0];
                }
                if (this.get("orientation") === "horizontal") {
                    display.moveTo(0, 0);
                    display.lineTo(x0, 0);
                    display.lineTo(x0, h);
                    display.lineTo(0, h);
                    display.lineTo(0, 0);
                    display.moveTo(x1, 0);
                    display.lineTo(w, 0);
                    display.lineTo(w, h);
                    display.lineTo(x1, h);
                    display.lineTo(x1, 0);
                }
                else {
                    display.moveTo(0, 0);
                    display.lineTo(0, y0);
                    display.lineTo(w, y0);
                    display.lineTo(w, 0);
                    display.lineTo(0, 0);
                    display.moveTo(0, y1);
                    display.lineTo(0, h);
                    display.lineTo(w, h);
                    display.lineTo(w, y1);
                    display.lineTo(0, y1);
                }
            });
        }
    }
    Object.defineProperty(XYChartScrollbar, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "XYChartScrollbar"
    });
    Object.defineProperty(XYChartScrollbar, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Scrollbar.classNames.concat([XYChartScrollbar.className])
    });

    /**
     * Creates an axis grid line.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Grid} for more info
     * @important
     */
    class Grid extends Graphics {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
                this._clear = true;
            }
        }
    }
    Object.defineProperty(Grid, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Grid"
    });
    Object.defineProperty(Grid, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([Grid.className])
    });

    /**
     * Creates a chart cursor for an [[XYChart]].
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/cursor/} for more info
     * @important
     */
    class XYCursor extends Container {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_alwaysShow", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            /**
             * A [[Grid]] elment that used for horizontal line of the cursor crosshair.
             *
             * @default Grid.new()
             */
            Object.defineProperty(this, "lineX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Grid.new(this._root, {
                    themeTags: ["x"]
                }))
            });
            /**
             * A [[Grid]] elment that used for horizontal line of the cursor crosshair.
             *
             * @default Grid.new()
             */
            Object.defineProperty(this, "lineY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Grid.new(this._root, {
                    themeTags: ["y"]
                }))
            });
            /**
             * An element that represents current selection.
             *
             * @default Graphics.new()
             */
            Object.defineProperty(this, "selection", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Graphics.new(this._root, {
                    themeTags: ["selection", "cursor"], layer: 30
                }))
            });
            Object.defineProperty(this, "_movePoint", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_lastPoint", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: { x: 0, y: 0 }
            });
            Object.defineProperty(this, "_lastPoint2", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: { x: 0, y: 0 }
            });
            Object.defineProperty(this, "_tooltipX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_tooltipY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            /**
             * A chart cursor is attached to.
             */
            Object.defineProperty(this, "chart", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_toX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_toY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["xy", "cursor"]);
            super._afterNew();
            this.setAll({ "width": p100, height: p100, isMeasured: true, position: "absolute" });
            this.states.create("hidden", { visible: true, opacity: 0 });
            this._drawLines();
            this.setPrivateRaw("visible", false);
            this._disposers.push(this.setTimeout(() => {
                this.setPrivate("visible", true);
            }, 500));
            this._disposers.push(this.lineX.events.on("positionchanged", () => {
                this._handleXLine();
            }));
            this._disposers.push(this.lineY.events.on("positionchanged", () => {
                this._handleYLine();
            }));
            this._disposers.push(this.lineX.events.on("focus", () => this._handleLineFocus()));
            this._disposers.push(this.lineX.events.on("blur", () => this._handleLineBlur()));
            this._disposers.push(this.lineY.events.on("focus", () => this._handleLineFocus()));
            this._disposers.push(this.lineY.events.on("blur", () => this._handleLineBlur()));
            if (supports("keyboardevents")) {
                this._disposers.push(addEventListener(document, "keydown", (ev) => {
                    this._handleLineMove(getEventKey(ev), ev.ctrlKey);
                }));
            }
        }
        _setUpTouch() {
            const chart = this.chart;
            if (chart) {
                chart.plotContainer._display.cancelTouch = this.get("behavior") != "none" ? true : false;
            }
        }
        _handleXLine() {
            let x = this.lineX.x();
            let visible = true;
            if (x < 0 || x > this.width()) {
                visible = false;
            }
            this.lineX.setPrivate("visible", visible);
        }
        _handleYLine() {
            let y = this.lineY.y();
            let visible = true;
            if (y < 0 || y > this.height()) {
                visible = false;
            }
            this.lineY.setPrivate("visible", visible);
        }
        _handleLineMove(key, ctrlKey) {
            let dir = "";
            const chart = this.chart;
            let axis;
            if (chart && chart.xAxes.length) {
                if (this._root.focused(this.lineX)) {
                    dir = "positionX";
                    axis = chart.xAxes.getIndex(0);
                }
                else if (this._root.focused(this.lineY)) {
                    axis = chart.yAxes.getIndex(0);
                    dir = "positionY";
                }
                let m = 1;
                if (ctrlKey) {
                    m = 5;
                }
                if (axis) {
                    let inversed = axis.get("renderer").get("inversed", false);
                    let step;
                    if (key == "ArrowRight" || key == "ArrowDown") {
                        step = 1;
                    }
                    else if (key == "ArrowLeft" || key == "ArrowUp") {
                        step = -1;
                    }
                    else if (key == "Tab") {
                        step = 0;
                    }
                    if (step != null) {
                        if (inversed) {
                            step *= -1;
                        }
                        this.set(dir, axis.nextPosition(step * m));
                    }
                }
            }
        }
        _handleLineFocus() {
            this._alwaysShow = this.get("alwaysShow", false);
            this.setAll({
                positionX: this.getPrivate("positionX", 0),
                positionY: this.getPrivate("positionY", 0),
                alwaysShow: true
            });
            this._handleLineMove("Tab");
        }
        _handleLineBlur() {
            if (this.lineX.isFocus() || this.lineY.isFocus()) {
                this.setAll({
                    positionX: undefined,
                    positionY: undefined,
                    alwaysShow: this._alwaysShow
                });
            }
        }
        _prepareChildren() {
            super._prepareChildren();
            if (this.isDirty("xAxis")) {
                this._tooltipX = false;
                const xAxis = this.get("xAxis");
                if (xAxis) {
                    const tooltip = xAxis.get("tooltip");
                    if (tooltip) {
                        this._tooltipX = true;
                        this._disposers.push(tooltip.on("pointTo", () => {
                            this._updateXLine(tooltip);
                        }));
                    }
                }
            }
            if (this.isDirty("yAxis")) {
                this._tooltipY = false;
                const yAxis = this.get("yAxis");
                if (yAxis) {
                    const tooltip = yAxis.get("tooltip");
                    if (tooltip) {
                        this._tooltipY = true;
                        this._disposers.push(tooltip.on("pointTo", () => {
                            this._updateYLine(tooltip);
                        }));
                    }
                }
            }
        }
        _handleSyncWith() {
            const chart = this.chart;
            if (chart) {
                const syncWith = this.get("syncWith");
                const otherCharts = [];
                if (syncWith) {
                    each$1(syncWith, (cursor) => {
                        const chart = cursor.chart;
                        if (chart) {
                            otherCharts.push(chart);
                        }
                    });
                }
                chart._otherCharts = otherCharts;
            }
        }
        _updateChildren() {
            super._updateChildren();
            this._handleSyncWith();
            if (this.isDirty("positionX") || this.isDirty("positionY")) {
                const positionX = this.get("positionX");
                const positionY = this.get("positionY");
                if (positionX == null && positionY == null) {
                    this.hide(0);
                }
                else {
                    this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0)));
                    this.handleMove();
                }
            }
        }
        _updateXLine(tooltip) {
            let x = round$1(this._display.toLocal(tooltip.get("pointTo", { x: 0, y: 0 })).x, 3);
            if (this._toX != x) {
                this.lineX.animate({ key: "x", to: x, duration: tooltip.get("animationDuration", 0), easing: tooltip.get("animationEasing") });
                this._toX = x;
            }
        }
        _updateYLine(tooltip) {
            let y = round$1(this._display.toLocal(tooltip.get("pointTo", { x: 0, y: 0 })).y, 3);
            if (this._toY != y) {
                this.lineY.animate({ key: "y", to: y, duration: tooltip.get("animationDuration", 0), easing: tooltip.get("animationEasing") });
                this._toY = y;
            }
        }
        _drawLines() {
            this.lineX.set("draw", (display) => {
                display.moveTo(0, 0);
                display.lineTo(0, this.height());
            });
            this.lineY.set("draw", (display) => {
                display.moveTo(0, 0);
                display.lineTo(this.width(), 0);
            });
        }
        updateCursor() {
            if (this.get("alwaysShow")) {
                this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0)));
            }
            this.handleMove();
        }
        _setChart(chart) {
            this.chart = chart;
            this._handleSyncWith();
            const plotContainer = chart.plotContainer;
            this.events.on("boundschanged", () => {
                this._disposers.push(this.setTimeout(() => {
                    this.updateCursor();
                }, 50));
            });
            //this._display.interactive = true;
            if (supports("touchevents")) {
                this._disposers.push(plotContainer.events.on("click", (event) => {
                    if (isTouchEvent(event.originalEvent)) {
                        this._handleMove(event);
                    }
                }));
                this._setUpTouch();
            }
            this._disposers.push(plotContainer.events.on("pointerdown", (event) => {
                this._handleCursorDown(event);
            }));
            this._disposers.push(plotContainer.events.on("globalpointerup", (event) => {
                this._handleCursorUp(event);
                if (!event.native && !this.isHidden()) {
                    this._handleMove(event);
                }
            }));
            this._disposers.push(plotContainer.events.on("globalpointermove", (event) => {
                if (!this.get("syncWith")) {
                    if (keys(plotContainer._downPoints).length == 0 && !event.native && this.isHidden()) {
                        // Ignore mouse movement if it originates on outside element and
                        // we're not dragging.
                        return;
                    }
                }
                this._handleMove(event);
                if (Math.hypot(this._lastPoint2.x - event.point.x, this._lastPoint2.y - event.point.y) > 1) {
                    this._handleLineBlur();
                    this._lastPoint2 = event.point;
                }
            }));
            const parent = this.parent;
            if (parent) {
                parent.children.moveValue(this.selection);
            }
        }
        _inPlot(point) {
            const chart = this.chart;
            if (chart) {
                return chart.inPlot(point);
            }
            return false;
        }
        _handleCursorDown(event) {
            if (event.originalEvent.button == 2) {
                return;
            }
            const rootPoint = event.point;
            let local = this._display.toLocal(rootPoint);
            const chart = this.chart;
            this.selection.set("draw", () => { });
            if (chart && this._inPlot(local)) {
                this._downPoint = local;
                if (this.get("behavior") != "none") {
                    this.selection.show();
                    const type = "selectstarted";
                    if (this.events.isEnabled(type)) {
                        this.events.dispatch(type, { type: type, target: this, originalEvent: event.originalEvent });
                    }
                }
                let positionX = this._getPosition(local).x;
                let positionY = this._getPosition(local).y;
                this.setPrivate("downPositionX", positionX);
                this.setPrivate("downPositionY", positionY);
            }
        }
        _handleCursorUp(event) {
            // TODO: handle multitouch
            if (this._downPoint) {
                const behavior = this.get("behavior", "none");
                if (behavior != "none") {
                    if (behavior.charAt(0) === "z") {
                        this.selection.hide();
                    }
                    const rootPoint = event.point;
                    let local = this._display.toLocal(rootPoint);
                    const downPoint = this._downPoint;
                    const moveThreshold = this.get("moveThreshold", 1);
                    if (local && downPoint) {
                        let dispatch = false;
                        if (behavior === "zoomX" || behavior === "zoomXY" || behavior === "selectX" || behavior === "selectXY") {
                            if (Math.abs(local.x - downPoint.x) > moveThreshold) {
                                dispatch = true;
                            }
                        }
                        if (behavior === "zoomY" || behavior === "zoomXY" || behavior === "selectY" || behavior === "selectXY") {
                            if (Math.abs(local.y - downPoint.y) > moveThreshold) {
                                dispatch = true;
                            }
                        }
                        if (dispatch) {
                            const type = "selectended";
                            if (this.events.isEnabled(type)) {
                                this.events.dispatch(type, { type: type, target: this, originalEvent: event.originalEvent });
                            }
                        }
                        else {
                            const type = "selectcancelled";
                            if (this.events.isEnabled(type)) {
                                this.events.dispatch(type, { type: type, target: this, originalEvent: event.originalEvent });
                            }
                        }
                    }
                }
            }
            this._downPoint = undefined;
        }
        _handleMove(event) {
            if (this.getPrivate("visible")) {
                const chart = this.chart;
                if (chart && keys(chart.plotContainer._downPoints).length > 1) {
                    this.set("forceHidden", true);
                    return;
                }
                else {
                    this.set("forceHidden", false);
                }
                // TODO: handle multitouch
                const rootPoint = event.point;
                const lastPoint = this._lastPoint;
                if (Math.round(lastPoint.x) === Math.round(rootPoint.x) && Math.round(lastPoint.y) === Math.round(rootPoint.y)) {
                    return;
                }
                this._lastPoint = rootPoint;
                this.setPrivate("lastPoint", rootPoint);
                this.handleMove({ x: rootPoint.x, y: rootPoint.y }, false, event.originalEvent);
            }
        }
        _getPosition(point) {
            return { x: point.x / this.width(), y: point.y / this.height() };
        }
        /**
         * Moves the cursor to X/Y coordinates within chart container (`point`).
         *
         * If `skipEvent` parameter is set to `true`, the move will not invoke
         * the `"cursormoved"` event.
         *
         * @param  point      X/Y to move cursor to
         * @param  skipEvent  Do not fire "cursormoved" event
         */
        handleMove(point, skipEvent, originalEvent) {
            if (!point) {
                point = this._movePoint;
            }
            const alwaysShow = this.get("alwaysShow");
            if (!point) {
                this.hide(0);
                return;
            }
            this._movePoint = point;
            let local = this._display.toLocal(point);
            let chart = this.chart;
            if (chart && (this._inPlot(local) || this._downPoint)) {
                chart._movePoint = point;
                if (this.isHidden()) {
                    this.show();
                    const behavior = this.get("behavior", "");
                    if (behavior.charAt(0) == "z") {
                        this.selection.set("draw", () => { });
                    }
                }
                let x = local.x;
                let y = local.y;
                let xyPos = this._getPosition(local);
                this.setPrivate("point", local);
                let snapToSeries = this.get("snapToSeries");
                if (this._downPoint) {
                    snapToSeries = undefined;
                }
                let userPositionX = this.get("positionX");
                let positionX = xyPos.x;
                if (isNumber(userPositionX)) {
                    positionX = userPositionX;
                }
                let userPositionY = this.get("positionY");
                let positionY = xyPos.y;
                if (isNumber(userPositionY)) {
                    positionY = userPositionY;
                }
                this.setPrivate("positionX", positionX);
                this.setPrivate("positionY", positionY);
                const xy = this._getPoint(positionX, positionY);
                x = xy.x;
                y = xy.y;
                chart.xAxes.each((axis) => {
                    axis._handleCursorPosition(positionX, snapToSeries);
                    if (alwaysShow) {
                        axis.handleCursorShow();
                    }
                });
                chart.yAxes.each((axis) => {
                    axis._handleCursorPosition(positionY, snapToSeries);
                    if (alwaysShow) {
                        axis.handleCursorShow();
                    }
                });
                if (!skipEvent) {
                    chart._handleCursorPosition();
                    const type = "cursormoved";
                    if (this.events.isEnabled(type)) {
                        this.events.dispatch(type, { type: type, target: this, point: point, originalEvent: originalEvent });
                    }
                }
                this._updateLines(x, y);
                chart.arrangeTooltips();
            }
            else if (!this._downPoint) {
                if (!alwaysShow) {
                    this.hide(0);
                    const type = "cursorhidden";
                    if (this.events.isEnabled(type)) {
                        this.events.dispatch(type, { type: type, target: this });
                    }
                }
            }
            if (this._downPoint && this.get("behavior") != "none") {
                this._updateSelection(local);
            }
        }
        _getPoint(positionX, positionY) {
            return { x: this.width() * positionX, y: this.height() * positionY };
        }
        _updateLines(x, y) {
            if (!this._tooltipX) {
                this.lineX.set("x", x);
            }
            if (!this._tooltipY) {
                this.lineY.set("y", y);
            }
            this._drawLines();
        }
        _updateSelection(point) {
            const selection = this.selection;
            const behavior = this.get("behavior");
            const w = this.width();
            const h = this.height();
            if (point.x < 0) {
                point.x = 0;
            }
            if (point.x > w) {
                point.x = w;
            }
            if (point.y < 0) {
                point.y = 0;
            }
            if (point.y > h) {
                point.y = h;
            }
            selection.set("draw", (display) => {
                const downPoint = this._downPoint;
                if (downPoint) {
                    if (behavior === "zoomXY" || behavior === "selectXY") {
                        display.moveTo(downPoint.x, downPoint.y);
                        display.lineTo(downPoint.x, point.y);
                        display.lineTo(point.x, point.y);
                        display.lineTo(point.x, downPoint.y);
                        display.lineTo(downPoint.x, downPoint.y);
                    }
                    else if (behavior === "zoomX" || behavior === "selectX") {
                        display.moveTo(downPoint.x, 0);
                        display.lineTo(downPoint.x, h);
                        display.lineTo(point.x, h);
                        display.lineTo(point.x, 0);
                        display.lineTo(downPoint.x, 0);
                    }
                    else if (behavior === "zoomY" || behavior === "selectY") {
                        display.moveTo(0, downPoint.y);
                        display.lineTo(w, downPoint.y);
                        display.lineTo(w, point.y);
                        display.lineTo(0, point.y);
                        display.lineTo(0, downPoint.y);
                    }
                }
            });
        }
        _onHide() {
            if (this.isHidden()) {
                let chart = this.chart;
                if (chart) {
                    chart.xAxes.each((axis) => {
                        axis.handleCursorHide();
                    });
                    chart.yAxes.each((axis) => {
                        axis.handleCursorHide();
                    });
                    chart.series.each((series) => {
                        series.handleCursorHide();
                    });
                }
            }
            super._onHide();
        }
        _onShow() {
            if (!this.isHidden()) {
                let chart = this.chart;
                if (chart) {
                    chart.xAxes.each((axis) => {
                        axis.handleCursorShow();
                    });
                    chart.yAxes.each((axis) => {
                        axis.handleCursorShow();
                    });
                }
            }
            super._onShow();
        }
        _dispose() {
            super._dispose();
            this.selection.dispose();
        }
    }
    Object.defineProperty(XYCursor, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "XYCursor"
    });
    Object.defineProperty(XYCursor, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([XYCursor.className])
    });

    /**
     * @ignore
     */
    function min(left, right) {
        if (left == null) {
            return right;
        }
        else if (right == null) {
            return left;
        }
        else if (right < left) {
            return right;
        }
        else {
            return left;
        }
    }
    /**
     * @ignore
     */
    function max(left, right) {
        if (left == null) {
            return right;
        }
        else if (right == null) {
            return left;
        }
        else if (right > left) {
            return right;
        }
        else {
            return left;
        }
    }
    /**
     * A base class for all XY chart series.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/} for more info
     */
    class XYSeries extends Series {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_xField", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_yField", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_xOpenField", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_yOpenField", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_xLowField", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_xHighField", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_yLowField", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_yHighField", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_axesDirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_stackDirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_selectionProcessed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_dataSets", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_mainContainerMask", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_x", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_y", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_bullets", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            /**
             * A [[Container]] that us used to put series' elements in.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "mainContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Container.new(this._root, {}))
            });
            /**
             * A list of axis ranges that affect the series.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
             */
            Object.defineProperty(this, "axisRanges", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new List()
            });
            Object.defineProperty(this, "_skipped", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_couldStackTo", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_reallyStackedTo", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_stackedSeries", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_aLocationX0", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_aLocationX1", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_aLocationY0", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_aLocationY1", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_showBullets", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: true
            });
            Object.defineProperty(this, "valueXFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: [
                    "valueX",
                    "openValueX",
                    "lowValueX",
                    "highValueX"
                ]
            });
            Object.defineProperty(this, "valueYFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: [
                    "valueY",
                    "openValueY",
                    "lowValueY",
                    "highValueY"
                ]
            });
            Object.defineProperty(this, "_valueXFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_valueYFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // used for full min/max
            Object.defineProperty(this, "_valueXShowFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_valueYShowFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // used for selection (uses working)
            Object.defineProperty(this, "__valueXShowFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "__valueYShowFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_emptyDataItem", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new DataItem(this, undefined, {})
            });
            Object.defineProperty(this, "_dataSetId", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltipFieldX", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_tooltipFieldY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_posXDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_posYDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _afterNew() {
            this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY");
            this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY");
            this._setRawDefault("vcx", 1);
            this._setRawDefault("vcy", 1);
            // this can't go to themes, as data might be parsed before theme
            this._setRawDefault("valueXShow", "valueXWorking");
            this._setRawDefault("valueYShow", "valueYWorking");
            this._setRawDefault("openValueXShow", "openValueXWorking");
            this._setRawDefault("openValueYShow", "openValueYWorking");
            this._setRawDefault("lowValueXShow", "lowValueXWorking");
            this._setRawDefault("lowValueYShow", "lowValueYWorking");
            this._setRawDefault("highValueXShow", "highValueXWorking");
            this._setRawDefault("highValueYShow", "highValueYWorking");
            this._setRawDefault("lowValueXGrouped", "low");
            this._setRawDefault("lowValueYGrouped", "low");
            this._setRawDefault("highValueXGrouped", "high");
            this._setRawDefault("highValueYGrouped", "high");
            super._afterNew();
            this.set("maskContent", true);
            this._disposers.push(this.axisRanges.events.onAll((change) => {
                if (change.type === "clear") {
                    each$1(change.oldValues, (axisRange) => {
                        this._removeAxisRange(axisRange);
                    });
                }
                else if (change.type === "push") {
                    this._processAxisRange(change.newValue);
                }
                else if (change.type === "setIndex") {
                    this._processAxisRange(change.newValue);
                }
                else if (change.type === "insertIndex") {
                    this._processAxisRange(change.newValue);
                }
                else if (change.type === "removeIndex") {
                    this._removeAxisRange(change.oldValue);
                }
                else if (change.type === "moveIndex") {
                    this._processAxisRange(change.value);
                }
                else {
                    throw new Error("Unknown IStreamEvent type");
                }
            }));
            this.states.create("hidden", { opacity: 1, visible: false });
            this.onPrivate("startIndex", () => {
                this.root.events.once("frameended", () => {
                    this.updateLegendValue();
                });
            });
            this.onPrivate("endIndex", () => {
                this.root.events.once("frameended", () => {
                    this.updateLegendValue();
                });
            });
            this._makeFieldNames();
        }
        _processAxisRange(axisRange) {
            const container = Container.new(this._root, {});
            axisRange.container = container;
            this.children.push(container);
            axisRange.series = this;
            const axisDataItem = axisRange.axisDataItem;
            axisDataItem.setRaw("isRange", true);
            const axis = axisDataItem.component;
            if (axis) {
                axis._processAxisRange(axisDataItem, ["range", "series"]);
                const bullet = axisDataItem.get("bullet");
                if (bullet) {
                    const sprite = bullet.get("sprite");
                    if (sprite) {
                        sprite.setPrivate("visible", false);
                    }
                }
                const axisFill = axisDataItem.get("axisFill");
                if (axisFill) {
                    container.set("mask", axisFill);
                }
                axis._seriesAxisRanges.push(axisDataItem);
            }
        }
        _removeAxisRange(axisRange) {
            const axisDataItem = axisRange.axisDataItem;
            const axis = axisDataItem.component;
            axis.disposeDataItem(axisDataItem);
            remove(axis._seriesAxisRanges, axisDataItem);
            const container = axisRange.container;
            if (container) {
                container.dispose();
            }
        }
        _updateFields() {
            super._updateFields();
            this._valueXFields = [];
            this._valueYFields = [];
            this._valueXShowFields = [];
            this._valueYShowFields = [];
            this.__valueXShowFields = [];
            this.__valueYShowFields = [];
            if (this.valueXFields) {
                each$1(this.valueXFields, (key) => {
                    const field = this.get((key + "Field"));
                    if (field) {
                        this._valueXFields.push(key);
                        let field = this.get((key + "Show"));
                        this.__valueXShowFields.push(field);
                        if (field.indexOf("Working") != -1) {
                            this._valueXShowFields.push(field.split("Working")[0]);
                        }
                        else {
                            this._valueXShowFields.push(field);
                        }
                    }
                });
            }
            if (this.valueYFields) {
                each$1(this.valueYFields, (key) => {
                    const field = this.get((key + "Field"));
                    if (field) {
                        this._valueYFields.push(key);
                        let field = this.get((key + "Show"));
                        this.__valueYShowFields.push(field);
                        if (field.indexOf("Working") != -1) {
                            this._valueYShowFields.push(field.split("Working")[0]);
                        }
                        else {
                            this._valueYShowFields.push(field);
                        }
                    }
                });
            }
        }
        _dispose() {
            super._dispose();
            this._bullets = {};
            const chart = this.chart;
            if (chart) {
                chart.series.removeValue(this);
            }
            removeFirst(this.get("xAxis").series, this);
            removeFirst(this.get("yAxis").series, this);
        }
        // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
        _min(key, value) {
            let newValue = min(this.getPrivate(key), value);
            this.setPrivate(key, newValue);
        }
        // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
        _max(key, value) {
            let newValue = max(this.getPrivate(key), value);
            this.setPrivate(key, newValue);
        }
        _shouldMakeBullet(dataItem) {
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            if (!xAxis.inited || !yAxis.inited) {
                return false;
            }
            const minBulletDistance = this.get("minBulletDistance", 0);
            if (minBulletDistance > 0) {
                let startIndex = this.startIndex();
                let endIndex = this.endIndex();
                let count = endIndex - startIndex;
                if (xAxis == baseAxis) {
                    if (xAxis.get("renderer").axisLength() / count < minBulletDistance / 5) {
                        return false;
                    }
                }
                else if (yAxis == baseAxis) {
                    if (yAxis.get("renderer").axisLength() / count < minBulletDistance / 5) {
                        return false;
                    }
                }
            }
            if (dataItem.get(this._xField) != null && dataItem.get(this._yField) != null) {
                return true;
            }
            return false;
        }
        _makeFieldNames() {
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const xName = xAxis.getPrivate("name");
            const xCapName = capitalizeFirst(xName);
            const yName = yAxis.getPrivate("name");
            const yCapName = capitalizeFirst(yName);
            const xLetter = xAxis.get("renderer").getPrivate("letter");
            const yLetter = yAxis.get("renderer").getPrivate("letter");
            const open = "open";
            const low = "low";
            const high = "high";
            const show = "Show";
            if (xAxis.className === "ValueAxis") {
                this._xField = this.get((xName + xLetter + show));
                this._xOpenField = this.get((open + xCapName + xLetter + show));
                this._xLowField = this.get((low + xCapName + xLetter + show));
                this._xHighField = this.get((high + xCapName + xLetter + show));
            }
            else {
                this._xField = (xName + xLetter);
                this._xOpenField = (open + xCapName + xLetter);
                this._xLowField = (low + xCapName + xLetter);
                this._xHighField = (high + xCapName + xLetter);
            }
            if (yAxis.className === "ValueAxis") {
                this._yField = this.get((yName + yLetter + show));
                this._yOpenField = this.get((open + yCapName + yLetter + show));
                this._yLowField = this.get((low + yCapName + yLetter + show));
                this._yHighField = this.get((high + yCapName + yLetter + show));
            }
            else {
                this._yField = (yName + yLetter);
                this._yOpenField = (open + yCapName + yLetter);
                this._yLowField = (low + yCapName + yLetter);
                this._yHighField = (high + yCapName + yLetter);
            }
        }
        _fixVC() {
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            const hiddenState = this.states.lookup("hidden");
            const sequencedInterpolation = this.get("sequencedInterpolation");
            if (hiddenState) {
                let value = 0;
                if (sequencedInterpolation) {
                    value = 0.999999999999; // makes animate, good for stacked
                }
                if (xAxis === baseAxis) {
                    hiddenState.set("vcy", value);
                }
                else if (yAxis === baseAxis) {
                    hiddenState.set("vcx", value);
                }
                else {
                    hiddenState.set("vcy", value);
                    hiddenState.set("vcx", value);
                }
            }
        }
        _handleMaskBullets() {
            if (this.isDirty("maskBullets")) {
                this.bulletsContainer.set("maskContent", this.get("maskBullets"));
            }
        }
        _fixPosition() {
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            this.set("x", xAxis.x() - relativeToValue(xAxis.get("centerX", 0), xAxis.width()) - xAxis.parent.get("paddingLeft", 0));
            this.set("y", yAxis.y() - relativeToValue(yAxis.get("centerY", 0), yAxis.height()) - yAxis.parent.get("paddingTop", 0));
            this.bulletsContainer.set("y", this.y());
            this.bulletsContainer.set("x", this.x());
        }
        _prepareChildren() {
            super._prepareChildren();
            this._bullets = {};
            if (this.isDirty("valueYShow") || this.isDirty("valueXShow") || this.isDirty("openValueYShow") || this.isDirty("openValueXShow") || this.isDirty("lowValueYShow") || this.isDirty("lowValueXShow") || this.isDirty("highValueYShow") || this.isDirty("highValueXShow")) {
                this._updateFields();
                this._makeFieldNames();
                this._valuesDirty = true;
            }
            if (this.isDirty("xAxis") || this.isDirty("yAxis")) {
                this._valuesDirty = true;
            }
            this.set("width", this.get("xAxis").width());
            this.set("height", this.get("yAxis").height());
            this._handleMaskBullets();
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            const tooltipPositionX = this.get("tooltipPositionX");
            let tooltipFieldX;
            switch (tooltipPositionX) {
                case "open":
                    tooltipFieldX = this._xOpenField;
                    break;
                case "low":
                    tooltipFieldX = this._xLowField;
                    break;
                case "high":
                    tooltipFieldX = this._xHighField;
                    break;
                default:
                    tooltipFieldX = this._xField;
            }
            this._tooltipFieldX = tooltipFieldX;
            const tooltipPositionY = this.get("tooltipPositionY");
            let tooltipFieldY;
            switch (tooltipPositionY) {
                case "open":
                    tooltipFieldY = this._yOpenField;
                    break;
                case "low":
                    tooltipFieldY = this._yLowField;
                    break;
                case "high":
                    tooltipFieldY = this._yHighField;
                    break;
                default:
                    tooltipFieldY = this._yField;
            }
            this._tooltipFieldY = tooltipFieldY;
            if (this.isDirty("baseAxis")) {
                this._fixVC();
            }
            this._fixPosition();
            const stacked = this.get("stacked");
            if (this.isDirty("stacked")) {
                if (stacked) {
                    if (this._valuesDirty && !this._dataProcessed) ;
                    else {
                        this._stack();
                    }
                }
                else {
                    this._unstack();
                }
            }
            if (this._valuesDirty && !this._dataProcessed) {
                this._dataProcessed = true;
                if (stacked) {
                    this._stack();
                }
                each$1(this.dataItems, (dataItem) => {
                    each$1(this._valueXShowFields, (key) => {
                        let value = dataItem.get(key);
                        if (value != null) {
                            if (stacked) {
                                value += this.getStackedXValue(dataItem, key);
                            }
                            this._min("minX", value);
                            this._max("maxX", value);
                        }
                    });
                    each$1(this._valueYShowFields, (key) => {
                        let value = dataItem.get(key);
                        if (value != null) {
                            if (stacked) {
                                value += this.getStackedYValue(dataItem, key);
                            }
                            this._min("minY", value);
                            this._max("maxY", value);
                        }
                    });
                    xAxis.processSeriesDataItem(dataItem, this._valueXFields);
                    yAxis.processSeriesDataItem(dataItem, this._valueYFields);
                });
                xAxis._seriesValuesDirty = true;
                yAxis._seriesValuesDirty = true;
                if (!this.get("ignoreMinMax")) {
                    if (this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) {
                        xAxis.markDirtyExtremes();
                    }
                    if (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) {
                        yAxis.markDirtyExtremes();
                    }
                }
                this._markStakedDirtyStack();
                //this.updateLegendMarker(undefined); // causes legend marker to change color instantly when on
                if (!this.get("tooltipDataItem")) {
                    this.updateLegendValue(undefined);
                }
            }
            if (this.isDirty("vcx") || this.isDirty("vcy")) {
                this._markStakedDirtyStack();
            }
            if (!this._dataGrouped) {
                xAxis._groupSeriesData(this);
                yAxis._groupSeriesData(this);
                this._dataGrouped = true;
            }
            if (this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("adjustedStartIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._sizeDirty) {
                let startIndex = this.startIndex();
                let endIndex = this.endIndex();
                let minBulletDistance = this.get("minBulletDistance", 0);
                if (minBulletDistance > 0 && baseAxis) {
                    if (baseAxis.get("renderer").axisLength() / (endIndex - startIndex) > minBulletDistance) {
                        this._showBullets = true;
                    }
                    else {
                        this._showBullets = false;
                    }
                }
                if ((this._psi != startIndex || this._pei != endIndex || this.isDirty("vcx") || this.isDirty("vcy") || this.isPrivateDirty("adjustedStartIndex") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) {
                    this._selectionProcessed = true;
                    const vcx = this.get("vcx", 1);
                    const vcy = this.get("vcy", 1);
                    const stacked = this.get("stacked", false);
                    const outOfSelection = this.getPrivate("outOfSelection");
                    if (baseAxis === xAxis || !baseAxis) {
                        yAxis._calculateTotals();
                        this.setPrivateRaw("selectionMinY", undefined);
                        this.setPrivateRaw("selectionMaxY", undefined);
                        if (!outOfSelection) {
                            for (let i = startIndex; i < endIndex; i++) {
                                this.processYSelectionDataItem(this.dataItems[i], vcy, stacked);
                            }
                        }
                        else {
                            yAxis.markDirtySelectionExtremes();
                        }
                    }
                    if (baseAxis === yAxis || !baseAxis) {
                        xAxis._calculateTotals();
                        this.setPrivateRaw("selectionMinX", undefined);
                        this.setPrivateRaw("selectionMaxX", undefined);
                        if (!outOfSelection) {
                            for (let i = startIndex; i < endIndex; i++) {
                                this.processXSelectionDataItem(this.dataItems[i], vcx, stacked);
                            }
                        }
                        else {
                            yAxis.markDirtySelectionExtremes();
                        }
                    }
                    if (baseAxis === xAxis || !baseAxis) {
                        if (this.get("valueYShow") !== "valueYWorking") {
                            const selectionMinY = this.getPrivate("selectionMinY");
                            if (selectionMinY != null) {
                                this.setPrivateRaw("minY", selectionMinY);
                                yAxis.markDirtyExtremes();
                            }
                            const selectionMaxY = this.getPrivate("selectionMaxY");
                            if (selectionMaxY != null) {
                                this.setPrivateRaw("maxY", selectionMaxY);
                                yAxis.markDirtyExtremes();
                            }
                        }
                    }
                    if (baseAxis === yAxis || !baseAxis) {
                        if (this.get("valueXShow") !== "valueXWorking") {
                            const selectionMinX = this.getPrivate("selectionMinX");
                            if (selectionMinX != null) {
                                this.setPrivateRaw("minX", selectionMinX);
                                yAxis.markDirtyExtremes();
                            }
                            const selectionMaxX = this.getPrivate("selectionMaxX");
                            if (selectionMaxX != null) {
                                this.setPrivateRaw("maxX", selectionMaxX);
                                xAxis.markDirtyExtremes();
                            }
                        }
                    }
                    if (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) {
                        xAxis.markDirtySelectionExtremes();
                    }
                    if (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) {
                        yAxis.markDirtySelectionExtremes();
                    }
                    // this.updateLegendValue(undefined); flickers while panning
                }
            }
        }
        _makeRangeMask() {
            if (this.axisRanges.length > 0) {
                let mainContainerMask = this._mainContainerMask;
                if (mainContainerMask == null) {
                    mainContainerMask = this.children.push(Graphics.new(this._root, {}));
                    this._mainContainerMask = mainContainerMask;
                    mainContainerMask.set("draw", (display, target) => {
                        const parent = this.parent;
                        if (parent) {
                            const w = this._root.container.width();
                            const h = this._root.container.height();
                            display.moveTo(-w, -h);
                            display.lineTo(-w, h * 2);
                            display.lineTo(w * 2, h * 2);
                            display.lineTo(w * 2, -h);
                            display.lineTo(-w, -h);
                            this.axisRanges.each((axisRange) => {
                                const fill = axisRange.axisDataItem.get("axisFill");
                                if (parent) {
                                    if (fill) {
                                        let draw = fill.get("draw");
                                        if (draw) {
                                            draw(display, target);
                                        }
                                    }
                                }
                            });
                        }
                        this.mainContainer._display.mask = mainContainerMask._display;
                    });
                }
                mainContainerMask.markDirty();
                mainContainerMask._markDirtyKey("fill");
            }
            else {
                this.mainContainer._display.mask = null;
            }
        }
        _updateChildren() {
            super._updateChildren();
            // save for performance
            this._x = this.x();
            this._y = this.y();
            this._makeRangeMask();
        }
        _stack() {
            const chart = this.chart;
            if (chart) {
                const seriesIndex = chart.series.indexOf(this);
                this._couldStackTo = [];
                if (seriesIndex > 0) {
                    let series;
                    for (let i = seriesIndex - 1; i >= 0; i--) {
                        series = chart.series.getIndex(i);
                        if (series.get("xAxis") === this.get("xAxis") && series.get("yAxis") === this.get("yAxis") && series.className === this.className) {
                            this._couldStackTo.push(series);
                            if (!series.get("stacked")) {
                                break;
                            }
                        }
                    }
                }
                this._stackDataItems();
            }
        }
        _unstack() {
            each(this._reallyStackedTo, (_key, value) => {
                delete (value._stackedSeries[this.uid]);
            });
            this._reallyStackedTo = {};
            each$1(this.dataItems, (dataItem) => {
                dataItem.setRaw("stackToItemY", undefined);
                dataItem.setRaw("stackToItemX", undefined);
            });
        }
        _stackDataItems() {
            // this works only with the same number of data @todo: search by date/category?
            const baseAxis = this.get("baseAxis");
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            let field;
            let stackToItemKey;
            if (baseAxis === xAxis) {
                field = "valueY";
                stackToItemKey = "stackToItemY";
            }
            else if (baseAxis === yAxis) {
                field = "valueX";
                stackToItemKey = "stackToItemX";
            }
            let len = this._couldStackTo.length;
            let index = 0;
            const stackToNegative = this.get("stackToNegative");
            this._reallyStackedTo = {};
            each$1(this.dataItems, (dataItem) => {
                for (let s = 0; s < len; s++) {
                    let stackToSeries = this._couldStackTo[s];
                    let stackToItem = stackToSeries.dataItems[index];
                    let value = dataItem.get(field);
                    if (stackToItem) {
                        let stackValue = stackToItem.get(field);
                        if (stackToNegative) {
                            if (isNumber(value)) {
                                if (isNumber(stackValue)) {
                                    if (value >= 0 && stackValue >= 0) {
                                        dataItem.setRaw(stackToItemKey, stackToItem);
                                        this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                        stackToSeries._stackedSeries[this.uid] = this;
                                        break;
                                    }
                                    if (value < 0 && stackValue < 0) {
                                        dataItem.setRaw(stackToItemKey, stackToItem);
                                        this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                        stackToSeries._stackedSeries[this.uid] = this;
                                        break;
                                    }
                                }
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            if (isNumber(value) && isNumber(stackValue)) {
                                dataItem.setRaw(stackToItemKey, stackToItem);
                                this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                stackToSeries._stackedSeries[this.uid] = this;
                                break;
                            }
                        }
                    }
                }
                index++;
            });
        }
        processXSelectionDataItem(dataItem, vcx, stacked) {
            each$1(this.__valueXShowFields, (key) => {
                let value = dataItem.get(key);
                if (value != null) {
                    if (stacked) {
                        value += this.getStackedXValueWorking(dataItem, key);
                    }
                    this._min("selectionMinX", value);
                    this._max("selectionMaxX", value * vcx);
                }
            });
        }
        processYSelectionDataItem(dataItem, vcy, stacked) {
            each$1(this.__valueYShowFields, (key) => {
                let value = dataItem.get(key);
                if (value != null) {
                    if (stacked) {
                        value += this.getStackedYValueWorking(dataItem, key);
                    }
                    this._min("selectionMinY", value);
                    this._max("selectionMaxY", value * vcy);
                }
            });
        }
        /**
         * @ignore
         */
        getStackedYValueWorking(dataItem, key) {
            const stackToItem = dataItem.get("stackToItemY");
            if (stackToItem) {
                const stackedToSeries = stackToItem.component;
                return stackToItem.get(key, 0) * stackedToSeries.get("vcy", 1) + this.getStackedYValueWorking(stackToItem, key);
            }
            return 0;
        }
        /**
         * @ignore
         */
        getStackedXValueWorking(dataItem, key) {
            const stackToItem = dataItem.get("stackToItemX");
            if (stackToItem) {
                const stackedToSeries = stackToItem.component;
                return stackToItem.get(key, 0) * stackedToSeries.get("vcx", 1) + this.getStackedXValueWorking(stackToItem, key);
            }
            return 0;
        }
        /**
         * @ignore
         */
        getStackedYValue(dataItem, key) {
            const stackToItem = dataItem.get("stackToItemY");
            if (stackToItem) {
                return stackToItem.get(key, 0) + this.getStackedYValue(stackToItem, key);
            }
            return 0;
        }
        /**
         * @ignore
         */
        getStackedXValue(dataItem, key) {
            const stackToItem = dataItem.get("stackToItemX");
            if (stackToItem) {
                return stackToItem.get(key, 0) + this.getStackedXValue(stackToItem, key);
            }
            return 0;
        }
        /**
         * @ignore
         */
        createLegendMarker(_dataItem) {
            this.updateLegendMarker();
        }
        _markDirtyAxes() {
            this._axesDirty = true;
            this.markDirty();
        }
        _markDataSetDirty() {
            this._afterDataChange();
            this._valuesDirty = true;
            this._dataProcessed = false;
            this._aggregatesCalculated = false;
            this.markDirty();
        }
        _clearDirty() {
            super._clearDirty();
            this._axesDirty = false;
            this._selectionProcessed = false;
            this._stackDirty = false;
            this._dataProcessed = false;
        }
        _positionBullet(bullet) {
            let sprite = bullet.get("sprite");
            if (sprite) {
                let dataItem = sprite.dataItem;
                let locationX = bullet.get("locationX", dataItem.get("locationX", 0.5));
                let locationY = bullet.get("locationY", dataItem.get("locationY", 0.5));
                let xAxis = this.get("xAxis");
                let yAxis = this.get("yAxis");
                let positionX = xAxis.getDataItemPositionX(dataItem, this._xField, locationX, this.get("vcx", 1));
                let positionY = yAxis.getDataItemPositionY(dataItem, this._yField, locationY, this.get("vcy", 1));
                let point = this.getPoint(positionX, positionY);
                let left = dataItem.get("left", point.x);
                let right = dataItem.get("right", point.x);
                let top = dataItem.get("top", point.y);
                let bottom = dataItem.get("bottom", point.y);
                let x = 0;
                let y = 0;
                let w = right - left;
                let h = bottom - top;
                if (this._shouldShowBullet(positionX, positionY)) {
                    sprite.setPrivate("visible", !bullet.getPrivate("hidden"));
                    let field = bullet.get("field");
                    const baseAxis = this.get("baseAxis");
                    const xAxis = this.get("xAxis");
                    const yAxis = this.get("yAxis");
                    if (field != undefined) {
                        let realField;
                        if (baseAxis == xAxis) {
                            if (field == "value") {
                                realField = this._yField;
                            }
                            else if (field == "open") {
                                realField = this._yOpenField;
                            }
                            else if (field == "high") {
                                realField = this._yHighField;
                            }
                            else if (field == "low") {
                                realField = this._yLowField;
                            }
                            if (realField) {
                                positionY = yAxis.getDataItemPositionY(dataItem, realField, 0, this.get("vcy", 1));
                                point = yAxis.get("renderer").positionToPoint(positionY);
                                y = point.y;
                                x = left + w * locationX;
                            }
                        }
                        else {
                            if (field == "value") {
                                realField = this._xField;
                            }
                            else if (field == "open") {
                                realField = this._xOpenField;
                            }
                            else if (field == "high") {
                                realField = this._xHighField;
                            }
                            else if (field == "low") {
                                realField = this._xLowField;
                            }
                            if (realField) {
                                positionX = xAxis.getDataItemPositionX(dataItem, realField, 0, this.get("vcx", 1));
                                point = xAxis.get("renderer").positionToPoint(positionX);
                                x = point.x;
                                y = bottom - h * locationY;
                            }
                        }
                    }
                    else {
                        x = left + w * locationX;
                        y = bottom - h * locationY;
                    }
                    const stacked = bullet.get("stacked");
                    if (stacked) {
                        const chart = this.chart;
                        if (baseAxis == xAxis) {
                            let previousBullet = this._bullets[positionX + "_" + positionY];
                            if (previousBullet) {
                                let previousBounds = previousBullet.bounds();
                                let bounds = sprite.localBounds();
                                let yo = y;
                                y = previousBounds.top;
                                if (stacked == "down") {
                                    y = previousBounds.bottom - bounds.top;
                                }
                                else if (stacked == "auto") {
                                    if (chart) {
                                        if (yo < chart.plotContainer.height() / 2) {
                                            y = previousBounds.bottom - bounds.top;
                                        }
                                        else {
                                            y += bounds.bottom;
                                        }
                                    }
                                }
                                else {
                                    y += bounds.bottom;
                                }
                            }
                            this._bullets[positionX + "_" + positionY] = sprite;
                        }
                        else {
                            let previousBullet = this._bullets[positionX + "_" + positionY];
                            if (previousBullet) {
                                let previousBounds = previousBullet.bounds();
                                let bounds = sprite.localBounds();
                                let xo = x;
                                x = previousBounds.right;
                                if (stacked == "down") {
                                    x = previousBounds.left - bounds.right;
                                }
                                else if (stacked == "auto") {
                                    if (chart) {
                                        if (xo < chart.plotContainer.width() / 2) {
                                            x = previousBounds.left - bounds.right;
                                        }
                                        else {
                                            x -= bounds.left;
                                        }
                                    }
                                }
                                else {
                                    x -= bounds.left;
                                }
                            }
                            this._bullets[positionX + "_" + positionY] = sprite;
                        }
                    }
                    if (sprite.isType("Label")) {
                        sprite.setPrivate("maxWidth", Math.abs(w));
                        sprite.setPrivate("maxHeight", Math.abs(h));
                    }
                    sprite.setAll({ x, y });
                }
                else {
                    sprite.setPrivate("visible", false);
                }
            }
        }
        _shouldShowBullet(_positionX, _positionY) {
            return this._showBullets;
        }
        /**
         * @ignore
         */
        setDataSet(id) {
            if (this._dataSets[id]) {
                this._handleDataSetChange();
                this._dataItems = this._dataSets[id];
                this._markDataSetDirty();
                this._dataSetId = id;
                const type = "datasetchanged";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this, id: id });
                }
            }
        }
        /**
         * @ignore
         */
        resetGrouping() {
            each(this._dataSets, (_key, dataSet) => {
                if (dataSet != this._mainDataItems) {
                    each$1(dataSet, (dataItem) => {
                        this.disposeDataItem(dataItem);
                    });
                }
            });
            this._dataSets = {};
            this._dataItems = this.mainDataItems;
        }
        _handleDataSetChange() {
            each$1(this._dataItems, (dataItem) => {
                let bullets = dataItem.bullets;
                if (bullets) {
                    each$1(bullets, (bullet) => {
                        if (bullet) {
                            let sprite = bullet.get("sprite");
                            if (sprite) {
                                sprite.setPrivate("visible", false);
                            }
                        }
                    });
                }
            });
            this._selectionProcessed = false; // for totals to be calculated
        }
        /**
         * Shows hidden series.
         *
         * @param   duration  Duration of animation in milliseconds
         * @return            Animation promise
         */
        show(duration) {
            const _super = Object.create(null, {
                show: { get: () => super.show }
            });
            return __awaiter(this, void 0, void 0, function* () {
                this._fixVC();
                let promises = [];
                promises.push(_super.show.call(this, duration).then(() => {
                    this._isShowing = false;
                    let xAxis = this.get("xAxis");
                    let yAxis = this.get("yAxis");
                    let baseAxis = this.get("baseAxis");
                    if (yAxis !== baseAxis) {
                        yAxis.markDirtySelectionExtremes();
                    }
                    if (xAxis !== baseAxis) {
                        xAxis.markDirtySelectionExtremes();
                    }
                }));
                promises.push(this.bulletsContainer.show(duration));
                promises.push(this._sequencedShowHide(true, duration));
                yield Promise.all(promises);
            });
        }
        /**
         * Hides series.
         *
         * @param   duration  Duration of animation in milliseconds
         * @return            Animation promise
         */
        hide(duration) {
            const _super = Object.create(null, {
                hide: { get: () => super.hide }
            });
            return __awaiter(this, void 0, void 0, function* () {
                this._fixVC();
                let promises = [];
                promises.push(_super.hide.call(this, duration).then(() => {
                    this._isHiding = false;
                }));
                promises.push(this.bulletsContainer.hide(duration));
                promises.push(this._sequencedShowHide(false, duration));
                yield Promise.all(promises);
            });
        }
        /**
         * Shows series's data item.
         *
         * @param   dataItem  Data item
         * @param   duration  Animation duration in milliseconds
         * @return            Promise
         */
        showDataItem(dataItem, duration) {
            const _super = Object.create(null, {
                showDataItem: { get: () => super.showDataItem }
            });
            return __awaiter(this, void 0, void 0, function* () {
                const promises = [_super.showDataItem.call(this, dataItem, duration)];
                if (!isNumber(duration)) {
                    duration = this.get("stateAnimationDuration", 0);
                }
                const easing = this.get("stateAnimationEasing");
                each$1(this._valueFields, (key) => {
                    promises.push(dataItem.animate({ key: key + "Working", to: dataItem.get(key), duration: duration, easing: easing }).waitForStop());
                });
                yield Promise.all(promises);
            });
        }
        /**
         * Hides series's data item.
         *
         * @param   dataItem  Data item
         * @param   duration  Animation duration in milliseconds
         * @return            Promise
         */
        hideDataItem(dataItem, duration) {
            const _super = Object.create(null, {
                hideDataItem: { get: () => super.hideDataItem }
            });
            return __awaiter(this, void 0, void 0, function* () {
                const promises = [_super.hideDataItem.call(this, dataItem, duration)];
                const hiddenState = this.states.create("hidden", {});
                if (!isNumber(duration)) {
                    duration = hiddenState.get("stateAnimationDuration", this.get("stateAnimationDuration", 0));
                }
                const easing = hiddenState.get("stateAnimationEasing", this.get("stateAnimationEasing"));
                const xAxis = this.get("xAxis");
                const yAxis = this.get("yAxis");
                const baseAxis = this.get("baseAxis");
                const stacked = this.get("stacked");
                if (baseAxis === xAxis || !baseAxis) {
                    each$1(this._valueYFields, (key) => {
                        let min = yAxis.getPrivate("min");
                        let baseValue = yAxis.baseValue();
                        if (isNumber(min) && min > baseValue) {
                            baseValue = min;
                        }
                        if (stacked) {
                            baseValue = 0;
                        }
                        let value = dataItem.get(key);
                        if (value != null) {
                            promises.push(dataItem.animate({ key: key + "Working", to: baseValue, duration: duration, easing: easing }).waitForStop());
                        }
                    });
                }
                if (baseAxis === yAxis || !baseAxis) {
                    let min = xAxis.getPrivate("min");
                    let baseValue = xAxis.baseValue();
                    if (isNumber(min) && min > baseValue) {
                        baseValue = min;
                    }
                    if (stacked) {
                        baseValue = 0;
                    }
                    each$1(this._valueXFields, (key) => {
                        let value = dataItem.get(key);
                        if (value != null) {
                            promises.push(dataItem.animate({ key: key + "Working", to: baseValue, duration: duration, easing: easing }).waitForStop());
                        }
                    });
                }
                yield Promise.all(promises);
            });
        }
        _markDirtyStack() {
            this._stackDirty = true;
            this.markDirty();
            this._markStakedDirtyStack();
        }
        _markStakedDirtyStack() {
            const stackedSeries = this._stackedSeries;
            if (stackedSeries) {
                each(stackedSeries, (_key, value) => {
                    if (!value._stackDirty) {
                        value._markDirtyStack();
                    }
                });
            }
        }
        _afterChanged() {
            super._afterChanged();
            if (this._skipped) {
                this._markDirtyAxes();
                this._skipped = false;
            }
        }
        /**
         * Shows a tooltip for specific data item.
         *
         * @param  dataItem  Data item
         */
        showDataItemTooltip(dataItem) {
            if (!this.getPrivate("doNotUpdateLegend")) {
                this.updateLegendMarker(dataItem);
                this.updateLegendValue(dataItem);
            }
            const tooltip = this.get("tooltip");
            if (tooltip) {
                if (!this.isHidden() && this.get("visible")) {
                    tooltip._setDataItem(dataItem);
                    if (dataItem) {
                        let locationX = this.get("locationX", 0);
                        let locationY = this.get("locationY", 1);
                        let itemLocationX = dataItem.get("locationX", locationX);
                        let itemLocationY = dataItem.get("locationY", locationY);
                        const xAxis = this.get("xAxis");
                        const yAxis = this.get("yAxis");
                        const vcx = this.get("vcx", 1);
                        const vcy = this.get("vcy", 1);
                        const xPos = xAxis.getDataItemPositionX(dataItem, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * itemLocationX, vcx);
                        const yPos = yAxis.getDataItemPositionY(dataItem, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * itemLocationY, vcy);
                        const point = this.getPoint(xPos, yPos);
                        let show = true;
                        each$1(this._valueFields, (field) => {
                            if (dataItem.get(field) == null) {
                                show = false;
                            }
                        });
                        if (show) {
                            const chart = this.chart;
                            if (chart && chart.inPlot(point)) {
                                tooltip.label.text.markDirtyText();
                                tooltip.set("tooltipTarget", this._getTooltipTarget(dataItem));
                                tooltip.set("pointTo", this._display.toGlobal({ x: point.x, y: point.y }));
                            }
                            else {
                                tooltip._setDataItem(undefined);
                            }
                        }
                        else {
                            tooltip._setDataItem(undefined);
                        }
                    }
                }
                else {
                    this.hideTooltip();
                }
            }
        }
        hideTooltip() {
            const tooltip = this.get("tooltip");
            if (tooltip) {
                tooltip.set("tooltipTarget", this);
            }
            return super.hideTooltip();
        }
        _getTooltipTarget(dataItem) {
            if (this.get("seriesTooltipTarget") == "bullet") {
                const bullets = dataItem.bullets;
                if (bullets && bullets.length > 0) {
                    const bullet = bullets[0];
                    const sprite = bullet.get("sprite");
                    if (sprite) {
                        return sprite;
                    }
                }
            }
            return this;
        }
        /**
         * @ignore
         */
        updateLegendValue(dataItem) {
            const legendDataItem = this.get("legendDataItem");
            if (legendDataItem) {
                const label = legendDataItem.get("label");
                if (label) {
                    let txt = "";
                    if (dataItem) {
                        label._setDataItem(dataItem);
                        txt = this.get("legendLabelText", label.get("text", this.get("name", "")));
                    }
                    else {
                        label._setDataItem(this._emptyDataItem);
                        txt = this.get("legendRangeLabelText", this.get("legendLabelText", label.get("text", this.get("name", ""))));
                    }
                    label.set("text", txt);
                }
                const valueLabel = legendDataItem.get("valueLabel");
                if (valueLabel) {
                    let txt = "";
                    if (dataItem) {
                        valueLabel._setDataItem(dataItem);
                        txt = this.get("legendValueText", valueLabel.get("text", ""));
                    }
                    else {
                        valueLabel._setDataItem(this._emptyDataItem);
                        txt = this.get("legendRangeValueText", valueLabel.get("text", ""));
                    }
                    valueLabel.set("text", txt);
                }
            }
        }
        _getItemReaderLabel() {
            let text = "X: {" + this._xField;
            if (this.get("xAxis").isType("DateAxis")) {
                text += ".formatDate()";
            }
            text += "}; Y: {" + this._yField;
            if (this.get("yAxis").isType("DateAxis")) {
                text += ".formatDate()";
            }
            text += "}";
            return text;
        }
        /**
         * @ignore
         */
        getPoint(positionX, positionY) {
            let x = this.get("xAxis").get("renderer").positionToCoordinate(positionX);
            let y = this.get("yAxis").get("renderer").positionToCoordinate(positionY);
            // if coordinate is super big, canvas fails to draw line, capping to some big number (won't make any visual difference)
            let max = 999999999;
            if (y < -max) {
                y = -max;
            }
            if (y > max) {
                y = max;
            }
            if (x < -max) {
                x = -max;
            }
            if (x > max) {
                x = max;
            }
            return { x: x, y: y };
        }
        _shouldInclude(_position) {
            return true;
        }
        /**
         * @ignore
         */
        handleCursorHide() {
            this.hideTooltip();
            this.updateLegendValue(undefined);
            this.updateLegendMarker(undefined);
        }
        _afterDataChange() {
            super._afterDataChange();
            this.get("xAxis")._markDirtyKey("start");
            this.get("yAxis")._markDirtyKey("start");
            this.resetExtremes();
        }
        /**
         * Resets cached axis scale values.
         */
        resetExtremes() {
            this.setPrivate("selectionMinX", undefined);
            this.setPrivate("selectionMaxX", undefined);
            this.setPrivate("selectionMinY", undefined);
            this.setPrivate("selectionMaxY", undefined);
            this.setPrivate("minX", undefined);
            this.setPrivate("minY", undefined);
            this.setPrivate("maxX", undefined);
            this.setPrivate("maxY", undefined);
        }
        /**
         * Creates and returns an axis range object.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
         * @param   axisDataItem  Axis data item
         * @return                Axis range
         */
        createAxisRange(axisDataItem) {
            return this.axisRanges.push({
                axisDataItem: axisDataItem
            });
        }
        /**
         * A list of series's main (ungrouped) data items.
         *
         * @return  Data items
         */
        get mainDataItems() {
            return this._mainDataItems;
        }
        /**
         * @ignore
         */
        _adjustStartIndex(index) {
            const xAxis = this.get("xAxis");
            const baseAxis = this.get("baseAxis");
            if (baseAxis == xAxis && xAxis.isType("DateAxis")) {
                const baseDuration = xAxis.baseDuration();
                const minSelection = xAxis.getPrivate("selectionMin", xAxis.getPrivate("min", 0));
                const dl = baseDuration * this.get("locationX", 0.5);
                let value = -Infinity;
                while (value < minSelection) {
                    const dataItem = this.dataItems[index];
                    if (dataItem) {
                        const open = dataItem.open;
                        if (open) {
                            value = open["valueX"];
                        }
                        else {
                            value = dataItem.get("valueX", 0);
                        }
                        value += dl;
                        if (value < minSelection) {
                            index++;
                        }
                        else {
                            break;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            return index;
        }
    }
    Object.defineProperty(XYSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "XYSeries"
    });
    Object.defineProperty(XYSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Series.classNames.concat([XYSeries.className])
    });

    /**
     * Base class for all "column-based" series
     */
    class BaseColumnSeries extends XYSeries {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_ph", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_pw", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
        }
        _makeGraphics(listTemplate, dataItem) {
            return this.makeColumn(dataItem, listTemplate);
        }
        _makeFieldNames() {
            super._makeFieldNames();
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const categoryAxis = "CategoryAxis";
            const valueAxis = "ValueAxis";
            if (xAxis.isType(categoryAxis)) {
                if (!this.get("openCategoryXField")) {
                    this._xOpenField = this._xField;
                }
            }
            if (xAxis.isType(valueAxis)) {
                if (!this.get("openValueXField")) {
                    this._xOpenField = this._xField;
                }
            }
            if (yAxis.isType(categoryAxis)) {
                if (!this.get("openCategoryYField")) {
                    this._yOpenField = this._yField;
                }
            }
            if (yAxis.isType(valueAxis)) {
                if (!this.get("openValueYField")) {
                    this._yOpenField = this._yField;
                }
            }
        }
        _prepareChildren() {
            super._prepareChildren();
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const len = this.dataItems.length;
            const startIndex = Math.max(0, this.startIndex() - 2);
            const endIndex = Math.min(this.endIndex() + 2, len - 1);
            if (xAxis.inited && yAxis.inited) {
                for (let i = startIndex; i <= endIndex; i++) {
                    let dataItem = this.dataItems[i];
                    this._createGraphics(dataItem);
                }
            }
        }
        _updateChildren() {
            const chart = this.chart;
            if (chart) {
                this._ph = chart.plotContainer.height();
                this._pw = chart.plotContainer.width();
            }
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            const columnsTemplate = this.columns.template;
            if (this.isDirty("fill")) {
                if (columnsTemplate.get("fill") == null) {
                    columnsTemplate.set("fill", this.get("fill"));
                }
            }
            if (this.isDirty("fillPattern")) {
                if (columnsTemplate.get("fillPattern") == null) {
                    columnsTemplate.set("fillPattern", this.get("fillPattern"));
                }
            }
            if (this.isDirty("stroke")) {
                if (columnsTemplate.get("stroke") == null) {
                    columnsTemplate.set("stroke", this.get("stroke"));
                }
            }
            let index = 0;
            let clusterCount = 0;
            let i = 0;
            each$1(baseAxis.series, (series) => {
                if (series instanceof BaseColumnSeries) {
                    const stacked = series.get("stacked");
                    if (stacked && i == 0) {
                        clusterCount++;
                    }
                    if (!stacked && series.get("clustered")) {
                        clusterCount++;
                    }
                }
                if (series === this) {
                    index = clusterCount - 1;
                }
                i++;
            });
            if (!this.get("clustered")) {
                index = 0;
                clusterCount = 1;
            }
            if (clusterCount === 0) {
                clusterCount = 1;
                index = 0;
            }
            const xRenderer = xAxis.get("renderer");
            const yRenderer = yAxis.get("renderer");
            const cellStartLocation = "cellStartLocation";
            const cellEndLocation = "cellEndLocation";
            const cellLocationX0 = xRenderer.get(cellStartLocation, 0);
            const cellLocationX1 = xRenderer.get(cellEndLocation, 1);
            const cellLocationY0 = yRenderer.get(cellStartLocation, 0);
            const cellLocationY1 = yRenderer.get(cellEndLocation, 1);
            this._aLocationX0 = cellLocationX0 + (index / clusterCount) * (cellLocationX1 - cellLocationX0);
            this._aLocationX1 = cellLocationX0 + (index + 1) / clusterCount * (cellLocationX1 - cellLocationX0);
            this._aLocationY0 = cellLocationY0 + (index / clusterCount) * (cellLocationY1 - cellLocationY0);
            this._aLocationY1 = cellLocationY0 + (index + 1) / clusterCount * (cellLocationY1 - cellLocationY0);
            if (xAxis.inited && yAxis.inited) {
                if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) {
                    const len = this.dataItems.length;
                    let startIndex = Math.max(0, this.startIndex() - 2);
                    let endIndex = Math.min(this.endIndex() + 2, len - 1);
                    for (let i = 0; i < startIndex; i++) {
                        this._toggleColumn(this.dataItems[i], false);
                    }
                    let previous = this.dataItems[startIndex];
                    for (let i = startIndex; i <= endIndex; i++) {
                        let dataItem = this.dataItems[i];
                        if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                            previous = dataItem;
                            if (i > 0 && startIndex > 0) {
                                for (let j = i - 1; j >= 0; j--) {
                                    let dataItem = this.dataItems[j];
                                    if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                                        previous = dataItem;
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                        else {
                            this._toggleColumn(dataItem, false);
                        }
                    }
                    for (let i = startIndex; i <= endIndex; i++) {
                        let dataItem = this.dataItems[i];
                        this._updateGraphics(dataItem, previous);
                        if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                            previous = dataItem;
                        }
                    }
                    for (let i = endIndex + 1; i < len; i++) {
                        this._toggleColumn(this.dataItems[i], false);
                    }
                }
            }
            else {
                this._skipped = true;
            }
            this.updateLegendMarker(this.get("tooltipDataItem"));
            super._updateChildren();
        }
        _createGraphics(dataItem) {
            let graphics = dataItem.get("graphics");
            if (!graphics) {
                graphics = this._makeGraphics(this.columns, dataItem);
                dataItem.set("graphics", graphics);
                graphics._setDataItem(dataItem);
                const legendDataItem = dataItem.get("legendDataItem");
                if (legendDataItem) {
                    const markerRectangle = legendDataItem.get("markerRectangle");
                    if (markerRectangle) {
                        const ds = markerRectangle.states.lookup("default");
                        each$1(visualSettings, (setting) => {
                            const value = graphics.get(setting, this.get(setting));
                            markerRectangle.set(setting, value);
                            ds.set(setting, value);
                        });
                    }
                }
                let graphicsArray = dataItem.get("rangeGraphics");
                if (graphicsArray) {
                    each$1(graphicsArray, (graphics) => {
                        graphics.dispose();
                    });
                }
                graphicsArray = [];
                dataItem.setRaw("rangeGraphics", graphicsArray);
                this.axisRanges.each((axisRange) => {
                    const container = axisRange.container;
                    const rangeGraphics = this._makeGraphics(axisRange.columns, dataItem);
                    if (graphicsArray) {
                        graphicsArray.push(rangeGraphics);
                    }
                    rangeGraphics.setPrivate("list", axisRange.columns);
                    container.children.push(rangeGraphics);
                });
            }
        }
        createAxisRange(axisDataItem) {
            each$1(this.dataItems, (dataItem) => {
                const graphics = dataItem.get("graphics");
                if (graphics) {
                    graphics.dispose();
                    dataItem.set("graphics", undefined);
                }
            });
            return super.createAxisRange(axisDataItem);
        }
        _updateGraphics(dataItem, previousDataItem) {
            let graphics = dataItem.get("graphics");
            //if (!graphics) {
            //	this._createGraphics(dataItem);
            //	graphics = dataItem.get("graphics")!;
            //}
            const xField = this._xField;
            const yField = this._yField;
            const valueX = dataItem.get(xField);
            const valueY = dataItem.get(yField);
            if (valueX != null && valueY != null) {
                const xOpenField = this._xOpenField;
                const yOpenField = this._yOpenField;
                const locationX = this.get("locationX", dataItem.get("locationX", 0.5));
                const locationY = this.get("locationY", dataItem.get("locationY", 0.5));
                const openLocationX = this.get("openLocationX", dataItem.get("openLocationX", locationX));
                const openLocationY = this.get("openLocationY", dataItem.get("openLocationY", locationY));
                const width = graphics.get("width");
                const height = graphics.get("height");
                const stacked = this.get("stacked");
                const xAxis = this.get("xAxis");
                const yAxis = this.get("yAxis");
                const baseAxis = this.get("baseAxis");
                const xStart = xAxis.get("start");
                const xEnd = xAxis.get("end");
                const yStart = yAxis.get("start");
                const yEnd = yAxis.get("end");
                let l;
                let r;
                let t;
                let b;
                let vcy = this.get("vcy", 1);
                let vcx = this.get("vcx", 1);
                let fitW = false;
                let fitH = false;
                if (yAxis.isType("CategoryAxis") && xAxis.isType("CategoryAxis")) {
                    let startLocation = this._aLocationX0 + openLocationX - 0.5;
                    let endLocation = this._aLocationX1 + locationX - 0.5;
                    if (width instanceof Percent) {
                        let offset = (endLocation - startLocation) * (1 - width.value) / 2;
                        startLocation += offset;
                        endLocation -= offset;
                    }
                    l = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);
                    r = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);
                    startLocation = this._aLocationY0 + openLocationY - 0.5;
                    endLocation = this._aLocationY1 + locationY - 0.5;
                    if (height instanceof Percent) {
                        let offset = (endLocation - startLocation) * (1 - height.value) / 2;
                        startLocation += offset;
                        endLocation -= offset;
                    }
                    t = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);
                    b = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);
                    dataItem.setRaw("point", { x: l + (r - l) / 2, y: t + (b - t) / 2 });
                }
                else if (xAxis === baseAxis) {
                    let startLocation = this._aLocationX0 + openLocationX - 0.5;
                    let endLocation = this._aLocationX1 + locationX - 0.5;
                    if (width instanceof Percent) {
                        let offset = (endLocation - startLocation) * (1 - width.value) / 2;
                        startLocation += offset;
                        endLocation -= offset;
                    }
                    l = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);
                    r = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);
                    t = yAxis.getDataItemPositionY(dataItem, yField, locationY, vcy);
                    if (this._yOpenField !== this._yField) {
                        b = yAxis.getDataItemPositionY(dataItem, yOpenField, openLocationY, vcy);
                    }
                    else {
                        if (stacked) {
                            let stackToItemY = dataItem.get("stackToItemY");
                            if (stackToItemY) {
                                b = yAxis.getDataItemPositionY(stackToItemY, yField, openLocationY, stackToItemY.component.get("vcy"));
                            }
                            else {
                                b = yAxis.basePosition();
                            }
                        }
                        else {
                            b = yAxis.basePosition();
                        }
                    }
                    dataItem.setRaw("point", { x: l + (r - l) / 2, y: t });
                    fitH = true;
                }
                else if (yAxis === baseAxis) {
                    let startLocation = this._aLocationY0 + openLocationY - 0.5;
                    let endLocation = this._aLocationY1 + locationY - 0.5;
                    if (height instanceof Percent) {
                        let offset = (endLocation - startLocation) * (1 - height.value) / 2;
                        startLocation += offset;
                        endLocation -= offset;
                    }
                    t = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);
                    b = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);
                    r = xAxis.getDataItemPositionX(dataItem, xField, locationX, vcx);
                    if (this._xOpenField !== this._xField) {
                        l = xAxis.getDataItemPositionX(dataItem, xOpenField, openLocationX, vcx);
                    }
                    else {
                        if (stacked) {
                            let stackToItemX = dataItem.get("stackToItemX");
                            if (stackToItemX) {
                                l = xAxis.getDataItemPositionX(stackToItemX, xField, openLocationX, stackToItemX.component.get("vcx"));
                            }
                            else {
                                l = xAxis.basePosition();
                            }
                        }
                        else {
                            l = xAxis.basePosition();
                        }
                    }
                    fitW = true;
                    dataItem.setRaw("point", { x: r, y: t + (b - t) / 2 });
                }
                this._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);
                if ((l < xStart && r < xStart) || (l > xEnd && r > xEnd) || (t < yStart && b <= yStart) || (t >= yEnd && b > yEnd) || isNaN$1(l) || isNaN$1(t)) {
                    this._toggleColumn(dataItem, false);
                }
                else {
                    this._toggleColumn(dataItem, true);
                }
                let rangeGraphics = dataItem.get("rangeGraphics");
                if (rangeGraphics) {
                    each$1(rangeGraphics, (graphics) => {
                        this._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);
                    });
                }
                this._applyGraphicsStates(dataItem, previousDataItem);
            }
        }
        _updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH) {
            const width = graphics.get("width");
            const height = graphics.get("height");
            const maxWidth = graphics.get("maxWidth");
            const maxHeight = graphics.get("maxHeight");
            const ptl = this.getPoint(l, t);
            const pbr = this.getPoint(r, b);
            const tooltipPoint = dataItem.get("point");
            if (tooltipPoint) {
                const point = this.getPoint(tooltipPoint.x, tooltipPoint.y);
                tooltipPoint.x = point.x + this._x;
                tooltipPoint.y = point.y + this._y;
            }
            l = ptl.x;
            r = pbr.x;
            t = ptl.y;
            b = pbr.y;
            if (isNumber(width)) {
                const offset = ((r - l) - width) / 2;
                l += offset;
                r -= offset;
            }
            if (isNumber(maxWidth) && maxWidth < Math.abs(r - l)) {
                const offset = ((r - l) - maxWidth) / 2;
                l += offset;
                r -= offset;
            }
            if (isNumber(height)) {
                const offset = ((b - t) - height) / 2;
                t += offset;
                b -= offset;
            }
            if (isNumber(maxHeight) && maxHeight < Math.abs(b - t)) {
                const offset = ((b - t) - maxHeight) / 2;
                t += offset;
                b -= offset;
            }
            if (this.get("adjustBulletPosition")) {
                if (fitW) {
                    r = Math.min(Math.max(0, r), this._pw);
                    l = Math.min(Math.max(0, l), this._pw);
                }
                if (fitH) {
                    t = Math.min(Math.max(0, t), this._ph);
                    b = Math.min(Math.max(0, b), this._ph);
                }
            }
            dataItem.setRaw("left", l);
            dataItem.setRaw("right", r);
            dataItem.setRaw("top", t);
            dataItem.setRaw("bottom", b);
            graphics.setPrivate("width", r - l);
            graphics.setPrivate("height", b - t);
            graphics.set("x", l);
            graphics.set("y", b - (b - t));
        }
        _handleDataSetChange() {
            super._handleDataSetChange();
            each$1(this._dataItems, (dataItem) => {
                this._toggleColumn(dataItem, false);
            });
        }
        _applyGraphicsStates(dataItem, previousDataItem) {
            const graphics = dataItem.get("graphics");
            const dropFromOpen = graphics.states.lookup("dropFromOpen");
            const riseFromOpen = graphics.states.lookup("riseFromOpen");
            const dropFromPrevious = graphics.states.lookup("dropFromPrevious");
            const riseFromPrevious = graphics.states.lookup("riseFromPrevious");
            if (dropFromOpen || dropFromPrevious || riseFromOpen || riseFromPrevious) {
                const xAxis = this.get("xAxis");
                const yAxis = this.get("yAxis");
                const baseAxis = this.get("baseAxis");
                let open;
                let close;
                let previousClose;
                if (baseAxis === xAxis && yAxis.isType("ValueAxis")) {
                    open = dataItem.get(this._yOpenField);
                    close = dataItem.get(this._yField);
                    previousClose = previousDataItem.get(this._yField);
                }
                else if (baseAxis === yAxis && xAxis.isType("ValueAxis")) {
                    open = dataItem.get(this._xOpenField);
                    close = dataItem.get(this._xField);
                    previousClose = previousDataItem.get(this._xField);
                }
                if (isNumber(open) && isNumber(close)) {
                    if (close < open) {
                        if (dropFromOpen) {
                            dropFromOpen.apply();
                        }
                    }
                    else {
                        if (riseFromOpen) {
                            riseFromOpen.apply();
                        }
                    }
                    if (isNumber(previousClose)) {
                        if (close < previousClose) {
                            if (dropFromPrevious) {
                                dropFromPrevious.apply();
                            }
                        }
                        else {
                            if (riseFromPrevious) {
                                riseFromPrevious.apply();
                            }
                        }
                    }
                }
            }
        }
        /**
         * @ignore
         */
        disposeDataItem(dataItem) {
            super.disposeDataItem(dataItem);
            const graphics = dataItem.get("graphics");
            if (graphics) {
                this.columns.removeValue(graphics);
                graphics.dispose();
            }
            const rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                each$1(rangeGraphics, (graphics) => {
                    const list = graphics.getPrivate("list");
                    if (list) {
                        list.removeValue(graphics);
                    }
                    graphics.dispose();
                });
            }
        }
        /**
         * Hides series's data item.
         *
         * @param   dataItem  Data item
         * @param   duration  Animation duration in milliseconds
         * @return            Promise
         */
        hideDataItem(dataItem, duration) {
            const _super = Object.create(null, {
                hideDataItem: { get: () => super.hideDataItem }
            });
            return __awaiter(this, void 0, void 0, function* () {
                const promises = [_super.hideDataItem.call(this, dataItem, duration)];
                const graphics = dataItem.get("graphics");
                if (graphics) {
                    promises.push(graphics.hide(duration));
                }
                const rangeGraphics = dataItem.get("rangeGraphics");
                if (rangeGraphics) {
                    each$1(rangeGraphics, (graphics) => {
                        promises.push(graphics.hide(duration));
                    });
                }
                yield Promise.all(promises);
            });
        }
        _toggleColumn(dataItem, visible) {
            const graphics = dataItem.get("graphics");
            if (graphics) {
                graphics.setPrivate("visible", visible);
            }
            const rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                each$1(rangeGraphics, (graphics) => {
                    graphics.setPrivate("visible", visible);
                });
            }
            const bullets = dataItem.bullets;
            if (bullets) {
                each$1(bullets, (bullet) => {
                    bullet.setPrivate("hidden", !visible);
                });
            }
        }
        /**
         * Shows series's data item.
         *
         * @param   dataItem  Data item
         * @param   duration  Animation duration in milliseconds
         * @return            Promise
         */
        showDataItem(dataItem, duration) {
            const _super = Object.create(null, {
                showDataItem: { get: () => super.showDataItem }
            });
            return __awaiter(this, void 0, void 0, function* () {
                const promises = [_super.showDataItem.call(this, dataItem, duration)];
                const graphics = dataItem.get("graphics");
                if (graphics) {
                    promises.push(graphics.show(duration));
                }
                const rangeGraphics = dataItem.get("rangeGraphics");
                if (rangeGraphics) {
                    each$1(rangeGraphics, (graphics) => {
                        promises.push(graphics.show(duration));
                    });
                }
                yield Promise.all(promises);
            });
        }
        /**
         * @ignore
         */
        updateLegendMarker(dataItem) {
            let legendDataItem = this.get("legendDataItem");
            if (this.get("useLastColorForLegendMarker")) {
                if (!dataItem) {
                    const lastDataItem = this.dataItems[this.endIndex() - 1];
                    if (lastDataItem) {
                        dataItem = lastDataItem;
                    }
                }
            }
            if (legendDataItem) {
                let graphics = this.columns.template;
                if (dataItem) {
                    let column = dataItem.get("graphics");
                    if (column) {
                        graphics = column;
                    }
                }
                const markerRectangle = legendDataItem.get("markerRectangle");
                if (markerRectangle) {
                    if (!legendDataItem.get("itemContainer").get("disabled")) {
                        const ds = markerRectangle.states.lookup("default");
                        each$1(visualSettings, (setting) => {
                            const value = graphics.get(setting, this.get(setting));
                            markerRectangle.set(setting, value);
                            ds.set(setting, value);
                        });
                    }
                }
            }
        }
        _getTooltipTarget(dataItem) {
            if (this.get("seriesTooltipTarget") == "bullet") {
                return super._getTooltipTarget(dataItem);
            }
            let column = dataItem.get("graphics");
            if (column) {
                return column;
            }
            return this;
        }
    }
    Object.defineProperty(BaseColumnSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BaseColumnSeries"
    });
    Object.defineProperty(BaseColumnSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: XYSeries.classNames.concat([BaseColumnSeries.className])
    });

    /**
     * A base class for all axes.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Adding_axes} for more info
     */
    class Axis extends Component {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_series", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_isPanning", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            /**
             * Array of minor data items.
             */
            Object.defineProperty(this, "minorDataItems", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            /**
             * A [[Container]] that holds all the axis label elements.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "labelsContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Container.new(this._root, {}))
            });
            /**
             * A [[Container]] that holds all the axis grid and fill elements.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "gridContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Container.new(this._root, { width: p100, height: p100 })
            });
            /**
             * A [[Container]] that holds axis grid elements which goes above the series.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "topGridContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Container.new(this._root, { width: p100, height: p100 })
            });
            /**
             * A [[Container]] that holds all the axis bullet elements.
             *
             * @default new Container
             */
            Object.defineProperty(this, "bulletsContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Container.new(this._root, { isMeasured: false, width: p100, height: p100, position: "absolute" }))
            });
            /**
             * A referenece to the the chart the axis belongs to.
             */
            Object.defineProperty(this, "chart", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_rangesDirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_panStart", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_panEnd", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_sAnimation", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_eAnimation", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_skipSync", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            /**
             * A list of axis ranges.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
             * @default new List()
             */
            Object.defineProperty(this, "axisRanges", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new List()
            });
            Object.defineProperty(this, "_seriesAxisRanges", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            /**
             * A control label that is invisible but is used to keep width the width of
             * the axis constant.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Ghost_label} for more info
             */
            Object.defineProperty(this, "ghostLabel", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_cursorPosition", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: -1
            });
            Object.defineProperty(this, "_snapToSeries", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_seriesValuesDirty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_seriesAdded", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            /**
             * A container above the axis that can be used to add additional stuff into
             * it. For example a legend, label, or an icon.
             *
             * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info
             * @default new Container
             */
            Object.defineProperty(this, "axisHeader", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Container.new(this._root, {
                    themeTags: ["axis", "header"],
                    position: "absolute",
                    background: Rectangle.new(this._root, {
                        themeTags: ["header", "background"],
                        fill: this._root.interfaceColors.get("background")
                    })
                }))
            });
            Object.defineProperty(this, "_bullets", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
        }
        _dispose() {
            // these could be in other parents, so disposing just in case
            this.gridContainer.dispose();
            this.topGridContainer.dispose();
            this.bulletsContainer.dispose();
            this.labelsContainer.dispose();
            this.axisHeader.dispose();
            super._dispose();
        }
        _afterNew() {
            super._afterNew();
            this.setPrivate("updateScrollbar", true);
            this._disposers.push(this.axisRanges.events.onAll((change) => {
                if (change.type === "clear") {
                    each$1(change.oldValues, (dataItem) => {
                        this.disposeDataItem(dataItem);
                    });
                }
                else if (change.type === "push") {
                    this._processAxisRange(change.newValue, ["range"]);
                }
                else if (change.type === "setIndex") {
                    this._processAxisRange(change.newValue, ["range"]);
                }
                else if (change.type === "insertIndex") {
                    this._processAxisRange(change.newValue, ["range"]);
                }
                else if (change.type === "removeIndex") {
                    this.disposeDataItem(change.oldValue);
                }
                else if (change.type === "moveIndex") {
                    this._processAxisRange(change.value, ["range"]);
                }
                else {
                    throw new Error("Unknown IStreamEvent type");
                }
            }));
            const renderer = this.get("renderer");
            if (renderer) {
                renderer.axis = this;
                renderer.processAxis();
            }
            this.children.push(renderer);
            this.ghostLabel = renderer.makeLabel(new DataItem(this, undefined, {}), []);
            this.ghostLabel.adapters.disable("text");
            this.ghostLabel.setAll({ opacity: 0, tooltipText: undefined, tooltipHTML: undefined, interactive: false });
            this.ghostLabel.events.disable();
        }
        _updateFinals(_start, _end) {
        }
        /**
         * Zooms the axis to relative locations.
         *
         * Both `start` and `end` are relative: 0 means start of the axis, 1 - end.
         *
         * @param   start     Relative start
         * @param   end       Relative end
         * @param   duration  Duration of the zoom animation in milliseconds
         * @return            Zoom animation
         */
        zoom(start, end, duration, priority) {
            if (this.get("zoomable", true)) {
                this._updateFinals(start, end);
                if (this.get("start") !== start || this.get("end") != end) {
                    let sAnimation = this._sAnimation;
                    let eAnimation = this._eAnimation;
                    let maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, (end - start));
                    if (start < -maxDeviation) {
                        start = -maxDeviation;
                    }
                    if (end > 1 + maxDeviation) {
                        end = 1 + maxDeviation;
                    }
                    if (start > end) {
                        [start, end] = [end, start];
                    }
                    if (!isNumber(duration)) {
                        duration = this.get("interpolationDuration", 0);
                    }
                    if (!priority) {
                        priority = "end";
                    }
                    let maxZoomFactor = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100));
                    let maxZoomFactorReal = maxZoomFactor;
                    if (end === 1 && start !== 0) {
                        if (start < this.get("start", 0)) {
                            priority = "start";
                        }
                        else {
                            priority = "end";
                        }
                    }
                    if (start === 0 && end !== 1) {
                        if (end > this.get("end", 1)) {
                            priority = "end";
                        }
                        else {
                            priority = "start";
                        }
                    }
                    let minZoomCount = this.get("minZoomCount", 0);
                    let maxZoomCount = this.get("maxZoomCount", Infinity);
                    if (isNumber(minZoomCount)) {
                        maxZoomFactor = maxZoomFactorReal / minZoomCount;
                    }
                    let minZoomFactor = 1;
                    if (isNumber(maxZoomCount)) {
                        minZoomFactor = maxZoomFactorReal / maxZoomCount;
                    }
                    // most likely we are dragging left scrollbar grip here, so we tend to modify end
                    if (priority === "start") {
                        if (maxZoomCount > 0) {
                            // add to the end
                            if (1 / (end - start) < minZoomFactor) {
                                end = start + 1 / minZoomFactor;
                            }
                        }
                        // add to the end
                        if (1 / (end - start) > maxZoomFactor) {
                            end = start + 1 / maxZoomFactor;
                        }
                        //unless end is > 0
                        if (end > 1 && end - start < 1 / maxZoomFactor) {
                            //end = 1;
                            start = end - 1 / maxZoomFactor;
                        }
                    }
                    // most likely we are dragging right, so we modify left
                    else {
                        if (maxZoomCount > 0) {
                            // add to the end
                            if (1 / (end - start) < minZoomFactor) {
                                start = end - 1 / minZoomFactor;
                            }
                        }
                        // remove from start
                        if (1 / (end - start) > maxZoomFactor) {
                            start = end - 1 / maxZoomFactor;
                        }
                        if (start < 0 && end - start < 1 / maxZoomFactor) {
                            //start = 0;
                            end = start + 1 / maxZoomFactor;
                        }
                    }
                    if (1 / (end - start) > maxZoomFactor) {
                        end = start + 1 / maxZoomFactor;
                    }
                    if (1 / (end - start) > maxZoomFactor) {
                        start = end - 1 / maxZoomFactor;
                    }
                    if (maxZoomCount != null && minZoomCount != null && (start == this.get("start") && end == this.get("end"))) {
                        const chart = this.chart;
                        if (chart) {
                            chart._handleAxisSelection(this, true);
                        }
                    }
                    if (((sAnimation && sAnimation.playing && sAnimation.to == start) || this.get("start") == start) && ((eAnimation && eAnimation.playing && eAnimation.to == end) || this.get("end") == end)) {
                        return;
                    }
                    if (duration > 0) {
                        let easing = this.get("interpolationEasing");
                        let sAnimation, eAnimation;
                        if (this.get("start") != start) {
                            sAnimation = this.animate({ key: "start", to: start, duration: duration, easing: easing });
                        }
                        if (this.get("end") != end) {
                            eAnimation = this.animate({ key: "end", to: end, duration: duration, easing: easing });
                        }
                        this._sAnimation = sAnimation;
                        this._eAnimation = eAnimation;
                        if (sAnimation) {
                            return sAnimation;
                        }
                        else if (eAnimation) {
                            return eAnimation;
                        }
                    }
                    else {
                        this.set("start", start);
                        this.set("end", end);
                    }
                }
                else {
                    if (this._sAnimation) {
                        this._sAnimation.stop();
                    }
                    if (this._eAnimation) {
                        this._eAnimation.stop();
                    }
                }
            }
        }
        /**
         * A list of series using this axis.
         *
         * @return Series
         */
        get series() {
            return this._series;
        }
        _processAxisRange(dataItem, themeTags) {
            dataItem.setRaw("isRange", true);
            this._createAssets(dataItem, themeTags);
            this._rangesDirty = true;
            this._prepareDataItem(dataItem);
            const above = dataItem.get("above");
            const container = this.topGridContainer;
            const grid = dataItem.get("grid");
            if (above && grid) {
                container.children.moveValue(grid);
            }
            const fill = dataItem.get("axisFill");
            if (above && fill) {
                container.children.moveValue(fill);
            }
        }
        _prepareDataItem(_dataItem, _index) { }
        /**
         * @ignore
         */
        markDirtyExtremes() {
        }
        /**
         * @ignore
         */
        markDirtySelectionExtremes() {
        }
        _calculateTotals() {
        }
        _updateAxisRanges() {
            this._bullets = {};
            this.axisRanges.each((axisRange) => {
                this._prepareDataItem(axisRange);
            });
            each$1(this._seriesAxisRanges, (axisRange) => {
                this._prepareDataItem(axisRange);
            });
        }
        _prepareChildren() {
            super._prepareChildren();
            if (this.get("fixAxisSize")) {
                this.ghostLabel.set("visible", true);
            }
            else {
                this.ghostLabel.set("visible", false);
            }
            if (this.isDirty("start") || this.isDirty("end")) {
                const chart = this.chart;
                if (chart) {
                    chart._updateCursor();
                }
                let start = this.get("start", 0);
                let end = this.get("end", 1);
                let maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, (end - start));
                if (start < -maxDeviation) {
                    let delta = start + maxDeviation;
                    start = -maxDeviation;
                    this.setRaw("start", start);
                    if (this.isDirty("end")) {
                        this.setRaw("end", end - delta);
                    }
                }
                if (end > 1 + maxDeviation) {
                    let delta = end - 1 - maxDeviation;
                    end = 1 + maxDeviation;
                    this.setRaw("end", end);
                    if (this.isDirty("start")) {
                        this.setRaw("start", start - delta);
                    }
                }
            }
            const renderer = this.get("renderer");
            renderer._start = this.get("start");
            renderer._end = this.get("end");
            renderer._inversed = renderer.get("inversed", false);
            renderer._axisLength = renderer.axisLength() / (renderer._end - renderer._start);
            renderer._updateLC();
            if (this.isDirty("tooltip")) {
                const tooltip = this.get("tooltip");
                if (tooltip) {
                    const rendererTags = renderer.get("themeTags");
                    tooltip.addTag("axis");
                    tooltip.addTag(this.className.toLowerCase());
                    tooltip._applyThemes();
                    if (rendererTags) {
                        tooltip.set("themeTags", mergeTags(tooltip.get("themeTags"), rendererTags));
                        tooltip.label._applyThemes();
                    }
                }
            }
        }
        _updateTooltipBounds() {
            const tooltip = this.get("tooltip");
            if (tooltip) {
                this.get("renderer").updateTooltipBounds(tooltip);
            }
        }
        _updateBounds() {
            super._updateBounds();
            this._updateTooltipBounds();
        }
        /**
         * @ignore
         */
        processChart(chart) {
            this.chart = chart;
            const renderer = this.get("renderer");
            renderer.chart = chart;
            chart.gridContainer.children.push(this.gridContainer);
            chart.topGridContainer.children.push(this.topGridContainer);
            chart.axisHeadersContainer.children.push(this.axisHeader);
            this.on("start", () => {
                chart._handleAxisSelection(this);
            });
            this.on("end", () => {
                chart._handleAxisSelection(this);
            });
            chart.plotContainer.onPrivate("width", () => {
                this.markDirtySize();
            });
            chart.plotContainer.onPrivate("height", () => {
                this.markDirtySize();
            });
            chart.processAxis(this);
        }
        /**
         * @ignore
         */
        hideDataItem(dataItem) {
            this._toggleFHDataItem(dataItem, true);
            return super.hideDataItem(dataItem);
        }
        /**
         * @ignore
         */
        showDataItem(dataItem) {
            this._toggleFHDataItem(dataItem, false);
            return super.showDataItem(dataItem);
        }
        _toggleFHDataItem(dataItem, forceHidden) {
            const fh = "forceHidden";
            const label = dataItem.get("label");
            if (label) {
                label.set(fh, forceHidden);
            }
            const grid = dataItem.get("grid");
            if (grid) {
                grid.set(fh, forceHidden);
            }
            const tick = dataItem.get("tick");
            if (tick) {
                tick.set(fh, forceHidden);
            }
            const axisFill = dataItem.get("axisFill");
            if (axisFill) {
                axisFill.set(fh, forceHidden);
            }
            const bullet = dataItem.get("bullet");
            if (bullet) {
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.set(fh, forceHidden);
                }
            }
        }
        _toggleDataItem(dataItem, visible) {
            const label = dataItem.get("label");
            const v = "visible";
            if (label) {
                label.setPrivate(v, visible);
            }
            const grid = dataItem.get("grid");
            if (grid) {
                grid.setPrivate(v, visible);
            }
            const tick = dataItem.get("tick");
            if (tick) {
                tick.setPrivate(v, visible);
            }
            const axisFill = dataItem.get("axisFill");
            if (axisFill) {
                axisFill.setPrivate(v, visible);
            }
            const bullet = dataItem.get("bullet");
            if (bullet) {
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate(v, visible);
                }
            }
        }
        _createAssets(dataItem, tags, minor) {
            var _a, _b, _c;
            const renderer = this.get("renderer");
            let m = "minor";
            const label = dataItem.get("label");
            if (!label) {
                renderer.makeLabel(dataItem, tags);
            }
            else {
                let themeTags = label.get("themeTags");
                let remove = false;
                if (minor) {
                    if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) == -1) {
                        remove = true;
                    }
                }
                else {
                    if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) != -1) {
                        remove = true;
                    }
                }
                if (remove) {
                    (_a = label.parent) === null || _a === void 0 ? void 0 : _a.children.removeValue(label);
                    renderer.makeLabel(dataItem, tags);
                    label.dispose();
                    renderer.labels.removeValue(label);
                }
            }
            const grid = dataItem.get("grid");
            if (!grid) {
                renderer.makeGrid(dataItem, tags);
            }
            else {
                let themeTags = grid.get("themeTags");
                let remove = false;
                if (minor) {
                    if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) == -1) {
                        remove = true;
                    }
                }
                else {
                    if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) != -1) {
                        remove = true;
                    }
                }
                if (remove) {
                    (_b = grid.parent) === null || _b === void 0 ? void 0 : _b.children.removeValue(grid);
                    renderer.makeGrid(dataItem, tags);
                    grid.dispose();
                    renderer.grid.removeValue(grid);
                }
            }
            const tick = dataItem.get("tick");
            if (!tick) {
                renderer.makeTick(dataItem, tags);
            }
            else {
                let remove = false;
                let themeTags = tick.get("themeTags");
                if (minor) {
                    if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) == -1) {
                        remove = true;
                    }
                }
                else {
                    if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) != -1) {
                        remove = true;
                    }
                }
                if (remove) {
                    (_c = tick.parent) === null || _c === void 0 ? void 0 : _c.children.removeValue(tick);
                    renderer.makeTick(dataItem, tags);
                    tick.dispose();
                    renderer.ticks.removeValue(tick);
                }
            }
            if (!minor && !dataItem.get("axisFill")) {
                renderer.makeAxisFill(dataItem, tags);
            }
            this._processBullet(dataItem);
        }
        _processBullet(dataItem) {
            let bullet = dataItem.get("bullet");
            let axisBullet = this.get("bullet");
            if (!bullet && axisBullet && !dataItem.get("isRange")) {
                bullet = axisBullet(this._root, this, dataItem);
            }
            if (bullet) {
                bullet.axis = this;
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite._setDataItem(dataItem);
                    dataItem.setRaw("bullet", bullet);
                    if (!sprite.parent) {
                        this.bulletsContainer.children.push(sprite);
                    }
                }
            }
        }
        _afterChanged() {
            super._afterChanged();
            const chart = this.chart;
            if (chart) {
                chart._updateChartLayout();
                chart.axisHeadersContainer.markDirtySize();
            }
            this.get("renderer")._updatePositions();
            this._seriesAdded = false;
        }
        /**
         * @ignore
         */
        disposeDataItem(dataItem) {
            super.disposeDataItem(dataItem);
            const renderer = this.get("renderer");
            const label = dataItem.get("label");
            if (label) {
                renderer.labels.removeValue(label);
                label.dispose();
            }
            const tick = dataItem.get("tick");
            if (tick) {
                renderer.ticks.removeValue(tick);
                tick.dispose();
            }
            const grid = dataItem.get("grid");
            if (grid) {
                renderer.grid.removeValue(grid);
                grid.dispose();
            }
            const axisFill = dataItem.get("axisFill");
            if (axisFill) {
                renderer.axisFills.removeValue(axisFill);
                axisFill.dispose();
            }
            const bullet = dataItem.get("bullet");
            if (bullet) {
                bullet.dispose();
            }
        }
        _updateGhost() {
            this.setPrivate("cellWidth", this.getCellWidthPosition() * this.get("renderer").axisLength());
            const ghostLabel = this.ghostLabel;
            if (!ghostLabel.isHidden()) {
                const bounds = ghostLabel.localBounds();
                const gWidth = Math.ceil(bounds.right - bounds.left);
                let text = ghostLabel.get("text");
                each$1(this.dataItems, (dataItem) => {
                    const label = dataItem.get("label");
                    if (label && !label.isHidden()) {
                        const bounds = label.localBounds();
                        const w = Math.ceil(bounds.right - bounds.left);
                        if (w > gWidth) {
                            text = label.text._getText();
                        }
                    }
                });
                ghostLabel.set("text", text);
            }
            let start = this.get("start", 0);
            let end = this.get("end", 1);
            this.get("renderer").updateLabel(ghostLabel, start + (end - start) * 0.5);
        }
        _handleCursorPosition(position, snapToSeries) {
            const renderer = this.get("renderer");
            position = renderer.toAxisPosition(position);
            this._cursorPosition = position;
            this._snapToSeries = snapToSeries;
            this.updateTooltip();
        }
        /**
         * Can be called when axis zoom changes and you need to update tooltip
         * position.
         */
        updateTooltip() {
            const snapToSeries = this._snapToSeries;
            let position = this._cursorPosition;
            const tooltip = this.get("tooltip");
            const renderer = this.get("renderer");
            if (isNumber(position)) {
                each$1(this.series, (series) => {
                    if (series.get("baseAxis") === this) {
                        const dataItem = this.getSeriesItem(series, position, this.get("tooltipLocation"));
                        if (snapToSeries && snapToSeries.indexOf(series) != -1) {
                            series.updateLegendMarker(dataItem);
                            series.updateLegendValue(dataItem);
                            series._settings.tooltipDataItem = dataItem;
                        }
                        else {
                            series.showDataItemTooltip(dataItem);
                            series.setRaw("tooltipDataItem", dataItem);
                        }
                    }
                });
                if (this.get("snapTooltip")) {
                    position = this.roundAxisPosition(position, this.get("tooltipLocation", 0.5));
                }
                this.setPrivateRaw("tooltipPosition", position);
                if (tooltip) {
                    renderer.updateTooltipBounds(tooltip);
                    if (!isNaN$1(position)) {
                        this._updateTooltipText(tooltip, position);
                        renderer.positionTooltip(tooltip, position);
                        if (position < this.get("start", 0) || position > this.get("end", 1)) {
                            tooltip.hide(0);
                        }
                        else {
                            tooltip.show(0);
                        }
                    }
                    else {
                        tooltip.hide(0);
                    }
                }
            }
        }
        _updateTooltipText(tooltip, position) {
            tooltip.label.set("text", this.getTooltipText(position));
        }
        /**
         * @ignore
         */
        roundAxisPosition(position, _location) {
            return position;
        }
        /**
         * @ignore
         */
        handleCursorShow() {
            let tooltip = this.get("tooltip");
            if (tooltip) {
                tooltip.show();
            }
        }
        /**
         * @ignore
         */
        handleCursorHide() {
            let tooltip = this.get("tooltip");
            if (tooltip) {
                tooltip.hide();
            }
        }
        /**
         * @ignore
         */
        processSeriesDataItem(_dataItem, _fields) {
        }
        _clearDirty() {
            super._clearDirty();
            this._sizeDirty = false;
            this._rangesDirty = false;
        }
        /**
         * Converts pixel coordinate to a relative position on axis.
         *
         * @param   coordinate  Coordinate
         * @return              Relative position
         */
        coordinateToPosition(coordinate) {
            const renderer = this.get("renderer");
            return renderer.toAxisPosition(coordinate / renderer.axisLength());
        }
        /**
         * Converts relative position of the plot area to relative position of the
         * axis with zoom taken into account.
         *
         * @param position Position
         * @return Relative position
         */
        toAxisPosition(position) {
            return this.get("renderer").toAxisPosition(position);
        }
        /**
         * Converts relative position of the axis to a global position taking current
         * zoom into account (opposite to what `toAxisPosition` does).
         *
         * @since 5.4.2
         * @param position Position
         * @return Global position
         */
        toGlobalPosition(position) {
            return this.get("renderer").toGlobalPosition(position);
        }
        /**
         * Adjusts position with inversed taken into account.
         *
         * @ignore
         */
        fixPosition(position) {
            return this.get("renderer").fixPosition(position);
        }
        /**
         * @ignore
         */
        shouldGap(_dataItem, _nextItem, _autoGapCount, _fieldName) {
            return false;
        }
        /**
         * Creates and returns an axis range object.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
         * @param   axisDataItem  Axis data item
         * @return                Axis range
         */
        createAxisRange(axisDataItem) {
            return this.axisRanges.push(axisDataItem);
        }
        /**
         * @ignore
         */
        _groupSeriesData(_series) { }
        /**
         * Returns relative position between two grid lines of the axis.
         *
         * @return Position
         */
        getCellWidthPosition() {
            return 0.05;
        }
    }
    Object.defineProperty(Axis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Axis"
    });
    Object.defineProperty(Axis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Component.classNames.concat([Axis.className])
    });

    /**
     * Creates a category axis.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-axis/} for more info
     * @important
     */
    class CategoryAxis extends Axis {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_frequency", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_itemMap", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["axis"]);
            this.fields.push("category");
            this.setPrivateRaw("name", "category");
            this.addTag("category");
            super._afterNew();
        }
        _prepareChildren() {
            super._prepareChildren();
            const len = this.dataItems.length;
            let i = 0;
            if (this._valuesDirty) {
                this._itemMap = {};
                each$1(this.dataItems, (dataItem) => {
                    dataItem.setRaw("index", i);
                    this._itemMap[dataItem.get("category")] = dataItem;
                    i++;
                });
                this.setPrivateRaw("maxZoomFactor", len);
            }
            this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * len), 0));
            this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * len), len));
            if (this._sizeDirty || this._valuesDirty || (this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height"))) {
                if (this.dataItems.length > 0) {
                    this._handleRangeChange();
                    this._prepareAxisItems();
                    this._updateAxisRanges();
                }
            }
        }
        _handleRangeChange() {
            each$1(this.series, (series) => {
                let startCategory = this.dataItems[this.startIndex()].get("category");
                let endCategory = this.dataItems[this.endIndex() - 1].get("category");
                let baseAxis = series.get("baseAxis");
                let xAxis = series.get("xAxis");
                let yAxis = series.get("yAxis");
                if (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {
                    series._markDirtyAxes();
                }
                else if (baseAxis === this) {
                    let key;
                    let openKey;
                    let otherAxis = yAxis;
                    if (xAxis === baseAxis) {
                        if (series.get("categoryXField")) {
                            key = "categoryX";
                        }
                        if (series.get("openCategoryXField")) {
                            openKey = "openCategoryX";
                        }
                    }
                    else if (yAxis === baseAxis) {
                        if (series.get("categoryYField")) {
                            key = "categoryY";
                        }
                        if (series.get("openCategoryYField")) {
                            openKey = "openCategoryY";
                        }
                        otherAxis = xAxis;
                    }
                    if (otherAxis.className == "ValueAxis") {
                        if (key || openKey) {
                            let startDataItem;
                            let endDataItem;
                            for (let i = 0, len = series.dataItems.length; i < len; i++) {
                                let dataItem = series.dataItems[i];
                                if (key) {
                                    if (dataItem.get(key) === startCategory) {
                                        startDataItem = dataItem;
                                        break;
                                    }
                                }
                                if (openKey) {
                                    if (dataItem.get(openKey) === startCategory) {
                                        startDataItem = dataItem;
                                        break;
                                    }
                                }
                            }
                            for (let i = series.dataItems.length - 1; i >= 0; i--) {
                                let dataItem = series.dataItems[i];
                                if (key) {
                                    if (dataItem.get(key) === endCategory) {
                                        endDataItem = dataItem;
                                        break;
                                    }
                                }
                                if (openKey) {
                                    if (dataItem.get(openKey) === endCategory) {
                                        endDataItem = dataItem;
                                        break;
                                    }
                                }
                            }
                            let startIndex = 0;
                            let endIndex = series.dataItems.length;
                            if (startDataItem) {
                                startIndex = series.dataItems.indexOf(startDataItem);
                            }
                            if (endDataItem) {
                                endIndex = series.dataItems.indexOf(endDataItem) + 1;
                            }
                            series.setPrivate("startIndex", startIndex);
                            series.setPrivate("endIndex", endIndex);
                            let hasValue = false;
                            for (let i = startIndex; i < endIndex; i++) {
                                const dataItem = series.dataItems[i];
                                each$1(series.__valueXShowFields, (key) => {
                                    let value = dataItem.get(key);
                                    if (value != null) {
                                        hasValue = true;
                                    }
                                });
                                each$1(series.__valueYShowFields, (key) => {
                                    let value = dataItem.get(key);
                                    if (value != null) {
                                        hasValue = true;
                                    }
                                });
                                if (hasValue) {
                                    break;
                                }
                            }
                            series.setPrivate("outOfSelection", !hasValue);
                        }
                    }
                    series._markDirtyAxes(); // must be outside
                }
            });
        }
        _prepareAxisItems() {
            var _a;
            const renderer = this.get("renderer");
            const len = this.dataItems.length;
            let startIndex = this.startIndex();
            if (startIndex > 0) {
                startIndex--;
            }
            let endIndex = this.endIndex();
            if (endIndex < len) {
                endIndex++;
            }
            const minorLabelsEnabled = renderer.get("minorLabelsEnabled");
            const minorGridEnabled = renderer.get("minorGridEnabled", minorLabelsEnabled);
            let maxCount = renderer.axisLength() / Math.max(renderer.get("minGridDistance"), 1);
            let frequency = Math.max(1, Math.min(len, Math.ceil((endIndex - startIndex) / maxCount)));
            startIndex = Math.floor(startIndex / frequency) * frequency;
            this._frequency = frequency;
            for (let j = 0; j < len; j++) {
                this._toggleDataItem(this.dataItems[j], false);
            }
            let f = this.dataItems[startIndex].get("index", 0);
            for (let i = startIndex; i < endIndex; i = i + frequency) {
                let dataItem = this.dataItems[i];
                this._createAssets(dataItem, []);
                this._toggleDataItem(dataItem, true);
                let count = frequency;
                if (minorGridEnabled) {
                    count = 1;
                }
                this._prepareDataItem(dataItem, f, count);
                f++;
            }
            if (renderer.get("minorGridEnabled")) {
                for (let i = startIndex; i < endIndex; i++) {
                    let dataItem = this.dataItems[i];
                    if (i % frequency != 0) {
                        this._createAssets(dataItem, ["minor"], true);
                        this._toggleDataItem(dataItem, true);
                        this._prepareDataItem(dataItem, 0, 1);
                        if (!minorLabelsEnabled) {
                            (_a = dataItem.get("label")) === null || _a === void 0 ? void 0 : _a.setPrivate("visible", false);
                        }
                    }
                }
            }
            this._updateGhost();
        }
        _prepareDataItem(dataItem, fillIndex, count) {
            let renderer = this.get("renderer");
            let categoryLocation = dataItem.get("categoryLocation", 0);
            let endCategoryLocation = dataItem.get("endCategoryLocation", 1);
            let index = dataItem.get("index");
            if (!isNumber(index)) {
                index = this.categoryToIndex(dataItem.get("category"));
            }
            let position = this.indexToPosition(index, categoryLocation);
            let endCategory = dataItem.get("endCategory");
            let endIndex;
            if (endCategory) {
                endIndex = this.categoryToIndex(endCategory);
                if (!isNumber(endIndex)) {
                    endIndex = index;
                }
            }
            else {
                endIndex = index;
            }
            let endPosition = this.indexToPosition(endIndex, endCategoryLocation);
            let fillEndIndex;
            let fillEndPosition;
            if (dataItem.get("isRange")) {
                fillEndIndex = endIndex;
            }
            else {
                fillEndIndex = index + this._frequency - 1;
            }
            fillEndPosition = this.indexToPosition(fillEndIndex, endCategoryLocation);
            renderer.updateLabel(dataItem.get("label"), position, endPosition, count);
            renderer.updateGrid(dataItem.get("grid"), position, endPosition);
            renderer.updateTick(dataItem.get("tick"), position, endPosition, count);
            renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);
            this._processBullet(dataItem);
            renderer.updateBullet(dataItem.get("bullet"), position, endPosition);
            const fillRule = this.get("fillRule");
            if (fillRule) {
                fillRule(dataItem, fillIndex);
            }
        }
        startIndex() {
            let len = this.dataItems.length;
            return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), len - 1);
        }
        endIndex() {
            let len = this.dataItems.length;
            return Math.max(1, Math.min(this.getPrivate("endIndex", len), len));
        }
        /**
         * @ignore
         */
        baseValue() {
        }
        /**
         * @ignore
         */
        basePosition() {
            return 0;
        }
        /**
         * Returns X coordinate in pixels corresponding to specific category index.
         *
         * @param   value  Index
         * @return         X coordinate
         */
        getX(value) {
            let axisDataItem = this._itemMap[value];
            if (axisDataItem) {
                return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));
            }
            return NaN;
        }
        /**
         * Returns Y coordinate in pixels corresponding to specific category index.
         *
         * @param   value  Index
         * @return         Y coordinate
         */
        getY(value) {
            let axisDataItem = this._itemMap[value];
            if (axisDataItem) {
                return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));
            }
            return NaN;
        }
        /**
         * @ignore
         */
        getDataItemPositionX(dataItem, field, cellLocation, _axisLocation) {
            const category = dataItem.get(field);
            const axisDataItem = this._itemMap[category];
            if (axisDataItem) {
                return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);
            }
            return NaN;
        }
        /**
         * @ignore
         */
        getDataItemCoordinateX(dataItem, field, cellLocation, _axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, _axisLocation));
        }
        /**
         * @ignore
         */
        getDataItemPositionY(dataItem, field, cellLocation, _axisLocation) {
            const category = dataItem.get(field);
            const axisDataItem = this._itemMap[category];
            if (axisDataItem) {
                return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);
            }
            return NaN;
        }
        /**
         * @ignore
         */
        getDataItemCoordinateY(dataItem, field, cellLocation, _axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, _axisLocation));
        }
        /**
         * Converts category index to a relative position.
         *
         * `location` indicates relative position within category: 0 - start, 1 - end.
         *
         * If not set, will use middle (0.5) of the category.
         *
         * @param   index     Index
         * @param   location  Location
         * @return            Index
         */
        indexToPosition(index, location) {
            if (!isNumber(location)) {
                location = 0.5;
            }
            let len = this.dataItems.length;
            let startLocation = this.get("startLocation", 0);
            let endLocation = this.get("endLocation", 1);
            len -= startLocation;
            len -= (1 - endLocation);
            let position = (index + location - startLocation) / len;
            let dataItem = this.dataItems[index];
            if (dataItem) {
                position += dataItem.get("deltaPosition", 0);
            }
            return position;
        }
        /**
         * Returns an index of a category.
         *
         * @param   category  Category to look up
         * @return            Index
         */
        categoryToIndex(category) {
            let dataItem = this._itemMap[category];
            if (dataItem) {
                return dataItem.get("index");
            }
            return NaN;
        }
        /**
         * @ignore
         */
        dataItemToPosition(dataItem) {
            return this.indexToPosition(dataItem.get("index"));
        }
        /**
         * @ignore
         */
        roundAxisPosition(position, location) {
            position += (0.5 - location) / this.dataItems.length;
            return this.indexToPosition(this.axisPositionToIndex(position), location);
        }
        /**
         * Returns an index of the category that corresponds to specific pixel
         * position within axis.
         *
         * @param position  Position (px)
         * @return Category index
         */
        axisPositionToIndex(position) {
            let len = this.dataItems.length;
            return fitToRange(Math.floor(position * len), 0, len - 1); //$math.fitToRange(Math.floor((end - start) * len * position + len * start), 0, len - 1);
        }
        /**
         * Returns text to be used in an axis tooltip for specific relative position.
         *
         * @param   position  Position
         * @return            Tooltip text
         */
        getTooltipText(position, _adjustPosition) {
            //@todo number formatter + tag
            const dataItem = this.dataItems[this.axisPositionToIndex(position)];
            if (dataItem) {
                const label = dataItem.get("label");
                if (label) {
                    return populateString(label, this.get("tooltipText", ""));
                }
            }
        }
        _updateTooltipText(tooltip, position) {
            tooltip._setDataItem(this.dataItems[this.axisPositionToIndex(position)]);
            tooltip.label.text.markDirtyText();
        }
        /**
         * Returns a data item from series that is closest to the `position`.
         *
         * @param   series    Series
         * @param   position  Relative position
         * @return            Data item
         */
        getSeriesItem(series, position) {
            if (this.dataItems.length > 0) {
                let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
                let index = this.axisPositionToIndex(position);
                // try simple first
                let seriesDataItem = series.dataItems[index];
                let axisDataItem = this.dataItems[index];
                let category = axisDataItem.get("category");
                if (seriesDataItem && axisDataItem) {
                    if (seriesDataItem.get(fieldName) === category) {
                        return seriesDataItem;
                    }
                }
                // if not found, try looking
                for (let i = 0, len = series.dataItems.length; i < len; i++) {
                    let dataItem = series.dataItems[i];
                    if (dataItem.get(fieldName) === category) {
                        return dataItem;
                    }
                }
            }
        }
        /**
         * Zooms the axis to specific `start` and `end` indexes.
         *
         * Optional `duration` specifies duration of zoom animation in milliseconds.
         *
         * @param  start     Start index
         * @param  end       End index
         * @param  duration  Duration in milliseconds
         */
        zoomToIndexes(start, end, duration) {
            let len = this.dataItems.length;
            this.zoom(start / len, end / len, duration);
        }
        zoomToCategories(startCategory, endCategory, duration) {
            this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1, duration);
        }
        /**
         * Returns position span between start and end of a single cell in axis.
         *
         * @since 5.2.30
         * @return Position
         */
        getCellWidthPosition() {
            return this._frequency / this.dataItems.length / (this.get("end", 1) - this.get("start", 0));
        }
        /**
         * @ignore
         */
        nextPosition(count) {
            if (count == null) {
                count = 1;
            }
            if (this.get("renderer").getPrivate("letter") == "Y") {
                count *= -1;
            }
            const position = this.getPrivate("tooltipPosition", 0);
            const index = fitToRange(this.axisPositionToIndex(position) + count, 0, this.dataItems.length - 1);
            return this.toGlobalPosition(this.indexToPosition(index));
        }
    }
    Object.defineProperty(CategoryAxis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CategoryAxis"
    });
    Object.defineProperty(CategoryAxis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Axis.classNames.concat([CategoryAxis.className])
    });

    /**
     * Category-based date axis.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-date-axis/} for more info
     * @important
     */
    class CategoryDateAxis extends CategoryAxis {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_frequency", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_itemMap", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["axis"]);
            this.fields.push("category");
            super._afterNew();
        }
        _prepareAxisItems() {
            // temp
            this.setPrivateRaw("baseInterval", this.get("baseInterval"));
            const renderer = this.get("renderer");
            const len = this.dataItems.length;
            let startIndex = this.startIndex();
            if (startIndex > 0) {
                startIndex--;
            }
            let endIndex = this.endIndex();
            if (endIndex < len) {
                endIndex++;
            }
            let maxCount = renderer.axisLength() / Math.max(renderer.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER);
            let frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));
            startIndex = Math.floor(startIndex / frequency) * frequency;
            this._frequency = frequency;
            for (let j = 0; j < len; j++) {
                this._toggleDataItem(this.dataItems[j], false);
            }
            let startTime = Number(this.dataItems[startIndex].get("category"));
            let endTime = Number(this.dataItems[endIndex - 1].get("category"));
            let realDuration = (endTime - startTime);
            if (endIndex - startIndex < maxCount) {
                realDuration = (endTime - startTime) - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();
            }
            // if all items are on axis
            let gridInterval = chooseInterval(0, realDuration, maxCount, this.get("gridIntervals"));
            const nextGridUnit = getNextUnit(gridInterval.timeUnit);
            const baseInterval = this.getPrivate("baseInterval");
            if (getIntervalDuration(gridInterval) < this.baseDuration()) {
                gridInterval = Object.assign({}, baseInterval);
            }
            const formats = this.get("dateFormats");
            let previousValue = -Infinity;
            let previousIndex = -Infinity;
            let previousUnitValue = -Infinity;
            let format;
            let selectedItems = [];
            let changed = false;
            for (let i = startIndex; i < endIndex; i++) {
                let dataItem = this.dataItems[i];
                let index = dataItem.get("index");
                let skip = false;
                let value = Number(dataItem.get("category"));
                let date = new Date(value);
                let unitValue = getUnitValue(date, gridInterval.timeUnit);
                format = formats[gridInterval.timeUnit];
                let added = false;
                if (gridInterval.timeUnit != "year" && gridInterval.timeUnit != "week") {
                    if (nextGridUnit && this.get("markUnitChange") && isNumber(previousValue)) {
                        if (checkChange(value, previousValue, nextGridUnit, this._root.utc)) {
                            format = this.get("periodChangeDateFormats")[gridInterval.timeUnit];
                            if (index - frequency * 0.5 < previousIndex) {
                                selectedItems.pop();
                            }
                            selectedItems.push({ format: format, dataItem: dataItem });
                            changed = true;
                            added = true;
                            previousIndex = index;
                            previousUnitValue = unitValue;
                        }
                    }
                }
                let shouldAdd = false;
                if (gridInterval.timeUnit === "day" || gridInterval.timeUnit === "week") {
                    if (index - previousIndex >= frequency) {
                        shouldAdd = true;
                    }
                }
                else {
                    if (unitValue % gridInterval.count === 0) {
                        if (unitValue != previousUnitValue) {
                            shouldAdd = true;
                        }
                    }
                }
                if (!added && shouldAdd) {
                    if (index - frequency * 0.7 < previousIndex) {
                        if (changed) {
                            skip = true;
                        }
                    }
                    if (!skip) {
                        selectedItems.push({ format: format, dataItem: dataItem });
                        previousIndex = index;
                        previousUnitValue = unitValue;
                    }
                    changed = false;
                }
                previousValue = value;
            }
            if (selectedItems.length > 0) {
                let f = selectedItems[0].dataItem.get("index", 0);
                each$1(selectedItems, (item) => {
                    const dataItem = item.dataItem;
                    const format = item.format;
                    this._createAssets(dataItem, []);
                    this._toggleDataItem(dataItem, true);
                    let value = Number(dataItem.get("category"));
                    let date = new Date(value);
                    const label = dataItem.get("label");
                    if (label) {
                        label.set("text", this._root.dateFormatter.format(date, format));
                    }
                    f++;
                    this._prepareDataItem(dataItem, f, frequency);
                });
            }
        }
        /**
         * Returns a duration of currently active `baseInterval` in milliseconds.
         *
         * @return Duration
         */
        baseDuration() {
            return getIntervalDuration(this.getPrivate("baseInterval"));
        }
        /**
         * Returns text to be used in an axis tooltip for specific relative position.
         *
         * @param   position  Position
         * @return            Tooltip text
         */
        getTooltipText(position, _adjustPosition) {
            //@todo number formatter + tag
            let dataItem = this.dataItems[this.axisPositionToIndex(position)];
            if (dataItem) {
                let format = this.get("dateFormats")[this.getPrivate("baseInterval").timeUnit];
                return this._root.dateFormatter.format(new Date(dataItem.get("category", 0)), this.get("tooltipDateFormat", format));
            }
        }
        _updateTooltipText(tooltip, position) {
            tooltip.label.set("text", this.getTooltipText(position));
        }
    }
    Object.defineProperty(CategoryDateAxis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CategoryDateAxis"
    });
    Object.defineProperty(CategoryDateAxis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: CategoryAxis.classNames.concat([CategoryDateAxis.className])
    });

    /**
     * Creates a value axis.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info
     * @important
     */
    class ValueAxis extends Axis {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_dirtyExtremes", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_dirtySelectionExtremes", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_dseHandled", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_deltaMinMax", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_minReal", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_maxReal", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_minRealLog", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_baseValue", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_syncDp", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_minLogAdjusted", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
        }
        /**
         * @ignore
         */
        markDirtyExtremes() {
            this._dirtyExtremes = true;
            this.markDirty();
        }
        /**
         * @ignore
         */
        markDirtySelectionExtremes() {
            this._dirtySelectionExtremes = true;
            this.markDirty();
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["axis"]);
            this.setPrivateRaw("name", "value");
            this.addTag("value");
            super._afterNew();
        }
        _prepareChildren() {
            super._prepareChildren();
            if (this.isDirty("syncWithAxis")) {
                let previousValue = this._prevSettings.syncWithAxis;
                if (previousValue) {
                    if (this._syncDp) {
                        this._syncDp.dispose();
                    }
                }
                let syncWithAxis = this.get("syncWithAxis");
                if (syncWithAxis) {
                    this._syncDp = new MultiDisposer([
                        syncWithAxis.onPrivate("selectionMinFinal", () => {
                            this._dirtySelectionExtremes = true;
                        }),
                        syncWithAxis.onPrivate("selectionMaxFinal", () => {
                            this._dirtySelectionExtremes = true;
                        })
                    ]);
                }
            }
            let someDirty = false;
            if (this.isDirty("min") || this.isDirty("max") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) {
                someDirty = true;
                this.ghostLabel.set("text", "");
            }
            //if (this._dirtyExtremes || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("maxPrecision")) {
            if (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || someDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("strictMinMaxSelection")) {
                this._getMinMax();
                this._dirtyExtremes = false;
            }
            this._handleSizeDirty();
            if (this._dirtySelectionExtremes && !this._isPanning && this.get("autoZoom", true)) {
                const chart = this.chart;
                let getMM = false;
                // #1563
                if (chart) {
                    const letter = this.get("renderer").getPrivate("letter");
                    if (letter == "Y") {
                        chart.xAxes.each((axis) => {
                            if (axis.className != "ValueAxis") {
                                getMM = true;
                            }
                        });
                    }
                    else if (letter == "X") {
                        chart.yAxes.each((axis) => {
                            if (axis.className != "ValueAxis") {
                                getMM = true;
                            }
                        });
                    }
                }
                if (getMM) {
                    this._getSelectionMinMax();
                }
                this._dirtySelectionExtremes = false;
            }
            this._groupData();
            if (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) {
                this._handleRangeChange();
                this._prepareAxisItems();
                this._updateAxisRanges();
            }
            this._baseValue = this.baseValue();
        }
        _handleSizeDirty() {
            if (this._sizeDirty && !this._dseHandled) {
                this._dirtySelectionExtremes = true;
                this._dseHandled = true;
            }
        }
        _clearDirty() {
            super._clearDirty();
            this._dseHandled = false;
        }
        _groupData() {
        }
        _formatText(value) {
            const numberFormat = this.get("numberFormat");
            const formatter = this.getNumberFormatter();
            let text = "";
            if (numberFormat) {
                text = formatter.format(value, numberFormat);
            }
            else {
                text = formatter.format(value, undefined, this.getPrivate("stepDecimalPlaces"));
            }
            return text;
        }
        _prepareAxisItems() {
            const min = this.getPrivate("min");
            const max = this.getPrivate("max");
            if (isNumber(min) && isNumber(max)) {
                const logarithmic = this.get("logarithmic");
                const step = this.getPrivate("step");
                const selectionMin = this.getPrivate("selectionMin");
                const selectionMax = this.getPrivate("selectionMax") + step;
                let value = selectionMin - step;
                let differencePower = 1;
                let minLog = min;
                if (logarithmic) {
                    value = this._minLogAdjusted;
                    if (value < selectionMin) {
                        while (value < selectionMin) {
                            value += step;
                        }
                    }
                    minLog = value;
                    if (minLog <= 0) {
                        minLog = 1;
                        if (step < 1) {
                            if (isNumber(this._minRealLog)) {
                                minLog = this._minRealLog;
                            }
                            else {
                                minLog = Math.pow(10, -50);
                            }
                        }
                    }
                    differencePower = Math.log(selectionMax - step) * Math.LOG10E - Math.log(minLog) * Math.LOG10E;
                    if (differencePower > 2) {
                        value = Math.pow(10, Math.log(minLog) * Math.LOG10E - 50);
                    }
                }
                /// minor grid
                const renderer = this.get("renderer");
                const minorLabelsEnabled = renderer.get("minorLabelsEnabled");
                const minorGridEnabled = renderer.get("minorGridEnabled", minorLabelsEnabled);
                let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
                const stepAdjusted = Math.round(step / stepPower);
                let minorGridCount = 2;
                if (round$1(stepAdjusted / 5, 10) % 1 == 0) {
                    minorGridCount = 5;
                }
                if (round$1(stepAdjusted / 10, 10) % 1 == 0) {
                    minorGridCount = 10;
                }
                let minorStep = step / minorGridCount;
                // end of minor grid
                let i = 0;
                let m = 0;
                let previous = -Infinity;
                while (value < selectionMax) {
                    let dataItem;
                    if (this.dataItems.length < i + 1) {
                        dataItem = new DataItem(this, undefined, {});
                        this._dataItems.push(dataItem);
                        this.processDataItem(dataItem);
                    }
                    else {
                        dataItem = this.dataItems[i];
                    }
                    this._createAssets(dataItem, []);
                    this._toggleDataItem(dataItem, true);
                    dataItem.setRaw("value", value);
                    const label = dataItem.get("label");
                    if (label) {
                        label.set("text", this._formatText(value));
                    }
                    this._prepareDataItem(dataItem);
                    let nextValue = value;
                    if (!logarithmic) {
                        nextValue += step;
                    }
                    else {
                        if (differencePower > 2) {
                            nextValue = Math.pow(10, Math.log(minLog) * Math.LOG10E + i - 50);
                        }
                        else {
                            nextValue += step;
                        }
                    }
                    // minor grid
                    if (minorGridEnabled) {
                        let minorValue = value + minorStep;
                        if (logarithmic) {
                            if (differencePower > 2) {
                                let minorMinMaxStep = this._adjustMinMax(value, nextValue, 10);
                                minorStep = minorMinMaxStep.step;
                            }
                            minorValue = value + minorStep;
                        }
                        while (minorValue < nextValue - step * 0.00000000001) {
                            let minorDataItem;
                            if (this.minorDataItems.length < m + 1) {
                                minorDataItem = new DataItem(this, undefined, {});
                                this.minorDataItems.push(minorDataItem);
                                this.processDataItem(minorDataItem);
                            }
                            else {
                                minorDataItem = this.minorDataItems[m];
                            }
                            this._createAssets(minorDataItem, ["minor"], true);
                            this._toggleDataItem(minorDataItem, true);
                            minorDataItem.setRaw("value", minorValue);
                            const minorLabel = minorDataItem.get("label");
                            if (minorLabel) {
                                if (minorLabelsEnabled) {
                                    minorLabel.set("text", this._formatText(minorValue));
                                }
                                else {
                                    minorLabel.setPrivate("visible", false);
                                }
                            }
                            this._prepareDataItem(minorDataItem);
                            minorValue += minorStep;
                            m++;
                        }
                    }
                    value = nextValue;
                    if (previous == value) {
                        break;
                    }
                    let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
                    if (stepPower < 1 && !logarithmic) {
                        // exponent is less then 1 too. Count decimals of exponent
                        let decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;
                        // round value to avoid floating point issues
                        value = round$1(value, decCount);
                    }
                    i++;
                    previous = value;
                }
                for (let j = i; j < this.dataItems.length; j++) {
                    this._toggleDataItem(this.dataItems[j], false);
                }
                for (let j = m; j < this.minorDataItems.length; j++) {
                    this._toggleDataItem(this.minorDataItems[j], false);
                }
                each$1(this.series, (series) => {
                    if (series.inited) {
                        series._markDirtyAxes();
                    }
                });
                this._updateGhost();
            }
        }
        _prepareDataItem(dataItem, count) {
            let renderer = this.get("renderer");
            let value = dataItem.get("value");
            let endValue = dataItem.get("endValue");
            let position = this.valueToPosition(value);
            let endPosition = position;
            let fillEndPosition = this.valueToPosition(value + this.getPrivate("step"));
            if (isNumber(endValue)) {
                endPosition = this.valueToPosition(endValue);
                fillEndPosition = endPosition;
            }
            if (dataItem.get("isRange")) {
                if (endValue == null) {
                    fillEndPosition = position;
                }
            }
            let labelEndPosition = endPosition;
            let labelEndValue = dataItem.get("labelEndValue");
            if (labelEndValue != null) {
                labelEndPosition = this.valueToPosition(labelEndValue);
            }
            renderer.updateLabel(dataItem.get("label"), position, labelEndPosition, count);
            const grid = dataItem.get("grid");
            renderer.updateGrid(grid, position, endPosition);
            if (grid) {
                if (value == this.get("baseValue", 0)) {
                    grid.addTag("base");
                    grid._applyThemes();
                }
                else if (grid.hasTag("base")) {
                    grid.removeTag("base");
                    grid._applyThemes();
                }
            }
            renderer.updateTick(dataItem.get("tick"), position, labelEndPosition, count);
            renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);
            this._processBullet(dataItem);
            renderer.updateBullet(dataItem.get("bullet"), position, endPosition);
            if (!dataItem.get("isRange")) {
                const fillRule = this.get("fillRule");
                if (fillRule) {
                    fillRule(dataItem);
                }
            }
        }
        _handleRangeChange() {
            let selectionMin = this.positionToValue(this.get("start", 0));
            let selectionMax = this.positionToValue(this.get("end", 1));
            const gridCount = this.get("renderer").gridCount();
            let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
            let stepDecimalPlaces = decimalPlaces(minMaxStep.step);
            this.setPrivateRaw("stepDecimalPlaces", stepDecimalPlaces);
            selectionMin = round$1(selectionMin, stepDecimalPlaces);
            selectionMax = round$1(selectionMax, stepDecimalPlaces);
            minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
            let step = minMaxStep.step;
            selectionMin = minMaxStep.min;
            selectionMax = minMaxStep.max;
            if (this.getPrivate("selectionMin") !== selectionMin || this.getPrivate("selectionMax") !== selectionMax || this.getPrivate("step") !== step) {
                // do not change to setPrivate, will cause SO
                this.setPrivateRaw("selectionMin", selectionMin);
                this.setPrivateRaw("selectionMax", selectionMax);
                this.setPrivateRaw("step", step);
            }
        }
        /**
         * Converts a relative position to a corresponding numeric value from axis
         * scale.
         *
         * @param   position  Relative position
         * @return            Value
         */
        positionToValue(position) {
            const min = this.getPrivate("min");
            const max = this.getPrivate("max");
            if (!this.get("logarithmic")) {
                return position * (max - min) + min;
            }
            else {
                return Math.pow(Math.E, (position * ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E)) + Math.log(min) * Math.LOG10E) / Math.LOG10E);
            }
        }
        /**
         * Convers value to a relative position on axis.
         *
         * @param   value  Value
         * @return         Relative position
         */
        valueToPosition(value) {
            const min = this.getPrivate("min");
            const max = this.getPrivate("max");
            if (!this.get("logarithmic")) {
                return (value - min) / (max - min);
            }
            else {
                if (value <= 0) {
                    let treatZeroAs = this.get("treatZeroAs");
                    if (isNumber(treatZeroAs)) {
                        value = treatZeroAs;
                    }
                }
                return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));
            }
        }
        /**
         * @ignore
         */
        valueToFinalPosition(value) {
            const min = this.getPrivate("minFinal");
            const max = this.getPrivate("maxFinal");
            if (!this.get("logarithmic")) {
                return (value - min) / (max - min);
            }
            else {
                if (value <= 0) {
                    let treatZeroAs = this.get("treatZeroAs");
                    if (isNumber(treatZeroAs)) {
                        value = treatZeroAs;
                    }
                }
                return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));
            }
        }
        /**
         * Returns X coordinate in pixels corresponding to specific value.
         *
         * @param   value     Numeric value
         * @param   location  Location
         * @param   baseValue Base value
         * @return            X coordinate
         */
        getX(value, location, baseValue) {
            value = baseValue + (value - baseValue) * location;
            const position = this.valueToPosition(value);
            return this._settings.renderer.positionToCoordinate(position);
        }
        /**
         * Returns X coordinate in pixels corresponding to specific value.
         *
         * @param   value     Numeric value
         * @param   location  Location
         * @param   baseValue Base value
         * @return            X coordinate
         */
        getY(value, location, baseValue) {
            value = baseValue + (value - baseValue) * location;
            const position = this.valueToPosition(value);
            return this._settings.renderer.positionToCoordinate(position);
        }
        /**
         * @ignore
         */
        getDataItemCoordinateX(dataItem, field, _cellLocation, axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));
        }
        /**
         * @ignore
         */
        getDataItemPositionX(dataItem, field, _cellLocation, axisLocation) {
            let value = dataItem.get(field);
            const stackToItem = dataItem.get("stackToItemX");
            if (stackToItem) {
                const series = dataItem.component;
                value = value * axisLocation + series.getStackedXValueWorking(dataItem, field);
            }
            else {
                value = this._baseValue + (value - this._baseValue) * axisLocation;
            }
            return this.valueToPosition(value);
        }
        /**
         * @ignore
         */
        getDataItemCoordinateY(dataItem, field, _cellLocation, axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));
        }
        /**
         * @ignore
         */
        getDataItemPositionY(dataItem, field, _cellLocation, axisLocation) {
            let value = dataItem.get(field);
            const stackToItem = dataItem.get("stackToItemY");
            if (stackToItem) {
                const series = dataItem.component;
                value = value * axisLocation + series.getStackedYValueWorking(dataItem, field);
            }
            else {
                value = this._baseValue + (value - this._baseValue) * axisLocation;
            }
            return this.valueToPosition(value);
        }
        /**
         * Returns relative position of axis' `baseValue`.
         *
         * @return  Base value position
         */
        basePosition() {
            return this.valueToPosition(this.baseValue());
        }
        /**
         * Base value of the [[ValueAxis]], which determines positive and negative
         * values.
         *
         * @return Base value
         */
        baseValue() {
            const min = Math.min(this.getPrivate("minFinal", -Infinity), this.getPrivate("selectionMin", -Infinity));
            const max = Math.max(this.getPrivate("maxFinal", Infinity), this.getPrivate("selectionMax", Infinity));
            let baseValue = this.get("baseValue", 0);
            if (baseValue < min) {
                baseValue = min;
            }
            if (baseValue > max) {
                baseValue = max;
            }
            return baseValue;
        }
        /**
         * @ignore
         */
        cellEndValue(value) {
            return value;
        }
        fixSmallStep(step) {
            // happens because of floating point error
            if (1 + step === 1) {
                step *= 2;
                return this.fixSmallStep(step);
            }
            return step;
        }
        _fixMin(min) {
            return min;
        }
        _fixMax(max) {
            return max;
        }
        _calculateTotals() {
            if (this.get("calculateTotals")) {
                let series = this.series[0];
                if (series) {
                    let startIndex = series.startIndex();
                    if (series.dataItems.length > 0) {
                        if (startIndex > 0) {
                            startIndex--;
                        }
                        let endIndex = series.endIndex();
                        if (endIndex < series.dataItems.length) {
                            endIndex++;
                        }
                        let field;
                        let vc;
                        if (series.get("yAxis") == this) {
                            field = "valueY";
                            vc = "vcy";
                        }
                        else if (series.get("xAxis") == this) {
                            field = "valueX";
                            vc = "vcx";
                        }
                        let fieldWorking = field + "Working";
                        if (field) {
                            for (let i = startIndex; i < endIndex; i++) {
                                let sum = 0;
                                let total = 0;
                                each$1(this.series, (series) => {
                                    if (!series.get("excludeFromTotal")) {
                                        let dataItem = series.dataItems[i];
                                        if (dataItem) {
                                            let value = dataItem.get(fieldWorking) * series.get(vc);
                                            if (!isNaN$1(value)) {
                                                sum += value;
                                                total += Math.abs(value);
                                            }
                                        }
                                    }
                                });
                                each$1(this.series, (series) => {
                                    if (!series.get("excludeFromTotal")) {
                                        let dataItem = series.dataItems[i];
                                        if (dataItem) {
                                            let value = dataItem.get(fieldWorking) * series.get(vc);
                                            if (!isNaN$1(value)) {
                                                dataItem.set((field + "Total"), total);
                                                dataItem.set((field + "Sum"), sum);
                                                dataItem.set((field + "TotalPercent"), value / total * 100);
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
            }
        }
        _getSelectionMinMax() {
            const min = this.getPrivate("minFinal");
            const max = this.getPrivate("maxFinal");
            const minDefined = this.get("min");
            const maxDefined = this.get("max");
            let extraMin = this.get("extraMin", 0);
            let extraMax = this.get("extraMax", 0);
            if (this.get("logarithmic")) {
                if (this.get("extraMin") == null) {
                    extraMin = 0.1;
                }
                if (this.get("extraMax") == null) {
                    extraMax = 0.2;
                }
            }
            const gridCount = this.get("renderer").gridCount();
            const selectionStrictMinMax = this.get("strictMinMaxSelection");
            let strictMinMax = this.get("strictMinMax");
            if (isNumber(min) && isNumber(max)) {
                let selectionMin = max;
                let selectionMax = min;
                each$1(this.series, (series) => {
                    if (!series.get("ignoreMinMax")) {
                        let seriesMin;
                        let seriesMax;
                        const outOfSelection = series.getPrivate("outOfSelection");
                        if (series.get("xAxis") === this) {
                            if (!outOfSelection) {
                                let minX = series.getPrivate("minX");
                                let maxX = series.getPrivate("maxX");
                                // solves #90085
                                if (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {
                                    minX = undefined;
                                    maxX = undefined;
                                }
                                seriesMin = series.getPrivate("selectionMinX", minX);
                                seriesMax = series.getPrivate("selectionMaxX", maxX);
                            }
                        }
                        else if (series.get("yAxis") === this) {
                            if (!outOfSelection) {
                                let minY = series.getPrivate("minY");
                                let maxY = series.getPrivate("maxY");
                                // solves #90085
                                if (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {
                                    minY = undefined;
                                    maxY = undefined;
                                }
                                seriesMin = series.getPrivate("selectionMinY", minY);
                                seriesMax = series.getPrivate("selectionMaxY", maxY);
                            }
                        }
                        if (!series.isHidden() && !series.isShowing()) {
                            if (isNumber(seriesMin)) {
                                selectionMin = Math.min(selectionMin, seriesMin);
                            }
                            if (isNumber(seriesMax)) {
                                selectionMax = Math.max(selectionMax, seriesMax);
                            }
                        }
                    }
                });
                this.axisRanges.each((range) => {
                    if (range.get("affectsMinMax")) {
                        let value = range.get("value");
                        if (value != null) {
                            selectionMin = Math.min(selectionMin, value);
                            selectionMax = Math.max(selectionMax, value);
                        }
                        value = range.get("endValue");
                        if (value != null) {
                            selectionMin = Math.min(selectionMin, value);
                            selectionMax = Math.max(selectionMax, value);
                        }
                    }
                });
                if (selectionMin > selectionMax) {
                    [selectionMin, selectionMax] = [selectionMax, selectionMin];
                }
                if (isNumber(minDefined)) {
                    if (strictMinMax) {
                        selectionMin = minDefined;
                    }
                    else {
                        selectionMin = min;
                    }
                }
                else if (strictMinMax) {
                    if (isNumber(this._minReal)) {
                        selectionMin = this._minReal;
                    }
                }
                if (isNumber(maxDefined)) {
                    if (strictMinMax) {
                        selectionMax = maxDefined;
                    }
                    else {
                        selectionMax = max;
                    }
                }
                else if (strictMinMax) {
                    if (isNumber(this._maxReal)) {
                        selectionMax = this._maxReal;
                    }
                }
                if (selectionMin === selectionMax) {
                    let smin = selectionMin;
                    selectionMin -= this._deltaMinMax;
                    selectionMax += this._deltaMinMax;
                    if (selectionMin < min) {
                        let d = smin - min;
                        if (d == 0) {
                            d = this._deltaMinMax;
                        }
                        selectionMin = smin - d;
                        selectionMax = smin + d;
                        strictMinMax = true;
                    }
                    let minMaxStep2 = this._adjustMinMax(selectionMin, selectionMax, gridCount, strictMinMax);
                    selectionMin = minMaxStep2.min;
                    selectionMax = minMaxStep2.max;
                }
                let selectionMinReal = selectionMin;
                let selectionMaxReal = selectionMax;
                let delta = selectionMax - selectionMin;
                selectionMin -= delta * extraMin;
                selectionMax += delta * extraMax;
                let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount);
                selectionMin = minMaxStep.min;
                selectionMax = minMaxStep.max;
                selectionMin = fitToRange(selectionMin, min, max);
                selectionMax = fitToRange(selectionMax, min, max);
                // do it for the second time !important			
                minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
                if (!strictMinMax) {
                    selectionMin = minMaxStep.min;
                    selectionMax = minMaxStep.max;
                }
                const syncWithAxis = this.get("syncWithAxis");
                if (syncWithAxis) {
                    minMaxStep = this._syncAxes(selectionMin, selectionMax, minMaxStep.step, syncWithAxis.getPrivate("selectionMinFinal", syncWithAxis.getPrivate("minFinal", 0)), syncWithAxis.getPrivate("selectionMaxFinal", syncWithAxis.getPrivate("maxFinal", 1)), syncWithAxis.getPrivate("selectionStepFinal", syncWithAxis.getPrivate("step", 1)));
                    if (minMaxStep.min < min) {
                        minMaxStep.min = min;
                    }
                    if (minMaxStep.max > max) {
                        minMaxStep.max = max;
                    }
                    selectionMin = minMaxStep.min;
                    selectionMax = minMaxStep.max;
                }
                if (strictMinMax) {
                    if (isNumber(minDefined)) {
                        selectionMin = Math.max(selectionMin, minDefined);
                    }
                    if (isNumber(maxDefined)) {
                        selectionMax = Math.min(selectionMax, maxDefined);
                    }
                }
                if (selectionStrictMinMax) {
                    selectionMin = selectionMinReal - (selectionMaxReal - selectionMinReal) * extraMin;
                    selectionMax = selectionMaxReal + (selectionMaxReal - selectionMinReal) * extraMax;
                }
                if (strictMinMax) {
                    if (isNumber(minDefined)) {
                        selectionMin = minDefined;
                    }
                    else {
                        selectionMin = selectionMinReal;
                    }
                    if (isNumber(maxDefined)) {
                        selectionMax = maxDefined;
                    }
                    else {
                        selectionMax = selectionMaxReal;
                    }
                    if (selectionMax - selectionMin <= 0.00000001) {
                        selectionMin -= this._deltaMinMax;
                        selectionMax += this._deltaMinMax;
                    }
                    let delta = selectionMax - selectionMin;
                    selectionMin -= delta * extraMin;
                    selectionMax += delta * extraMax;
                }
                if (this.get("logarithmic")) {
                    if (selectionMin <= 0) {
                        selectionMin = selectionMinReal * (1 - Math.min(extraMin, 0.99));
                    }
                    if (selectionMin < min) {
                        selectionMin = min;
                    }
                    if (selectionMax > max) {
                        selectionMax = max;
                    }
                }
                let len = Math.min(20, Math.ceil(Math.log(this.getPrivate("maxZoomFactor", 100) + 1) / Math.LN10) + 2);
                let start = round$1(this.valueToFinalPosition(selectionMin), len);
                let end = round$1(this.valueToFinalPosition(selectionMax), len);
                this.setPrivateRaw("selectionMinFinal", selectionMin);
                this.setPrivateRaw("selectionMaxFinal", selectionMax);
                this.setPrivateRaw("selectionStepFinal", minMaxStep.step);
                this.zoom(start, end);
            }
        }
        _getMinMax() {
            let minDefined = this.get("min");
            let maxDefined = this.get("max");
            let min = Infinity;
            let max = -Infinity;
            let extraMin = this.get("extraMin", 0);
            let extraMax = this.get("extraMax", 0);
            if (this.get("logarithmic")) {
                if (this.get("extraMin") == null) {
                    extraMin = 0.1;
                }
                if (this.get("extraMax") == null) {
                    extraMax = 0.2;
                }
            }
            let minDiff = Infinity;
            each$1(this.series, (series) => {
                if (!series.get("ignoreMinMax")) {
                    let seriesMin;
                    let seriesMax;
                    if (series.get("xAxis") === this) {
                        seriesMin = series.getPrivate("minX");
                        seriesMax = series.getPrivate("maxX");
                    }
                    else if (series.get("yAxis") === this) {
                        seriesMin = series.getPrivate("minY");
                        seriesMax = series.getPrivate("maxY");
                    }
                    if (isNumber(seriesMin) && isNumber(seriesMax)) {
                        min = Math.min(min, seriesMin);
                        max = Math.max(max, seriesMax);
                        let diff = seriesMax - seriesMin;
                        if (diff <= 0) {
                            diff = Math.abs(seriesMax / 100);
                        }
                        if (diff < minDiff) {
                            minDiff = diff;
                        }
                    }
                }
            });
            this.axisRanges.each((range) => {
                if (range.get("affectsMinMax")) {
                    let value = range.get("value");
                    if (value != null) {
                        min = Math.min(min, value);
                        max = Math.max(max, value);
                    }
                    value = range.get("endValue");
                    if (value != null) {
                        min = Math.min(min, value);
                        max = Math.max(max, value);
                    }
                }
            });
            if (this.get("logarithmic")) {
                let treatZeroAs = this.get("treatZeroAs");
                if (isNumber(treatZeroAs)) {
                    if (min <= 0) {
                        min = treatZeroAs;
                    }
                }
            }
            if (min === 0 && max === 0) {
                max = 0.9;
                min = -0.9;
            }
            if (isNumber(minDefined)) {
                min = minDefined;
            }
            if (isNumber(maxDefined)) {
                max = maxDefined;
            }
            // meaning no min/max found on series/ranges and no min/max was defined
            if (min === Infinity || max === -Infinity) {
                this.setPrivate("minFinal", undefined);
                this.setPrivate("maxFinal", undefined);
                return;
            }
            if (min > max) {
                [min, max] = [max, min];
            }
            const initialMin = min;
            const initialMax = max;
            // adapter
            let minAdapted = this.adapters.fold("min", min);
            let maxAdapted = this.adapters.fold("max", max);
            this._minRealLog = min;
            if (isNumber(minAdapted)) {
                min = minAdapted;
            }
            if (isNumber(maxAdapted)) {
                max = maxAdapted;
            }
            // DateAxis does some magic here
            min = this._fixMin(min);
            max = this._fixMax(max);
            // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date		
            if (max - min <= 1 / Math.pow(10, 15)) {
                if (max - min !== 0) {
                    this._deltaMinMax = (max - min) / 2;
                }
                else {
                    this._getDelta(max);
                }
                min -= this._deltaMinMax;
                max += this._deltaMinMax;
            }
            // add extras
            min -= (max - min) * extraMin;
            max += (max - min) * extraMax;
            if (this.get("logarithmic")) {
                // don't let min go below 0 if real min is >= 0
                if (min < 0 && initialMin >= 0) {
                    min = 0;
                }
                // don't let max go above 0 if real max is <= 0
                if (max > 0 && initialMax <= 0) {
                    max = 0;
                }
            }
            this._minReal = min;
            this._maxReal = max;
            let strictMinMax = this.get("strictMinMax");
            let strictMinMaxSelection = this.get("strictMinMaxSelection", false);
            if (strictMinMaxSelection) {
                strictMinMax = strictMinMaxSelection;
            }
            let strict = strictMinMax;
            if (isNumber(maxDefined)) {
                strict = true;
            }
            let gridCount = this.get("renderer").gridCount();
            let minMaxStep = this._adjustMinMax(min, max, gridCount, strict);
            min = minMaxStep.min;
            max = minMaxStep.max;
            // do it for the second time with strict true (importat!)
            minMaxStep = this._adjustMinMax(min, max, gridCount, true);
            min = minMaxStep.min;
            max = minMaxStep.max;
            // return min max if strict
            if (strictMinMax) {
                if (isNumber(minDefined)) {
                    min = minDefined;
                }
                else {
                    min = this._minReal;
                }
                if (isNumber(maxDefined)) {
                    max = maxDefined;
                }
                else {
                    max = this._maxReal;
                }
                if (max - min <= 0.00000001) {
                    min -= this._deltaMinMax;
                    max += this._deltaMinMax;
                }
                let delta = max - min;
                min -= delta * extraMin;
                max += delta * extraMax;
            }
            minAdapted = this.adapters.fold("min", min);
            maxAdapted = this.adapters.fold("max", max);
            if (isNumber(minAdapted)) {
                min = minAdapted;
            }
            if (isNumber(maxAdapted)) {
                max = maxAdapted;
            }
            if (minDiff == Infinity) {
                minDiff = (max - min);
            }
            // this is to avoid floating point number error
            let decCount = Math.round(Math.abs(Math.log(Math.abs(max - min)) * Math.LOG10E)) + 5;
            min = round$1(min, decCount);
            max = round$1(max, decCount);
            const syncWithAxis = this.get("syncWithAxis");
            if (syncWithAxis) {
                minMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate("minFinal", syncWithAxis.getPrivate("min", 0)), syncWithAxis.getPrivate("maxFinal", syncWithAxis.getPrivate("max", 1)), syncWithAxis.getPrivate("step", 1));
                min = minMaxStep.min;
                max = minMaxStep.max;
            }
            this.setPrivateRaw("maxZoomFactor", Math.max(1, Math.ceil((max - min) / minDiff * this.get("maxZoomFactor", 100))));
            this._fixZoomFactor();
            if (this.get("logarithmic")) {
                this._minLogAdjusted = min;
                min = this._minReal;
                max = this._maxReal;
                if (min <= 0) {
                    min = initialMin * (1 - Math.min(extraMin, 0.99));
                }
            }
            if (isNumber(min) && isNumber(max)) {
                if (this.getPrivate("minFinal") !== min || this.getPrivate("maxFinal") !== max) {
                    this.setPrivate("minFinal", min);
                    this.setPrivate("maxFinal", max);
                    this._saveMinMax(min, max);
                    const duration = this.get("interpolationDuration", 0);
                    const easing = this.get("interpolationEasing");
                    this.animatePrivate({ key: "min", to: min, duration, easing });
                    this.animatePrivate({ key: "max", to: max, duration, easing });
                }
            }
        }
        _fixZoomFactor() {
        }
        _getDelta(max) {
            // the number by which we need to raise 10 to get difference
            let exponent = Math.log(Math.abs(max)) * Math.LOG10E;
            // here we find a number which is power of 10 and has the same count of numbers as difference has
            let power = Math.pow(10, Math.floor(exponent));
            // reduce this number by 10 times
            power = power / 10;
            this._deltaMinMax = power;
        }
        _saveMinMax(_min, _max) {
        }
        _adjustMinMax(min, max, gridCount, strictMode) {
            // will fail if 0
            if (gridCount <= 1) {
                gridCount = 1;
            }
            gridCount = Math.round(gridCount);
            let initialMin = min;
            let initialMax = max;
            let difference = max - min;
            // in case min and max is the same, use max
            if (difference === 0) {
                difference = Math.abs(max);
            }
            // the number by which we need to raise 10 to get difference
            let exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
            // here we find a number which is power of 10 and has the same count of numbers as difference has
            let power = Math.pow(10, Math.floor(exponent));
            // reduce this number by 10 times
            power = power / 10;
            let extra = power;
            if (strictMode) {
                extra = 0;
            }
            // round down min
            if (strictMode) {
                min = Math.floor(min / power) * power;
                // round up max
                max = Math.ceil(max / power) * power;
            }
            else {
                min = Math.ceil(min / power) * power - extra;
                // round up max
                max = Math.floor(max / power) * power + extra;
            }
            // don't let min go below 0 if real min is >= 0
            if (min < 0 && initialMin >= 0) {
                min = 0;
            }
            // don't let max go above 0 if real max is <= 0
            if (max > 0 && initialMax <= 0) {
                max = 0;
            }
            exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
            power = Math.pow(10, Math.floor(exponent));
            power = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance
            // approximate difference between two grid lines
            let step = Math.ceil((difference / gridCount) / power) * power;
            let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
            // the step should divide by  2, 5, and 10.
            let stepDivisor = Math.ceil(step / stepPower); // number 0 - 10
            if (stepDivisor > 5) {
                stepDivisor = 10;
            }
            else if (stepDivisor <= 5 && stepDivisor > 2) {
                stepDivisor = 5;
            }
            // now get real step
            step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;
            let maxPrecision = this.get("maxPrecision");
            if (isNumber(maxPrecision)) {
                let ceiledStep = ceil(step, maxPrecision);
                if (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {
                    step = ceiledStep;
                    if (step == 0) {
                        step = 1;
                    }
                }
            }
            let decCount = 0;
            // in case numbers are smaller than 1
            if (stepPower < 1) {
                // exponent is less then 1 too. Count decimals of exponent
                decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;
                // round step
                step = round$1(step, decCount);
            }
            // final min and max
            let minCount = Math.floor(min / step);
            min = round$1(step * minCount, decCount);
            let maxCount;
            if (!strictMode) {
                maxCount = Math.ceil(max / step);
            }
            else {
                maxCount = Math.floor(max / step);
            }
            if (maxCount === minCount) {
                maxCount++;
            }
            max = round$1(step * maxCount, decCount);
            if (max < initialMax) {
                max = max + step;
            }
            if (min > initialMin) {
                min = min - step;
            }
            step = this.fixSmallStep(step);
            return { min: min, max: max, step: step };
        }
        /**
         * Returns text to be used in an axis tooltip for specific relative position.
         *
         * @param   position  Position
         * @return            Tooltip text
         */
        getTooltipText(position, _adjustPosition) {
            const numberFormat = this.get("tooltipNumberFormat", this.get("numberFormat"));
            const formatter = this.getNumberFormatter();
            const extraDecimals = this.get("extraTooltipPrecision", 0);
            const decimals = this.getPrivate("stepDecimalPlaces", 0) + extraDecimals;
            const value = round$1(this.positionToValue(position), decimals);
            if (numberFormat) {
                return formatter.format(value, numberFormat);
            }
            else {
                return formatter.format(value, undefined, decimals);
            }
        }
        /**
         * Returns a data item from series that is closest to the `position`.
         *
         * @param   series    Series
         * @param   position  Relative position
         * @return            Data item
         */
        getSeriesItem(series, position) {
            let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
            let value = this.positionToValue(position);
            let index = undefined;
            let oldDiff;
            each$1(series.dataItems, (dataItem, i) => {
                const diff = Math.abs(dataItem.get(fieldName) - value);
                if (index === undefined || diff < oldDiff) {
                    index = i;
                    oldDiff = diff;
                }
            });
            if (index != null) {
                return series.dataItems[index];
            }
        }
        /**
         * Zooms the axis to specific `start` and `end` values.
         *
         * Optional `duration` specifies duration of zoom animation in milliseconds.
         *
         * @param  start     Start value
         * @param  end       End value
         * @param  duration  Duration in milliseconds
         */
        zoomToValues(start, end, duration) {
            const min = this.getPrivate("minFinal", 0);
            const max = this.getPrivate("maxFinal", 0);
            if (this.getPrivate("min") != null && this.getPrivate("max") != null) {
                this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);
            }
        }
        /**
         * Syncs with a target axis.
         *
         * @param  min  Min
         * @param  max  Max
         * @param  step Step
         */
        _syncAxes(min, max, step, syncMin, syncMax, syncStep) {
            let axis = this.get("syncWithAxis");
            if (axis) {
                let count = Math.round(syncMax - syncMin) / syncStep;
                let currentCount = Math.round((max - min) / step);
                let gridCount = this.get("renderer").gridCount();
                if (isNumber(count) && isNumber(currentCount)) {
                    let synced = false;
                    let c = 0;
                    let diff = (max - min) * 0.01;
                    let omin = min;
                    let omax = max;
                    let ostep = step;
                    while (synced != true) {
                        synced = this._checkSync(omin, omax, ostep, count);
                        c++;
                        if (c > 500) {
                            synced = true;
                        }
                        if (!synced) {
                            if (c / 3 == Math.round(c / 3)) {
                                omin = min - diff * c;
                                if (min >= 0 && omin < 0) {
                                    omin = 0;
                                }
                            }
                            else {
                                omax = max + diff * c;
                                if (omax <= 0 && omax > 0) {
                                    omax = 0;
                                }
                            }
                            let minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);
                            omin = minMaxStep.min;
                            omax = minMaxStep.max;
                            ostep = minMaxStep.step;
                        }
                        else {
                            min = omin;
                            max = omax;
                            step = ostep;
                        }
                    }
                }
            }
            return { min: min, max: max, step: step };
        }
        /**
         * Returns `true` if axis needs to be resunced with some other axis.
         */
        _checkSync(min, max, step, count) {
            let currentCount = (max - min) / step;
            for (let i = 1; i < count; i++) {
                if (round$1(currentCount / i, 1) == count || currentCount * i == count) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Returns relative position between two grid lines of the axis.
         *
         * @return Position
         */
        getCellWidthPosition() {
            let max = this.getPrivate("selectionMax", this.getPrivate("max"));
            let min = this.getPrivate("selectionMin", this.getPrivate("min"));
            if (isNumber(max) && isNumber(min)) {
                return this.getPrivate("step", 1) / (max - min);
            }
            return 0.05;
        }
        /**
         * @ignore
         */
        nextPosition(count) {
            if (count == null) {
                count = 1;
            }
            if (this.get("renderer").getPrivate("letter") == "Y") {
                count *= -1;
            }
            let value = this.positionToValue(this.getPrivate("tooltipPosition", 0));
            value += this.getPrivate("step", 1) * count;
            value = fitToRange(value, this.getPrivate("selectionMin", 0), this.getPrivate("selectionMax", 1));
            return this.toGlobalPosition(this.valueToPosition(value));
        }
    }
    Object.defineProperty(ValueAxis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ValueAxis"
    });
    Object.defineProperty(ValueAxis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Axis.classNames.concat([ValueAxis.className])
    });

    /**
     * Creates a date axis.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info
     * @important
     */
    class DateAxis extends ValueAxis {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_dataGrouped", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_seriesDataGrouped", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_groupingCalculated", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_intervalDuration", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_baseDuration", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_intervalMax", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
            Object.defineProperty(this, "_intervalMin", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: {}
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["axis"]);
            super._afterNew();
            this._setBaseInterval(this.get("baseInterval"));
            this.on("baseInterval", () => {
                this._setBaseInterval(this.get("baseInterval"));
            });
        }
        _setBaseInterval(interval) {
            this.setPrivateRaw("baseInterval", interval);
            this._baseDuration = getIntervalDuration(interval);
        }
        _fixZoomFactor() {
            const maxZoomFactor = this.get("maxZoomFactor");
            if (maxZoomFactor != null && maxZoomFactor != Infinity) {
                this.setPrivateRaw("maxZoomFactor", maxZoomFactor);
            }
            else {
                this.setPrivateRaw("maxZoomFactor", Math.round((this.getPrivate("max", 0) - this.getPrivate("min", 0)) / this.baseMainDuration()));
            }
        }
        _groupData() {
            const min = this.getPrivate("min");
            const max = this.getPrivate("max");
            if ((isNumber(min) && isNumber(max))) {
                this._fixZoomFactor();
                const groupInterval = this.getPrivate("groupInterval");
                if (groupInterval) {
                    this._setBaseInterval(groupInterval);
                }
                else {
                    this._setBaseInterval(this.get("baseInterval"));
                }
                if (this.isDirty("groupInterval")) {
                    let groupInterval = this.get("groupInterval");
                    if (groupInterval) {
                        this.setRaw("groupIntervals", [groupInterval]);
                        this._handleRangeChange();
                    }
                }
                if (this.isDirty("groupData")) {
                    if (!this._dataGrouped) {
                        if (this.get("groupData")) {
                            each$1(this.series, (series) => {
                                this._groupSeriesData(series);
                            });
                            this._handleRangeChange();
                        }
                        else {
                            let baseInterval = this.get("baseInterval");
                            let mainDataSetId = baseInterval.timeUnit + baseInterval.count;
                            each$1(this.series, (series) => {
                                series.setDataSet(mainDataSetId);
                                series.resetGrouping();
                            });
                            this._setBaseInterval(baseInterval);
                            this.setPrivateRaw("groupInterval", undefined);
                            this.markDirtyExtremes();
                        }
                        this._dataGrouped = true;
                    }
                }
            }
        }
        _groupSeriesData(series) {
            if (this.get("groupData") && !series.get("groupDataDisabled")) {
                this._dataGrouped = true; // helps to avoid double grouping
                this._seriesDataGrouped = true;
                // make array of intervals which will be used;
                let intervals = [];
                let baseDuration = this.baseMainDuration();
                let groupIntervals = this.get("groupIntervals");
                each$1(groupIntervals, (interval) => {
                    let intervalDuration = getIntervalDuration(interval);
                    if (intervalDuration > baseDuration) {
                        intervals.push(interval);
                    }
                });
                series._dataSets = {};
                const key = this.getPrivate("name") + this.get("renderer").getPrivate("letter");
                let fields;
                const baseAxis = series.get("baseAxis");
                if (series.get("xAxis") === baseAxis) {
                    fields = series._valueYFields;
                }
                else if (series.get("yAxis") === baseAxis) {
                    fields = series._valueXFields;
                }
                let dataItems = series._mainDataItems;
                let baseInterval = this.get("baseInterval");
                let mainDataSetId = baseInterval.timeUnit + baseInterval.count;
                series._dataSets[mainDataSetId] = dataItems;
                const groupCallback = series.get("groupDataCallback");
                let groupOriginals = series.get("groupDataWithOriginals", false);
                if (groupCallback) {
                    groupOriginals = true;
                }
                each$1(intervals, (interval) => {
                    let previousTime = -Infinity;
                    let dataSetId = interval.timeUnit + interval.count;
                    series._dataSets[dataSetId] = [];
                    let newDataItem;
                    let sum = {};
                    let count = {};
                    let groupFieldValues = {};
                    let workingFields = {};
                    each$1(fields, (field) => {
                        sum[field] = 0;
                        count[field] = 0;
                        groupFieldValues[field] = series.get((field + "Grouped"));
                        workingFields[field] = field + "Working";
                    });
                    let intervalDuration = getDuration(interval.timeUnit);
                    let firstItem = dataItems[0];
                    let firstTime;
                    if (firstItem) {
                        firstTime = dataItems[0].get(key);
                    }
                    let prevNewDataItem;
                    each$1(dataItems, (dataItem) => {
                        let time = dataItem.get(key);
                        //let roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, firstDay, utc, firstDate, timezone).getTime();
                        let roundedTime = roun(time, interval.timeUnit, interval.count, this._root, firstTime);
                        let dataContext;
                        if (previousTime < roundedTime - intervalDuration / 24) {
                            dataContext = copy$1(dataItem.dataContext);
                            newDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));
                            newDataItem.setRaw(key, roundedTime);
                            series._dataSets[dataSetId].push(newDataItem);
                            each$1(fields, (field) => {
                                let value = dataItem.get(field);
                                if (isNumber(value)) {
                                    newDataItem.setRaw(field, value);
                                    newDataItem.setRaw(workingFields[field], value);
                                    count[field] = 1;
                                    sum[field] = value;
                                }
                                else {
                                    sum[field] = 0;
                                    count[field] = 0;
                                }
                            });
                            if (groupOriginals) {
                                newDataItem.set("originals", [dataItem]);
                            }
                            if (groupCallback && prevNewDataItem) {
                                groupCallback(prevNewDataItem, interval);
                            }
                            prevNewDataItem = newDataItem;
                        }
                        else {
                            each$1(fields, (field) => {
                                let groupKey = groupFieldValues[field];
                                let value = dataItem.get(field);
                                if (value != null) {
                                    let currentValue = newDataItem.get(field);
                                    switch (groupKey) {
                                        case "close":
                                            newDataItem.setRaw(field, value);
                                            break;
                                        case "sum":
                                            newDataItem.setRaw(field, currentValue + value);
                                            break;
                                        case "open":
                                            break;
                                        case "low":
                                            if (value < currentValue) {
                                                newDataItem.setRaw(field, value);
                                            }
                                            break;
                                        case "high":
                                            if (value > currentValue) {
                                                newDataItem.setRaw(field, value);
                                            }
                                            break;
                                        case "average":
                                            count[field]++;
                                            sum[field] += value;
                                            let average = sum[field] / count[field];
                                            newDataItem.setRaw(field, average);
                                            break;
                                        case "extreme":
                                            if (Math.abs(value) > Math.abs(currentValue)) {
                                                newDataItem.setRaw(field, value);
                                            }
                                            break;
                                    }
                                    newDataItem.setRaw(workingFields[field], newDataItem.get(field));
                                    let dataContext = copy$1(dataItem.dataContext);
                                    dataContext[key] = roundedTime;
                                    newDataItem.dataContext = dataContext;
                                }
                            });
                            if (groupOriginals) {
                                newDataItem.get("originals").push(dataItem);
                            }
                        }
                        previousTime = roundedTime;
                    });
                    if (groupCallback && prevNewDataItem) {
                        groupCallback(prevNewDataItem, interval);
                    }
                });
                if (series._dataSetId) {
                    series.setDataSet(series._dataSetId);
                }
                this.markDirtySize();
                // solves problem if new series was added
                if (this._seriesAdded) {
                    this._root.events.once("frameended", () => {
                        this.markDirtySize();
                    });
                }
            }
        }
        _clearDirty() {
            super._clearDirty();
            this._groupingCalculated = false;
            this._dataGrouped = false;
        }
        /**
         * Returns a time interval axis would group data to for a specified duration.
         *
         * @since 5.2.1
         */
        getGroupInterval(duration) {
            let baseInterval = this.get("baseInterval");
            let groupInterval = chooseInterval(0, duration, this.get("groupCount", Infinity), this.get("groupIntervals"));
            if (getIntervalDuration(groupInterval) < getIntervalDuration(baseInterval)) {
                groupInterval = Object.assign({}, baseInterval);
            }
            return groupInterval;
        }
        /**
         * Return `max` of a specified time interval.
         *
         * Will work only if the axis was grouped to this interval at least once.
         *
         * @since 5.2.1
         * @param   interval  Interval
         * @return            Max
         */
        getIntervalMax(interval) {
            return this._intervalMax[interval.timeUnit + interval.count];
        }
        /**
         * Return `min` of a specified time interval.
         *
         * Will work only if the axis was grouped to this interval at least once.
         *
         * @since 5.2.1
         * @param   interval  Interval
         * @return            Min
         */
        getIntervalMin(interval) {
            return this._intervalMin[interval.timeUnit + interval.count];
        }
        _handleRangeChange() {
            super._handleRangeChange();
            let selectionMin = Math.round(this.getPrivate("selectionMin"));
            let selectionMax = Math.round(this.getPrivate("selectionMax"));
            if (isNumber(selectionMin) && isNumber(selectionMax)) {
                if (this.get("endLocation") == 0) {
                    selectionMax += 1;
                }
                if (this.get("groupData") && !this._groupingCalculated) {
                    this._groupingCalculated = true;
                    let groupInterval = this.get("groupInterval");
                    let current = this.getPrivate("groupInterval");
                    let modifiedDifference = (selectionMax - selectionMin) + (this.get("startLocation", 0) + (1 - this.get("endLocation", 1)) * this.baseDuration());
                    if (current) {
                        let duration = getIntervalDuration(current);
                        modifiedDifference = Math.ceil(modifiedDifference / duration) * duration;
                    }
                    if (!groupInterval) {
                        groupInterval = this.getGroupInterval(modifiedDifference);
                    }
                    if (groupInterval && (!current || (current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count) || this._seriesDataGrouped)) {
                        this._seriesDataGrouped = false;
                        this.setPrivateRaw("groupInterval", groupInterval);
                        this._setBaseInterval(groupInterval);
                        let newId = groupInterval.timeUnit + groupInterval.count;
                        each$1(this.series, (series) => {
                            if (series.get("baseAxis") === this) {
                                series.setDataSet(newId);
                            }
                        });
                        this.markDirtyExtremes();
                        this._root.events.once("frameended", () => {
                            this._root.events.once("frameended", () => {
                                const type = "groupintervalchanged";
                                if (this.events.isEnabled(type)) {
                                    this.events.dispatch(type, { type: type, target: this });
                                }
                            });
                        });
                    }
                }
                each$1(this.series, (series) => {
                    if (series.get("baseAxis") === this) {
                        let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
                        const start = getFirstSortedIndex(series.dataItems, (dataItem) => {
                            return compare(dataItem.get(fieldName), selectionMin);
                        });
                        let startIndex = start.index;
                        if (startIndex > 0) {
                            startIndex -= 1;
                        }
                        selectionMax += this.baseDuration() * (1 - this.get("endLocation", 1));
                        const end = getSortedIndex(series.dataItems, (dataItem) => {
                            return compare(dataItem.get(fieldName), selectionMax);
                        });
                        let endIndex = end.index;
                        let endIndex2 = endIndex;
                        if (endIndex2 > 1) {
                            endIndex2--;
                        }
                        const firstDataItem = series.dataItems[startIndex];
                        const lastDataItem = series.dataItems[endIndex2];
                        let lastDate;
                        let firstDate;
                        if (firstDataItem) {
                            firstDate = firstDataItem.get(fieldName);
                        }
                        if (lastDataItem) {
                            lastDate = lastDataItem.get(fieldName);
                        }
                        let outOfSelection = false;
                        if (lastDate != null && firstDate != null) {
                            if (lastDate < selectionMin || firstDate > selectionMax) {
                                outOfSelection = true;
                            }
                        }
                        series.setPrivate("outOfSelection", outOfSelection);
                        series.setPrivate("startIndex", startIndex);
                        series.setPrivate("adjustedStartIndex", series._adjustStartIndex(startIndex));
                        series.setPrivate("endIndex", endIndex);
                        this.root.events.once("frameended", () => {
                            series._markDirtyPrivateKey("adjustedStartIndex");
                        });
                    }
                });
            }
        }
        _adjustMinMax(min, max, gridCount, _strictMode) {
            return { min: min, max: max, step: (max - min) / gridCount };
        }
        /**
         * @ignore
         */
        intervalDuration() {
            return this._intervalDuration;
        }
        _saveMinMax(min, max) {
            let groupInterval = this.getPrivate("groupInterval");
            if (!groupInterval) {
                groupInterval = this.get("baseInterval");
            }
            let id = groupInterval.timeUnit + groupInterval.count;
            this._intervalMin[id] = min;
            this._intervalMax[id] = max;
        }
        _getM(timeUnit) {
            if (timeUnit == "month" || timeUnit == "year" || timeUnit == "day") {
                return 1.05;
            }
            return 1.01;
        }
        _getMinorInterval(interval) {
            var _a;
            let minorGridInterval;
            let count = interval.count;
            let timeUnit = interval.timeUnit;
            if (count > 1) {
                if (count == 10) {
                    count = 5;
                }
                else if (count == 15) {
                    count = 5;
                }
                else if (count == 12) {
                    count = 2;
                }
                else if (count == 6) {
                    count = 1;
                }
                else if (count == 30) {
                    count = 10;
                }
                else if (count < 10) {
                    count = 1;
                }
                minorGridInterval = { timeUnit: timeUnit, count: count };
            }
            if (timeUnit == "week") {
                if (((_a = this.getPrivate("baseInterval")) === null || _a === void 0 ? void 0 : _a.timeUnit) != "week") {
                    minorGridInterval = { timeUnit: "day", count: 1 };
                }
            }
            return minorGridInterval;
        }
        _prepareAxisItems() {
            const min = this.getPrivate("min");
            const max = this.getPrivate("max");
            if (isNumber(min) && isNumber(max)) {
                const root = this._root;
                const selectionMin = Math.round(this.getPrivate("selectionMin"));
                const selectionMax = Math.round(this.getPrivate("selectionMax"));
                const renderer = this.get("renderer");
                const baseInterval = this.getPrivate("baseInterval");
                let value = selectionMin;
                let i = 0;
                const intervals = this.get("gridIntervals");
                let gridInterval = chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);
                if (getIntervalDuration(gridInterval) < this.baseDuration()) {
                    gridInterval = Object.assign({}, baseInterval);
                }
                const intervalDuration = getIntervalDuration(gridInterval);
                this._intervalDuration = intervalDuration;
                const nextGridUnit = getNextUnit(gridInterval.timeUnit);
                const utc = root.utc;
                const timezone = root.timezone;
                //value = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, firstDay, utc, new Date(min), timezone).getTime();
                value = roun(selectionMin - intervalDuration, gridInterval.timeUnit, gridInterval.count, root, min);
                let previousValue = value - intervalDuration;
                let format;
                const formats = this.get("dateFormats");
                this.setPrivateRaw("gridInterval", gridInterval);
                const minorLabelsEnabled = renderer.get("minorLabelsEnabled");
                const minorGridEnabled = renderer.get("minorGridEnabled", minorLabelsEnabled);
                let minorGridInterval;
                let minorDuration = 0;
                if (minorGridEnabled) {
                    minorGridInterval = this._getMinorInterval(gridInterval);
                    minorDuration = getIntervalDuration(minorGridInterval);
                }
                let m = 0;
                while (value < selectionMax + intervalDuration) {
                    let dataItem;
                    if (this.dataItems.length < i + 1) {
                        dataItem = new DataItem(this, undefined, {});
                        this._dataItems.push(dataItem);
                        this.processDataItem(dataItem);
                    }
                    else {
                        dataItem = this.dataItems[i];
                    }
                    this._createAssets(dataItem, []);
                    this._toggleDataItem(dataItem, true);
                    dataItem.setRaw("value", value);
                    dataItem.setRaw("labelEndValue", undefined);
                    let endValue = value + getDuration(gridInterval.timeUnit, gridInterval.count * this._getM(gridInterval.timeUnit));
                    //endValue = $time.round(new Date(endValue), gridInterval.timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
                    endValue = roun(endValue, gridInterval.timeUnit, 1, root);
                    dataItem.setRaw("endValue", endValue);
                    let date = new Date(value);
                    format = formats[gridInterval.timeUnit];
                    if (nextGridUnit && this.get("markUnitChange") && isNumber(previousValue)) {
                        if (gridInterval.timeUnit != "year") {
                            if (checkChange(value, previousValue, nextGridUnit, utc, timezone)) {
                                format = this.get("periodChangeDateFormats")[gridInterval.timeUnit];
                            }
                        }
                    }
                    const label = dataItem.get("label");
                    if (label) {
                        label.set("text", root.dateFormatter.format(date, format));
                    }
                    let count = gridInterval.count;
                    // so that labels of week would always be at the beginning of the grid
                    if (gridInterval.timeUnit == "week") {
                        dataItem.setRaw("labelEndValue", value);
                    }
                    if (minorGridEnabled) {
                        count = 1;
                        let timeUnit = gridInterval.timeUnit;
                        if (timeUnit == "week") {
                            timeUnit = "day";
                        }
                        let labelEndValue = value + getDuration(timeUnit, this._getM(timeUnit));
                        //labelEndValue = $time.round(new Date(labelEndValue), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
                        labelEndValue = roun(labelEndValue, timeUnit, 1, root);
                        dataItem.setRaw("labelEndValue", labelEndValue);
                    }
                    this._prepareDataItem(dataItem, count);
                    previousValue = value;
                    value = endValue;
                    // min grid
                    if (minorGridInterval) {
                        const minorTimeUnit = minorGridInterval.timeUnit;
                        const minorCount = minorGridInterval.count;
                        const mmm = this._getM(minorTimeUnit);
                        //let minorValue = $time.round(new Date(previousValue + minorDuration * this._getM(minorGridInterval.timeUnit)), minorGridInterval.timeUnit, minorGridInterval.count, firstDay, utc, new Date(previousValue), timezone).getTime();
                        let minorValue = roun(previousValue + minorDuration * mmm, minorTimeUnit, minorCount, root, previousValue);
                        let previousMinorValue;
                        let minorFormats = this.get("minorDateFormats", this.get("dateFormats"));
                        while (minorValue < value - 0.01 * minorDuration) {
                            let minorDataItem;
                            if (this.minorDataItems.length < m + 1) {
                                minorDataItem = new DataItem(this, undefined, {});
                                this.minorDataItems.push(minorDataItem);
                                this.processDataItem(minorDataItem);
                            }
                            else {
                                minorDataItem = this.minorDataItems[m];
                            }
                            this._createAssets(minorDataItem, ["minor"], true);
                            this._toggleDataItem(minorDataItem, true);
                            minorDataItem.setRaw("value", minorValue);
                            let minorEndValue = minorValue + getDuration(minorTimeUnit, minorCount * mmm);
                            //minorEndValue = $time.round(new Date(minorEndValue), minorGridInterval.timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
                            minorEndValue = roun(minorEndValue, minorTimeUnit, 1, root);
                            minorDataItem.setRaw("endValue", minorEndValue);
                            let date = new Date(minorValue);
                            format = minorFormats[minorTimeUnit];
                            const minorLabel = minorDataItem.get("label");
                            if (minorLabel) {
                                if (minorLabelsEnabled) {
                                    minorLabel.set("text", root.dateFormatter.format(date, format));
                                }
                                else {
                                    minorLabel.setPrivate("visible", false);
                                }
                            }
                            this._prepareDataItem(minorDataItem, 1);
                            if (minorValue == previousMinorValue) {
                                break;
                            }
                            previousMinorValue = minorValue;
                            minorValue = minorEndValue;
                            m++;
                        }
                    }
                    if (value == previousValue) {
                        break;
                    }
                    i++;
                }
                for (let j = i; j < this.dataItems.length; j++) {
                    this._toggleDataItem(this.dataItems[j], false);
                }
                for (let j = m; j < this.minorDataItems.length; j++) {
                    this._toggleDataItem(this.minorDataItems[j], false);
                }
                each$1(this.series, (series) => {
                    if (series.inited) {
                        series._markDirtyAxes();
                    }
                });
            }
            this._updateGhost();
        }
        _updateFinals(start, end) {
            this.setPrivateRaw("selectionMinFinal", this.positionToValue(start));
            this.setPrivateRaw("selectionMaxFinal", this.positionToValue(end));
        }
        _getDelta() {
            this._deltaMinMax = this.baseDuration() / 2;
        }
        _fixMin(min) {
            const baseInterval = this.getPrivate("baseInterval");
            const timeUnit = baseInterval.timeUnit;
            //let startTime = $time.round(new Date(min), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();
            let startTime = roun(min, timeUnit, baseInterval.count, this._root);
            let endTime = startTime + getDuration(timeUnit, baseInterval.count * this._getM(timeUnit));
            //endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
            endTime = roun(endTime, timeUnit, 1, this._root);
            return startTime + (endTime - startTime) * this.get("startLocation", 0);
        }
        _fixMax(max) {
            const baseInterval = this.getPrivate("baseInterval");
            const timeUnit = baseInterval.timeUnit;
            //let startTime = $time.round(new Date(max), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();
            let startTime = roun(max, timeUnit, baseInterval.count, this._root);
            let endTime = startTime + getDuration(timeUnit, baseInterval.count * this._getM(timeUnit));
            //endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
            endTime = roun(endTime, timeUnit, 1, this._root);
            return startTime + (endTime - startTime) * this.get("endLocation", 1);
        }
        _updateDates(_date, _series) {
        }
        /**
         * Returns a duration of currently active `baseInterval` in milliseconds.
         *
         * @return Duration
         */
        baseDuration() {
            return this._baseDuration;
            //return $time.getIntervalDuration(this.getPrivate("baseInterval"));
        }
        /**
         * Returns a duration of user-defined `baseInterval` in milliseconds.
         *
         * @return Duration
         */
        baseMainDuration() {
            return getIntervalDuration(this.get("baseInterval"));
        }
        /**
         * @ignore
         */
        processSeriesDataItem(dataItem, fields) {
            const baseInterval = this.getPrivate("baseInterval");
            if (!dataItem.open) {
                dataItem.open = {};
            }
            if (!dataItem.close) {
                dataItem.close = {};
            }
            each$1(fields, (field) => {
                let value = dataItem.get(field);
                if (isNumber(value)) {
                    let startTime = dataItem.open[field];
                    let endTime = dataItem.close[field];
                    // this is done to save cpu, as rounding is quite expensive, especially with timezone set. 
                    // if value is between prev start and end, it means it didn't change, all is fine.
                    if (value >= startTime && value <= endTime) ;
                    else {
                        const timeUnit = baseInterval.timeUnit;
                        const count = baseInterval.count;
                        //startTime = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();
                        startTime = roun(value, timeUnit, count, this._root);
                        endTime = startTime + getDuration(timeUnit, count * this._getM(timeUnit));
                        //endTime = $time.round(new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
                        endTime = roun(endTime, timeUnit, 1, this._root);
                        dataItem.open[field] = startTime;
                        dataItem.close[field] = endTime;
                    }
                    this._updateDates(startTime, dataItem.component);
                }
            });
        }
        _handleSizeDirty() {
            // void 
        }
        /**
         * @ignore
         */
        getDataItemPositionX(dataItem, field, cellLocation, axisLocation) {
            let openValue;
            let closeValue;
            if (dataItem.open && dataItem.close) {
                openValue = dataItem.open[field];
                closeValue = dataItem.close[field];
            }
            else {
                openValue = dataItem.get(field);
                closeValue = openValue;
            }
            let value = openValue + (closeValue - openValue) * cellLocation;
            value = this._baseValue + (value - this._baseValue) * axisLocation;
            return this.valueToPosition(value);
        }
        /**
         * @ignore
         */
        getDataItemCoordinateX(dataItem, field, cellLocation, axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));
        }
        /**
         * @ignore
         */
        getDataItemPositionY(dataItem, field, cellLocation, axisLocation) {
            let openValue;
            let closeValue;
            if (dataItem.open && dataItem.close) {
                openValue = dataItem.open[field];
                closeValue = dataItem.close[field];
            }
            else {
                openValue = dataItem.get(field);
                closeValue = openValue;
            }
            let value = openValue + (closeValue - openValue) * cellLocation;
            value = this._baseValue + (value - this._baseValue) * axisLocation;
            return this.valueToPosition(value);
        }
        /**
         * @ignore
         */
        getDataItemCoordinateY(dataItem, field, cellLocation, axisLocation) {
            return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));
        }
        /**
         * @ignore
         */
        roundAxisPosition(position, location) {
            let value = this.positionToValue(position);
            value = value - (location - 0.5) * this.baseDuration();
            let baseInterval = this.getPrivate("baseInterval");
            if (!isNaN$1(value)) {
                const firstDay = this._root.locale.firstDayOfWeek;
                const timeUnit = baseInterval.timeUnit;
                const utc = this._root.utc;
                const timezone = this._root.timezone;
                const count = baseInterval.count;
                //value = $time.round(new Date(value), timeUnit, count, firstDay, utc, new Date(this.getPrivate("min", 0)), timezone).getTime();
                value = roun(value, timeUnit, count, this._root, this.getPrivate("min", 0));
                let duration = getDateIntervalDuration(baseInterval, new Date(value), firstDay, utc, timezone);
                if (timezone) {
                    //value = $time.round(new Date(value + this.baseDuration() * 0.05), timeUnit, count, firstDay, utc, new Date(this.getPrivate("min", 0)), timezone).getTime();
                    value = roun(value + this.baseDuration() * 0.05, timeUnit, count, this._root, this.getPrivate("min", 0));
                    duration = getDateIntervalDuration(baseInterval, new Date(value + duration * location), firstDay, utc, timezone);
                }
                return this.valueToPosition(value + duration * location);
            }
            return NaN;
        }
        /**
         * Returns text to be used in an axis tooltip for specific relative position.
         *
         * NOTE: Unless `adjustPosition` (2nd parameter) is set to `false`, the method
         * will adjust position by `tooltipIntervalOffset`.
         *
         * @param  position        Position
         * @param  adjustPosition  Adjust position
         * @return                 Tooltip text
         */
        getTooltipText(position, adjustPosition) {
            //@todo number formatter + tag
            if (this.getPrivate("min") != null) {
                let format = this.get("tooltipDateFormats")[this.getPrivate("baseInterval").timeUnit];
                let value = this.positionToValue(position);
                if (isNumber(value)) {
                    let date = new Date(value);
                    let baseInterval = this.getPrivate("baseInterval");
                    let duration = getDateIntervalDuration(baseInterval, date, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);
                    if (adjustPosition !== false) {
                        date = new Date(value + this.get("tooltipIntervalOffset", -this.get("tooltipLocation", 0.5)) * duration);
                    }
                    return this._root.dateFormatter.format(date, this.get("tooltipDateFormat", format));
                }
            }
            return "";
        }
        /**
         * Returns a data item from series that is closest to the `position`.
         *
         * @param   series    Series
         * @param   position  Relative position
         * @return            Data item
         */
        getSeriesItem(series, position, location, snap) {
            let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
            let value = this.positionToValue(position);
            if (location == null) {
                location = 0.5;
            }
            value = value - (location - 0.5) * this.baseDuration();
            const result = getSortedIndex(series.dataItems, (dataItem) => {
                let diValue = 0;
                if (dataItem.open) {
                    diValue = dataItem.open[fieldName];
                }
                return compare(diValue, value);
            });
            if (snap || series.get("snapTooltip")) {
                let first = series.dataItems[result.index - 1];
                let second = series.dataItems[result.index];
                if (first && second) {
                    if (first.open && second.close) {
                        let open = first.open[fieldName];
                        let close = second.close[fieldName];
                        if (Math.abs(value - open) > Math.abs(value - close)) {
                            return second;
                        }
                    }
                }
                if (first) {
                    return first;
                }
                if (second) {
                    return second;
                }
            }
            else {
                const dataItem = series.dataItems[result.index - 1];
                if (dataItem) {
                    if (dataItem.open && dataItem.close) {
                        let open = dataItem.open[fieldName];
                        let close = dataItem.close[fieldName];
                        if (value >= open && value <= close) {
                            return dataItem;
                        }
                    }
                }
            }
        }
        /**
         * @ignore
         */
        shouldGap(dataItem, nextItem, autoGapCount, fieldName) {
            const value1 = dataItem.get(fieldName);
            const value2 = nextItem.get(fieldName);
            if (value2 - value1 > this.baseDuration() * autoGapCount) {
                return true;
            }
            return false;
        }
        /**
         * Zooms the axis to specific `start` and `end` dates.
         *
         * Optional `duration` specifies duration of zoom animation in milliseconds.
         *
         * @param  start     Start Date
         * @param  end       End Date
         * @param  duration  Duration in milliseconds
         */
        zoomToDates(start, end, duration) {
            this.zoomToValues(start.getTime(), end.getTime(), duration);
        }
        /**
         * Zooms the axis to specific `start` and `end` values.
         *
         * Optional `duration` specifies duration of zoom animation in milliseconds.
         *
         * @param  start     Start value
         * @param  end       End value
         * @param  duration  Duration in milliseconds
         */
        zoomToValues(start, end, duration) {
            const min = this.getPrivate("minFinal", 0);
            const max = this.getPrivate("maxFinal", 0);
            if (this.getPrivate("min") != null && this.getPrivate("max") != null) {
                if (this.get("groupData")) {
                    const futureGroupInterval = this.getGroupInterval(end - start);
                    const baseInterval = this.get("baseInterval");
                    let baseMin = this.getIntervalMin(baseInterval);
                    let baseMax = this.getIntervalMax(baseInterval) - 1;
                    baseMax = roun(baseMax, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);
                    baseMax += this._getM(futureGroupInterval.timeUnit) * getIntervalDuration(futureGroupInterval);
                    baseMax = roun(baseMax, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);
                    let futureMin = roun(baseMin, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);
                    let futureMax = roun(baseMax, futureGroupInterval.timeUnit, futureGroupInterval.count, this.root);
                    let s = (start - futureMin) / (futureMax - futureMin);
                    let e = (end - futureMin) / (futureMax - futureMin);
                    this.zoom(s, e, duration);
                }
                else {
                    this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);
                }
            }
        }
        /**
         * Returns a `Date` object corresponding to specific position within plot
         * area.
         *
         * @param   position  Pposition
         * @return            Date
         */
        positionToDate(position) {
            return new Date(this.positionToValue(position));
        }
        /**
         * Returns a relative position within plot area that corresponds to specific
         * date.
         *
         * @param   date  Date
         * @return        Position
         */
        dateToPosition(date) {
            return this.valueToPosition(date.getTime());
        }
        /**
         * Returns relative position between two grid lines of the axis.
         *
         * @since 5.2.30
         * @return Position
         */
        getCellWidthPosition() {
            let max = this.getPrivate("selectionMax", this.getPrivate("max"));
            let min = this.getPrivate("selectionMin", this.getPrivate("min"));
            if (isNumber(max) && isNumber(min)) {
                return this._intervalDuration / (max - min);
            }
            return 0.05;
        }
        nextPosition(count) {
            if (count == null) {
                count = 1;
            }
            let dtime = this.get("tooltipLocation", 0.5) * this.baseDuration();
            if (this.get("renderer").getPrivate("letter") == "Y") {
                count *= -1;
            }
            let tooltipValue = this.positionToValue(this.getPrivate("tooltipPosition", 0));
            const baseInterval = this.getPrivate("baseInterval");
            let time = this._nextTime(tooltipValue, count, baseInterval);
            let selectionMin = this.getPrivate("selectionMin", 0);
            let selectionMax = this.getPrivate("selectionMax", 0);
            let min = roun(selectionMin, baseInterval.timeUnit, baseInterval.count, this._root);
            let max = roun(selectionMax, baseInterval.timeUnit, baseInterval.count, this._root);
            time += dtime;
            time = fitToRange(time, min + dtime, max - dtime);
            return this.toGlobalPosition(this.valueToPosition(time));
        }
        _nextTime(time, count, baseInterval) {
            return roun(time + count * this.baseDuration(), baseInterval.timeUnit, baseInterval.count, this._root);
        }
    }
    Object.defineProperty(DateAxis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "DateAxis"
    });
    Object.defineProperty(DateAxis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ValueAxis.classNames.concat([DateAxis.className])
    });

    /**
     * A version of a [[DateAxis]] which removes intervals that don't have any data
     * items in them.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/gapless-date-axis/} for more info
     * @important
     */
    class GaplessDateAxis extends DateAxis {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_frequency", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_m", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_dates", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
            Object.defineProperty(this, "_customDates", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _afterNew() {
            this.valueFields.push("date");
            super._afterNew();
        }
        _getDates() {
            if (this._customDates) {
                return this._customDates;
            }
            return this._dates;
        }
        _updateDates(date, series) {
            if (!series.get("ignoreMinMax")) {
                const dates = this._getDates();
                const result = getSortedIndex(dates, (x) => compare(x, date));
                if (!result.found) {
                    insertIndex(dates, result.index, date);
                }
            }
        }
        _updateAllDates() {
            if (!this._customDates) {
                const dates = this._dates;
                dates.length = 0;
                each$1(this.series, (series) => {
                    let field = "valueX";
                    if (series.get("yAxis") == this) {
                        field = "valueY";
                    }
                    each$1(series.dataItems, (dataItem) => {
                        let value = dataItem.get(field);
                        if (isNumber(value)) {
                            if (dataItem.open) {
                                this._updateDates(dataItem.open[field], series);
                            }
                        }
                    });
                });
                const extraMax = this.get("extraMax", 0);
                const extraMin = this.get("extraMin", 0);
                let len = dates.length;
                const baseInterval = this.getPrivate("baseInterval");
                const baseCount = baseInterval.count;
                const timeUnit = baseInterval.timeUnit;
                if (extraMax > 0) {
                    const extra = len * extraMax;
                    let time = dates[len - 1];
                    if (isNumber(time)) {
                        for (let i = len - 1; i < len + extra; i++) {
                            time += getDuration(timeUnit, baseCount * this._getM(timeUnit));
                            //time = $time.round(new Date(time), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();
                            time = roun(time, timeUnit, baseCount, this._root);
                            dates.push(time);
                        }
                    }
                }
                if (extraMin > 0) {
                    const extra = len * extraMin;
                    let time = dates[0];
                    if (isNumber(time)) {
                        for (let i = 0; i < extra; i++) {
                            time -= getDuration(timeUnit, baseCount);
                            //time = $time.round(new Date(time), timeUnit, baseCount, firstDay, utc, undefined, timezone).getTime();
                            time = roun(time, timeUnit, baseCount, this._root);
                            dates.unshift(time);
                        }
                    }
                }
            }
        }
        /**
         * Convers value to a relative position on axis.
         *
         * @param   value  Value
         * @return         Relative position
         */
        valueToPosition(value) {
            const dates = this._getDates();
            const startLocation = this.get("startLocation", 0);
            const endLocation = this.get("endLocation", 1);
            const len = dates.length - startLocation - (1 - endLocation);
            const result = getSortedIndex(dates, (x) => compare(x, value));
            let index = result.index;
            if (result.found) {
                return (index - startLocation) / len;
            }
            else {
                if (index > 0) {
                    index -= 1;
                }
                let itemValue = dates[index];
                let d = 0;
                if (itemValue > value && value > this.getPrivate("min", 0)) {
                    d = itemValue - value;
                }
                else {
                    d = value - itemValue;
                }
                return (index - startLocation) / len + d / this.baseDuration() / len;
            }
        }
        /**
         * Converts numeric value from axis scale to index.
         *
         * @param  value  Value
         * @return        Index
         */
        valueToIndex(value) {
            const dates = this._getDates();
            const result = getSortedIndex(dates, (x) => compare(x, value));
            let index = result.index;
            if (result.found) {
                return index;
            }
            else {
                if (index > 0) {
                    index -= 1;
                }
                return index;
            }
        }
        /**
         * Converts a relative position to a corresponding numeric value from axis
         * scale.
         *
         * @param   position  Relative position
         * @return            Value
         */
        positionToValue(position) {
            const startLocation = this.get("startLocation", 0);
            const endLocation = this.get("endLocation", 1);
            const dates = this._getDates();
            let len = Math.round(dates.length - startLocation - (1 - endLocation));
            let index = position * len;
            let findex = Math.floor(index);
            if (findex < 0) {
                findex = 0;
            }
            if (findex > len - 1) {
                findex = len - 1;
            }
            return dates[findex] + (index - findex + startLocation) * this.baseDuration();
        }
        _fixZoomFactor() {
            this.setPrivateRaw("maxZoomFactor", this._getDates().length - this.get("startLocation", 0) - (1 - this.get("endLocation", 1)));
        }
        /**
         * Zooms the axis to specific `start` and `end` dates.
         *
         * Optional `duration` specifies duration of zoom animation in milliseconds.
         *
         * @param  start     Start Date
         * @param  end       End Date
         * @param  duration  Duration in milliseconds
         */
        zoomToDates(start, end, duration) {
            const dates = this._getDates();
            const len = dates.length;
            let result = getSortedIndex(dates, (x) => compare(x, start.getTime()));
            let startValue = dates[Math.min(result.index, len - 1)];
            result = getSortedIndex(dates, (x) => compare(x, end.getTime()));
            let endValue = dates[result.index];
            if (result.index >= len) {
                endValue = dates[len - 1] + this.baseDuration();
            }
            this.zoomToValues(startValue, endValue, duration);
        }
        /**
         * Zooms the axis to specific `start` and `end` values.
         *
         * Optional `duration` specifies duration of zoom animation in milliseconds.
         *
         * @param  start     Start value
         * @param  end       End value
         * @param  duration  Duration in milliseconds
         */
        zoomToValues(start, end, duration) {
            const min = this.getPrivate("min", 0);
            const max = this.getPrivate("max", 0);
            start = fitToRange(start, min, max);
            end = fitToRange(end, min, max);
            this.zoom(this.valueToPosition(start), this.valueToPosition(end), duration);
        }
        _prepareAxisItems() {
            let startTime = this.getPrivate("selectionMin", 0);
            let endTime = this.getPrivate("selectionMax", 0);
            if (isNumber(startTime) && isNumber(endTime)) {
                if (this._seriesValuesDirty) {
                    this._seriesValuesDirty = false;
                    this._updateAllDates();
                }
                const root = this._root;
                const utc = root.utc;
                const timezone = root.timezone;
                const dates = this._getDates();
                const renderer = this.get("renderer");
                const len = dates.length;
                const baseDuration = this.baseDuration();
                let startIndex = this.valueToIndex(startTime);
                if (startIndex > 0) {
                    startIndex--;
                }
                let endIndex = this.valueToIndex(endTime);
                if (endIndex < len - 1) {
                    endIndex++;
                }
                let maxCount = renderer.axisLength() / Math.max(renderer.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER);
                let frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));
                frequency = Math.max(1, frequency);
                startIndex = Math.floor(startIndex / frequency) * frequency;
                this._frequency = frequency;
                each$1(this.dataItems, (dataItem) => {
                    this._toggleDataItem(dataItem, false);
                });
                each$1(this.minorDataItems, (dataItem) => {
                    this._toggleDataItem(dataItem, false);
                });
                let realDuration = (endTime - startTime) - ((endTime - startTime) / baseDuration - (endIndex - startIndex)) * baseDuration;
                // if all items are on axis
                let gridInterval = chooseInterval(0, realDuration, maxCount, this.get("gridIntervals"));
                const baseInterval = this.getPrivate("baseInterval");
                let intervalDuration = getIntervalDuration(gridInterval);
                if (intervalDuration < baseDuration) {
                    gridInterval = Object.assign({}, baseInterval);
                    intervalDuration = getIntervalDuration(gridInterval);
                }
                this._intervalDuration = intervalDuration;
                const timeUnit = gridInterval.timeUnit;
                const formats = this.get("dateFormats");
                let firstTime = Date.now();
                if (dates[0]) {
                    firstTime = dates[0];
                }
                //let value = $time.round(new Date(this.getPrivate("selectionMin", 0)), timeUnit, gridInterval.count, firstDay, utc, firstDate, timezone).getTime();
                let value = roun(this.getPrivate("selectionMin", 0), timeUnit, gridInterval.count, root, firstTime);
                const minorLabelsEnabled = renderer.get("minorLabelsEnabled");
                const minorGridEnabled = renderer.get("minorGridEnabled", minorLabelsEnabled);
                let minorGridInterval;
                let minorDuration = 0;
                let previousDataItem;
                if (minorGridEnabled) {
                    minorGridInterval = this._getMinorInterval(gridInterval);
                    minorDuration = getIntervalDuration(minorGridInterval);
                }
                let selectedItems = this._getIndexes(value, this.getPrivate("selectionMax", value) + intervalDuration, gridInterval, this.getPrivate("min", value));
                if (selectedItems.length > 0) {
                    let i = 0;
                    this._m = 0;
                    let previousValue = value - intervalDuration * 10;
                    const nextGridUnit = getNextUnit(timeUnit);
                    // MINOR GRID
                    if (minorGridInterval) {
                        let first = dates[selectedItems[0]];
                        this._addMinorGrid(first - intervalDuration, first, minorDuration, minorGridInterval);
                    }
                    let minDistance = renderer.axisLength() / renderer.gridCount() * 0.5;
                    each$1(selectedItems, (index) => {
                        var _a;
                        let dataItem;
                        if (this.dataItems.length < i + 1) {
                            dataItem = new DataItem(this, undefined, {});
                            this._dataItems.push(dataItem);
                            this.processDataItem(dataItem);
                        }
                        else {
                            dataItem = this.dataItems[i];
                        }
                        let value = dates[index];
                        let date = new Date(value);
                        let endValue = value;
                        if (i < selectedItems.length - 1) {
                            endValue = dates[selectedItems[i + 1]];
                        }
                        else {
                            endValue += intervalDuration;
                        }
                        dataItem.setRaw("value", value);
                        dataItem.setRaw("endValue", endValue);
                        dataItem.setRaw("index", i);
                        dataItem.setRaw("labelEndValue", undefined);
                        let format = formats[timeUnit];
                        if (nextGridUnit && this.get("markUnitChange") && isNumber(previousValue)) {
                            if (timeUnit != "year") {
                                if (checkChange(value, previousValue, nextGridUnit, utc, timezone)) {
                                    format = this.get("periodChangeDateFormats")[timeUnit];
                                }
                            }
                        }
                        this._createAssets(dataItem, []);
                        const label = dataItem.get("label");
                        if (label) {
                            label.set("text", root.dateFormatter.format(date, format));
                        }
                        this._toggleDataItem(dataItem, true);
                        let count = gridInterval.count;
                        // so that labels of week would always be at the beginning of the grid
                        if (timeUnit == "week") {
                            dataItem.setRaw("labelEndValue", value);
                        }
                        if (minorGridEnabled) {
                            let timeUnit2 = gridInterval.timeUnit;
                            if (timeUnit2 == "week") {
                                timeUnit2 = "day";
                            }
                            if (count > 1 || gridInterval.timeUnit == "week") {
                                //let labelEndValue = $time.round(new Date(value), timeUnit2, 1, firstDay, utc, undefined, timezone).getTime() + $time.getDuration(timeUnit2, this._getM(timeUnit2));
                                let labelEndValue = roun(value, timeUnit2, 1, root) + getDuration(timeUnit2, this._getM(timeUnit2));
                                let index = this.valueToIndex(labelEndValue);
                                labelEndValue = dates[index];
                                if (labelEndValue == value) {
                                    let next = dates[index + 1];
                                    if (next) {
                                        labelEndValue = next;
                                    }
                                    else {
                                        labelEndValue += minorDuration;
                                    }
                                }
                                dataItem.setRaw("labelEndValue", labelEndValue);
                            }
                            count = 1;
                        }
                        this._prepareDataItem(dataItem, count);
                        if (label && previousDataItem) {
                            if (renderer.getPrivate("letter") == "X") {
                                let previousLabel = previousDataItem.get("label");
                                if (previousLabel) {
                                    let x = label.x();
                                    let previousX = previousLabel.x();
                                    if (x - previousX < minDistance) {
                                        let worse = this._pickWorse(previousDataItem, dataItem, gridInterval);
                                        if (worse) {
                                            (_a = worse.get("label")) === null || _a === void 0 ? void 0 : _a.setPrivate("visible", false);
                                        }
                                    }
                                }
                            }
                            // todo y?
                        }
                        // MINOR GRID
                        if (minorGridInterval) {
                            this._addMinorGrid(value, endValue, minorDuration, minorGridInterval);
                        }
                        i++;
                        if (label && label.getPrivate("visible")) {
                            previousDataItem = dataItem;
                        }
                        previousValue = value;
                    });
                }
                each$1(this.series, (series) => {
                    if (series.inited) {
                        series._markDirtyAxes();
                    }
                });
            }
            this._updateGhost();
        }
        _pickWorse(dataItemA, dataItemB, interval) {
            const timeUnit = interval.timeUnit;
            const valueA = dataItemA.get("value", 0);
            const valueB = dataItemB.get("value", 0);
            if (timeUnit == "hour") {
                if (new Date(valueA).getDate() != new Date(valueB).getDate()) {
                    return dataItemA;
                }
            }
            return dataItemB;
        }
        _addMinorGrid(startValue, endValue, minorDuration, gridInterval) {
            const minorFormats = this.get("minorDateFormats", this.get("dateFormats"));
            const mTimeUnit = gridInterval.timeUnit;
            let value = startValue + getDuration(mTimeUnit, this._getM(mTimeUnit));
            //value = $time.round(new Date(value), mTimeUnit, 1, firstDay, utc, undefined, timezone).getTime();
            value = roun(value, mTimeUnit, 1, this._root);
            let maxValue = endValue - minorDuration * 0.5;
            let minorSelectedItems = this._getIndexes(value, maxValue, gridInterval, value);
            const dates = this._getDates();
            each$1(minorSelectedItems, (index) => {
                let minorDataItem;
                if (this.minorDataItems.length < this._m + 1) {
                    minorDataItem = new DataItem(this, undefined, {});
                    this.minorDataItems.push(minorDataItem);
                    this.processDataItem(minorDataItem);
                }
                else {
                    minorDataItem = this.minorDataItems[this._m];
                }
                value = dates[index];
                minorDataItem.setRaw("value", value);
                minorDataItem.setRaw("endValue", value + minorDuration);
                minorDataItem.setRaw("index", index);
                this._createAssets(minorDataItem, ["minor"], true);
                const label = minorDataItem.get("label");
                if (label) {
                    if (this.get("renderer").get("minorLabelsEnabled")) {
                        let date = new Date(value);
                        let format = minorFormats[mTimeUnit];
                        label.set("text", this._root.dateFormatter.format(date, format));
                    }
                    else {
                        label.setPrivate("visible", false);
                    }
                }
                this._toggleDataItem(minorDataItem, true);
                this._prepareDataItem(minorDataItem, 1);
                this._m++;
            });
        }
        _getIndexes(value, maxValue, interval, firstValue) {
            const items = [];
            const timeUnit = interval.timeUnit;
            const count = interval.count;
            const mmm = this._getM(timeUnit);
            const baseInterval = this.getPrivate("baseInterval");
            const root = this._root;
            const dates = this._getDates();
            let c = count - 1;
            let previousValue = -Infinity;
            let duration = getDuration(timeUnit, mmm);
            let fullDuration = getDuration(timeUnit, count * mmm);
            let originalValue = value;
            if (timeUnit == "day") {
                value = firstValue;
            }
            while (value <= maxValue) {
                //value = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();
                value = roun(value, timeUnit, count, root);
                let index = this.valueToIndex(value);
                let realValue = dates[index];
                if (timeUnit == "day" && baseInterval.timeUnit == "day") {
                    if (this._hasDate(value)) {
                        c++;
                    }
                    if (c == count) {
                        if (value >= originalValue - fullDuration * 2) {
                            move(items, index);
                        }
                        c = 0;
                    }
                    value += duration;
                    //value = $time.round(new Date(value), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
                    value = roun(value, timeUnit, 1, root);
                }
                else {
                    if (realValue < value) {
                        for (let i = index, len = dates.length; i < len; i++) {
                            realValue = dates[i];
                            if (realValue >= value) {
                                index = i;
                                break;
                            }
                        }
                    }
                    move(items, index);
                    value += fullDuration;
                    //value = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();
                    value = roun(value, timeUnit, count, root);
                }
                if (value == previousValue) {
                    value += fullDuration + duration;
                    //value = $time.round(new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();
                    value = roun(value, timeUnit, count, root);
                }
                if (value == previousValue) {
                    break;
                }
                previousValue = value;
            }
            return items;
        }
        _hasDate(time) {
            const result = getSortedIndex(this._getDates(), (date) => {
                return compareNumber(date, time);
            });
            return result.found;
        }
        _nextTime(time, count, _baseInterval) {
            let index = fitToRange(this.valueToIndex(time) + count, 0, this._dates.length - 1);
            return this._dates[index];
        }
    }
    Object.defineProperty(GaplessDateAxis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "GaplessDateAxis"
    });
    Object.defineProperty(GaplessDateAxis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: DateAxis.classNames.concat([GaplessDateAxis.className])
    });

    /**
     * Creates a duration axis.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info
     * @important
     */
    class DurationAxis extends ValueAxis {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_dataGrouped", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_groupingCalculated", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_intervalDuration", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["axis"]);
            super._afterNew();
        }
        _adjustMinMax(min, max, gridCount, strictMode) {
            let minMaxStep;
            const durationFormatter = this.getDurationFormatter();
            const baseUnit = this.get("baseUnit");
            // we don't allow to go to smaller units, setting so to avoid invalidation
            this.setRaw("maxPrecision", 0);
            if (baseUnit == "millisecond" || baseUnit == "second" || baseUnit == "minute" || baseUnit == "hour") {
                // will fail if 0
                if (gridCount <= 1) {
                    gridCount = 1;
                }
                gridCount = Math.round(gridCount);
                //let initialMin: number = min;
                //let initialMax: number = max;
                let difference = max - min;
                // in case min and max is the same, use max
                if (difference === 0) {
                    difference = Math.abs(max);
                }
                let step = difference / gridCount;
                let divisors = [60, 30, 20, 15, 10, 2, 1];
                let realDivisor = 1;
                if (baseUnit == "hour") {
                    divisors = [24, 12, 6, 4, 2, 1];
                }
                for (let divisor of divisors) {
                    if (difference / divisor > gridCount) {
                        realDivisor = divisor;
                        break;
                    }
                }
                let count = Math.ceil(((max - min) / realDivisor) / gridCount);
                let exponent = Math.log(Math.abs(count)) * Math.LOG10E;
                let power = Math.pow(10, Math.floor(exponent)) / 10;
                let reducedCount = count / power;
                // find closest to divisor
                let closest$1 = closest(divisors, reducedCount);
                count = closest$1 * power;
                step = realDivisor * count;
                min = Math.floor(min / step) * step;
                max = Math.ceil(max / step) * step;
                /*
                causese SO with seconds
                if (strictMode) {
                    min -= step;
                    if (min < 0 && initialMin >= 0) {
                        min = 0;
                    }
                    max += step;

                    if (max > 0 && initialMax <= 0) {
                        max = 0;
                    }
                }*/
                minMaxStep = { min: min, max: max, step: step };
            }
            else {
                minMaxStep = super._adjustMinMax(min, max, gridCount, strictMode);
            }
            // choose duration formatter based on step
            this.setPrivateRaw("durationFormat", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));
            return minMaxStep;
        }
        _formatText(value) {
            const formatter = this.getDurationFormatter();
            return formatter.format(value, this.getPrivate("durationFormat"), this.get("baseUnit"));
        }
        /**
         * Returns text to be used in an axis tooltip for specific relative position.
         *
         * @param   position  Position
         * @return            Tooltip text
         */
        getTooltipText(position, _adjustPosition) {
            const formatter = this.getDurationFormatter();
            const extraDecimals = this.get("extraTooltipPrecision", 0);
            const decimals = this.getPrivate("stepDecimalPlaces", 0) + extraDecimals;
            const value = round$1(this.positionToValue(position), decimals);
            return formatter.format(value, this.getPrivate("durationFormat"), this.get("baseUnit"));
        }
    }
    Object.defineProperty(DurationAxis, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "DurationAxis"
    });
    Object.defineProperty(DurationAxis, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ValueAxis.classNames.concat([DurationAxis.className])
    });

    /**
     * Draws a bullet on an axis.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Axis_bullets} for more info
     */
    class AxisBullet extends Entity {
        constructor() {
            super(...arguments);
            /**
             * Target axis object.
             */
            Object.defineProperty(this, "axis", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        _beforeChanged() {
            super._beforeChanged();
            const sprite = this.get("sprite");
            if (this.isDirty("sprite")) {
                if (sprite) {
                    sprite.setAll({ position: "absolute", role: "figure" });
                    this._disposers.push(sprite);
                }
            }
            if (this.isDirty("location")) {
                const dataItem = sprite.dataItem;
                if (this.axis && sprite && dataItem) {
                    this.axis._prepareDataItem(dataItem);
                }
            }
        }
        dispose() {
            const axis = this.axis;
            if (axis) {
                each(axis._bullets, (key, bullet) => {
                    if (bullet.uid == this.uid) {
                        delete axis._bullets[key];
                    }
                });
            }
            super.dispose();
        }
    }
    Object.defineProperty(AxisBullet, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisBullet"
    });
    Object.defineProperty(AxisBullet, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Entity.classNames.concat([AxisBullet.className])
    });

    /**
     * Draws an axis label.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Labels} for more info
     * @important
     */
    class AxisLabel extends Label {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_tickPoints", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
        }
    }
    Object.defineProperty(AxisLabel, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisLabel"
    });
    Object.defineProperty(AxisLabel, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Label.classNames.concat([AxisLabel.className])
    });

    /**
     * Draws a label on a circular axis.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Labels} for more info
     */
    class AxisLabelRadial extends RadialLabel {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_tickPoints", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
        }
    }
    Object.defineProperty(AxisLabelRadial, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisLabelRadial"
    });
    Object.defineProperty(AxisLabelRadial, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: RadialLabel.classNames.concat([AxisLabelRadial.className])
    });

    /**
     * Draws an axis tick.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Ticks} for more info
     * @important
     */
    class AxisTick extends Tick {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_tickPoints", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: []
            });
        }
    }
    Object.defineProperty(AxisTick, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisTick"
    });
    Object.defineProperty(AxisTick, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Tick.classNames.concat([AxisTick.className])
    });

    /**
     * Base class for an axis renderer.
     *
     * Should not be used on its own.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
     */
    class AxisRenderer extends Graphics {
        constructor() {
            super(...arguments);
            // save for quick access
            Object.defineProperty(this, "_axisLength", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 100
            });
            Object.defineProperty(this, "_start", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_end", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_inversed", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: false
            });
            Object.defineProperty(this, "_minSize", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            /**
             * Chart the renderer is used in.
             */
            Object.defineProperty(this, "chart", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_lc", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
            Object.defineProperty(this, "_ls", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_thumbDownPoint", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_downStart", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_downEnd", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * A list of ticks in the axis.
             *
             * `ticks.template` can be used to configure ticks.
             *
             * @default new ListTemplate<AxisTick>
             */
            Object.defineProperty(this, "ticks", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => AxisTick._new(this._root, {
                    themeTags: mergeTags(this.ticks.template.get("themeTags", []), this.get("themeTags", []))
                }, [this.ticks.template]))
            });
            /**
             * A list of grid elements in the axis.
             *
             * `grid.template` can be used to configure grid.
             *
             * @default new ListTemplate<Grid>
             */
            Object.defineProperty(this, "grid", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Grid._new(this._root, {
                    themeTags: mergeTags(this.grid.template.get("themeTags", []), this.get("themeTags", []))
                }, [this.grid.template]))
            });
            /**
             * A list of fills in the axis.
             *
             * `axisFills.template` can be used to configure axis fills.
             *
             * @default new ListTemplate<Graphics>
             */
            Object.defineProperty(this, "axisFills", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Graphics._new(this._root, {
                    themeTags: mergeTags(this.axisFills.template.get("themeTags", ["axis", "fill"]), this.get("themeTags", []))
                }, [this.axisFills.template]))
            });
            /**
             * A list of labels in the axis.
             *
             * `labels.template` can be used to configure axis labels.
             *
             * @default new ListTemplate<AxisLabel>
             */
            Object.defineProperty(this, "labels", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => AxisLabel._new(this._root, {
                    themeTags: mergeTags(this.labels.template.get("themeTags", []), this.get("themeTags", []))
                }, [this.labels.template]))
            });
            /**
             * An [[Axis]] renderer is for.
             */
            Object.defineProperty(this, "axis", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * A thumb Graphics to be used for panning the axis (the one which shows under the labels when hovered)
             */
            Object.defineProperty(this, "thumb", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        /**
         * @ignore
         */
        makeTick(dataItem, themeTags) {
            const tick = this.ticks.make();
            tick._setDataItem(dataItem);
            dataItem.setRaw("tick", tick);
            tick.set("themeTags", mergeTags(tick.get("themeTags"), themeTags));
            this.axis.labelsContainer.children.push(tick);
            this.ticks.push(tick);
            return tick;
        }
        /**
         * @ignore
         */
        makeGrid(dataItem, themeTags) {
            const grid = this.grid.make();
            grid._setDataItem(dataItem);
            dataItem.setRaw("grid", grid);
            grid.set("themeTags", mergeTags(grid.get("themeTags"), themeTags));
            this.axis.gridContainer.children.push(grid);
            this.grid.push(grid);
            return grid;
        }
        /**
         * @ignore
         */
        makeAxisFill(dataItem, themeTags) {
            const axisFill = this.axisFills.make();
            axisFill._setDataItem(dataItem);
            axisFill.set("themeTags", mergeTags(axisFill.get("themeTags"), themeTags));
            this.axis.gridContainer.children.push(axisFill);
            dataItem.setRaw("axisFill", axisFill);
            this.axisFills.push(axisFill);
            return axisFill;
        }
        /**
         * @ignore
         */
        makeLabel(dataItem, themeTags) {
            const label = this.labels.make();
            label.set("themeTags", mergeTags(label.get("themeTags"), themeTags));
            this.axis.labelsContainer.children.moveValue(label, 0);
            label._setDataItem(dataItem);
            dataItem.setRaw("label", label);
            this.labels.push(label);
            return label;
        }
        axisLength() {
            return 0;
        }
        /**
         * @ignore
         */
        gridCount() {
            return this.axisLength() / this.get("minGridDistance", 50);
        }
        _updatePositions() {
        }
        _afterNew() {
            super._afterNew();
            this.set("isMeasured", false);
            const thumb = this.thumb;
            if (thumb) {
                this._disposers.push(thumb.events.on("pointerdown", (event) => {
                    this._handleThumbDown(event);
                }));
                this._disposers.push(thumb.events.on("globalpointerup", (event) => {
                    this._handleThumbUp(event);
                }));
                this._disposers.push(thumb.events.on("globalpointermove", (event) => {
                    this._handleThumbMove(event);
                }));
            }
        }
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("minGridDistance")) {
                this.root.events.once("frameended", () => {
                    this.axis.markDirtySize();
                });
            }
        }
        _changed() {
            super._changed();
            if (this.isDirty("pan")) {
                const thumb = this.thumb;
                if (thumb) {
                    const labelsContainer = this.axis.labelsContainer;
                    const pan = this.get("pan");
                    if (pan == "zoom") {
                        labelsContainer.children.push(thumb);
                    }
                    else if (pan == "none") {
                        labelsContainer.children.removeValue(thumb);
                    }
                }
            }
        }
        _handleThumbDown(event) {
            this._thumbDownPoint = this.toLocal(event.point);
            const axis = this.axis;
            this._downStart = axis.get("start");
            this._downEnd = axis.get("end");
        }
        _handleThumbUp(_event) {
            this._thumbDownPoint = undefined;
        }
        _handleThumbMove(event) {
            const downPoint = this._thumbDownPoint;
            if (downPoint) {
                const point = this.toLocal(event.point);
                const downStart = this._downStart;
                const downEnd = this._downEnd;
                const extra = this._getPan(point, downPoint) * Math.min(1, (downEnd - downStart)) / 2;
                this.axis.zoom(downStart - extra, downEnd + extra, 0);
            }
        }
        _getPan(_point1, _point2) {
            return 0;
        }
        /**
         * Converts relative position (0-1) on axis to a pixel coordinate.
         *
         * @param position  Position (0-1)
         * @return Coordinate (px)
         */
        positionToCoordinate(position) {
            if (this._inversed) {
                return (this._end - position) * this._axisLength;
            }
            else {
                return (position - this._start) * this._axisLength;
            }
        }
        /**
         * @ignore
         */
        updateTooltipBounds(_tooltip) { }
        _updateSize() {
            this.markDirty();
            this._clear = true;
        }
        /**
         * @ignore
         */
        toAxisPosition(position) {
            const start = this._start || 0;
            const end = this._end || 1;
            position = position * (end - start);
            if (!this.get("inversed")) {
                position = start + position;
            }
            else {
                position = end - position;
            }
            return position;
        }
        /**
         * @ignore
         */
        toGlobalPosition(position) {
            const start = this._start || 0;
            const end = this._end || 1;
            if (!this.get("inversed")) {
                position = position - start;
            }
            else {
                position = end - position;
            }
            position = position / (end - start);
            return position;
        }
        /**
         * @ignore
         */
        fixPosition(position) {
            if (this.get("inversed")) {
                return 1 - position;
            }
            return position;
        }
        /**
         * @ignore
         */
        _updateLC() {
        }
        toggleVisibility(sprite, position, minPosition, maxPosition) {
            let axis = this.axis;
            const start = axis.get("start", 0);
            const end = axis.get("end", 1);
            let updatedStart = start + (end - start) * (minPosition - 0.0001);
            let updatedEnd = start + (end - start) * (maxPosition + 0.0001);
            if (position < updatedStart || position > updatedEnd) {
                sprite.setPrivate("visible", false);
            }
            else {
                sprite.setPrivate("visible", true);
            }
        }
        _positionTooltip(tooltip, point) {
            const chart = this.chart;
            if (chart) {
                tooltip.set("pointTo", this._display.toGlobal(point));
                if (!chart.inPlot(point)) {
                    tooltip.hide();
                }
            }
        }
        processAxis() { }
    }
    Object.defineProperty(AxisRenderer, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisRenderer"
    });
    Object.defineProperty(AxisRenderer, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([AxisRenderer.className])
    });

    /**
     * Used to render horizontal axis.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
     * @important
     */
    class AxisRendererX extends AxisRenderer {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "thumb", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Rectangle.new(this._root, { width: p100, isMeasured: false, themeTags: ["axis", "x", "thumb"] })
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["renderer", "x"]);
            super._afterNew();
            this.setPrivateRaw("letter", "X");
            const gridTemplate = this.grid.template;
            gridTemplate.set("height", p100);
            gridTemplate.set("width", 0);
            gridTemplate.set("draw", (display, graphics) => {
                display.moveTo(0, 0);
                display.lineTo(0, graphics.height());
            });
            this.set("draw", (display, graphics) => {
                display.moveTo(0, 0);
                display.lineTo(graphics.width(), 0);
            });
        }
        _changed() {
            super._changed();
            const axis = this.axis;
            axis.ghostLabel.setPrivate("visible", !this.get("inside"));
            axis.ghostLabel.set("x", -1000);
            const opposite = "opposite";
            const inside = "inside";
            if (this.isDirty(opposite) || this.isDirty(inside)) {
                const chart = this.chart;
                const axisChildren = axis.children;
                if (this.get(inside)) {
                    axis.addTag(inside);
                }
                else {
                    axis.removeTag(inside);
                }
                if (chart) {
                    if (this.get(opposite)) {
                        const children = chart.topAxesContainer.children;
                        if (children.indexOf(axis) == -1) {
                            children.insertIndex(0, axis);
                        }
                        axis.addTag(opposite);
                        axisChildren.moveValue(this);
                    }
                    else {
                        const children = chart.bottomAxesContainer.children;
                        if (children.indexOf(axis) == -1) {
                            children.moveValue(axis);
                        }
                        axis.removeTag(opposite);
                        axisChildren.moveValue(this, 0);
                    }
                    axis.ghostLabel._applyThemes();
                    this.labels.each((label) => {
                        label._applyThemes();
                    });
                    this.root._markDirtyRedraw();
                }
                axis.markDirtySize();
            }
            this.thumb.setPrivate("height", axis.labelsContainer.height());
        }
        _getPan(point1, point2) {
            return (point2.x - point1.x) / this.width();
        }
        /**
         * @ignore
         */
        toAxisPosition(position) {
            const start = this._start || 0;
            const end = this._end || 1;
            position -= this._ls;
            position = position * (end - start) / this._lc;
            if (!this.get("inversed")) {
                position = start + position;
            }
            else {
                position = end - position;
            }
            return position;
        }
        /**
         * @ignore
         */
        toGlobalPosition(position) {
            const start = this._start || 0;
            const end = this._end || 1;
            if (!this.get("inversed")) {
                position = position - start;
            }
            else {
                position = end - position;
            }
            position = position / (end - start) * this._lc;
            position += this._ls;
            return position;
        }
        /**
         * @ignore
         */
        _updateLC() {
            const axis = this.axis;
            const parent = axis.parent;
            if (parent) {
                const w = parent.innerWidth();
                this._lc = this.axisLength() / w;
                this._ls = (axis.x() - parent.get("paddingLeft", 0)) / w;
            }
        }
        /**
         * @ignore
         */
        _updatePositions() {
            const axis = this.axis;
            const x = axis.x() - relativeToValue(axis.get("centerX", 0), axis.width()) - axis.parent.get("paddingLeft", 0);
            axis.gridContainer.set("x", x);
            axis.topGridContainer.set("x", x);
            axis.bulletsContainer.set("y", this.y());
            const chart = axis.chart;
            if (chart) {
                const plotContainer = chart.plotContainer;
                const axisHeader = axis.axisHeader;
                let width = axis.get("marginLeft", 0);
                let x = axis.x() - width;
                const parent = axis.parent;
                if (parent) {
                    x -= parent.get("paddingLeft", 0);
                }
                if (axisHeader.children.length > 0) {
                    width = axis.axisHeader.width();
                    axis.set("marginLeft", width + 1);
                }
                else {
                    axisHeader.set("width", width);
                }
                axisHeader.setAll({ x: x, y: -1, height: plotContainer.height() + 2 });
            }
        }
        /**
         * @ignore
         */
        processAxis() {
            super.processAxis();
            const axis = this.axis;
            if (axis.get("width") == null) {
                axis.set("width", p100);
            }
            const verticalLayout = this._root.verticalLayout;
            axis.set("layout", verticalLayout);
            axis.labelsContainer.set("width", p100);
            axis.axisHeader.setAll({ layout: verticalLayout });
        }
        /**
         * @ignore
         */
        axisLength() {
            return this.axis.width();
        }
        /**
         * Converts axis relative position to actual coordinate in pixels.
         *
         * @param   position  Position
         * @return            Point
         */
        positionToPoint(position) {
            return { x: this.positionToCoordinate(position), y: 0 };
        }
        /**
         * @ignore
         */
        updateTick(tick, position, endPosition, count) {
            if (tick) {
                if (!isNumber(position)) {
                    position = 0;
                }
                let location = 0.5;
                if (isNumber(count) && count > 1) {
                    location = tick.get("multiLocation", location);
                }
                else {
                    location = tick.get("location", location);
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                tick.set("x", this.positionToCoordinate(position));
                let length = tick.get("length", 0);
                const inside = tick.get("inside", this.get("inside", false));
                if (this.get("opposite")) {
                    tick.set("y", p100);
                    if (!inside) {
                        length *= -1;
                    }
                }
                else {
                    tick.set("y", 0);
                    if (inside) {
                        length *= -1;
                    }
                }
                tick.set("draw", (display) => {
                    display.moveTo(0, 0);
                    display.lineTo(0, length);
                });
                this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
            }
        }
        /**
         * @ignore
         */
        updateLabel(label, position, endPosition, count) {
            if (label) {
                let location = 0.5;
                if (isNumber(count) && count > 1) {
                    location = label.get("multiLocation", location);
                }
                else {
                    location = label.get("location", location);
                }
                if (!isNumber(position)) {
                    position = 0;
                }
                const inside = label.get("inside", this.get("inside", false));
                const opposite = this.get("opposite");
                if (opposite) {
                    if (!inside) {
                        label.set("position", "relative");
                        label.set("y", p100);
                    }
                    else {
                        label.set("position", "absolute");
                        label.set("y", 0);
                    }
                }
                else {
                    if (!inside) {
                        label.set("y", undefined);
                        label.set("position", "relative");
                    }
                    else {
                        label.set("y", 0);
                        label.set("position", "absolute");
                    }
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                label.set("x", this.positionToCoordinate(position));
                this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
            }
        }
        /**
         * @ignore
         */
        updateGrid(grid, position, endPosition) {
            if (grid) {
                if (!isNumber(position)) {
                    position = 0;
                }
                let location = grid.get("location", 0.5);
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                grid.set("x", this.positionToCoordinate(position));
                this.toggleVisibility(grid, position, 0, 1);
            }
        }
        /**
         * @ignore
         */
        updateBullet(bullet, position, endPosition) {
            if (bullet) {
                const sprite = bullet.get("sprite");
                if (sprite) {
                    if (!isNumber(position)) {
                        position = 0;
                    }
                    let location = bullet.get("location", 0.5);
                    if (isNumber(endPosition) && endPosition != position) {
                        position = position + (endPosition - position) * location;
                    }
                    let bulletPosition = this.axis.roundAxisPosition(position, location);
                    let previousBullet = this.axis._bullets[bulletPosition];
                    let d = -1;
                    if (this.get("opposite")) {
                        d = 1;
                    }
                    if (bullet.get("stacked")) {
                        if (previousBullet) {
                            let previousSprite = previousBullet.get("sprite");
                            if (previousSprite) {
                                sprite.set("y", previousSprite.y() + previousSprite.height() * d);
                            }
                        }
                        else {
                            sprite.set("y", 0);
                        }
                    }
                    this.axis._bullets[bulletPosition] = bullet;
                    sprite.set("x", this.positionToCoordinate(position));
                    this.toggleVisibility(sprite, position, 0, 1);
                }
            }
        }
        /**
         * @ignore
         */
        updateFill(fill, position, endPosition) {
            if (fill) {
                if (!isNumber(position)) {
                    position = 0;
                }
                if (!isNumber(endPosition)) {
                    endPosition = 1;
                }
                let x0 = this.positionToCoordinate(position);
                let x1 = this.positionToCoordinate(endPosition);
                this.fillDrawMethod(fill, x0, x1);
            }
        }
        fillDrawMethod(fill, x0, x1) {
            fill.set("draw", (display) => {
                //display.drawRect(x0, 0, x1 - x0, this.axis!.gridContainer.height());
                // using for holes, so can not be rectangle
                const h = this.axis.gridContainer.height();
                const w = this.width();
                if (x1 < x0) {
                    [x1, x0] = [x0, x1];
                }
                if (x0 > w || x1 < 0) {
                    return;
                }
                /*
                const limit = 10000;

                x0 = Math.max(-limit, x0);
                x1 = Math.min(limit, x1);
                */
                display.moveTo(x0, 0);
                display.lineTo(x1, 0);
                display.lineTo(x1, h);
                display.lineTo(x0, h);
                display.lineTo(x0, 0);
            });
        }
        /**
         * @ignore
         */
        positionTooltip(tooltip, position) {
            this._positionTooltip(tooltip, { x: this.positionToCoordinate(position), y: 0 });
        }
        /**
         * @ignore
         */
        updateTooltipBounds(tooltip) {
            const inside = this.get("inside");
            const num = 100000;
            let global = this._display.toGlobal({ x: 0, y: 0 });
            let x = global.x;
            let y = 0;
            let w = this.axisLength();
            let h = num;
            let pointerOrientation = "up";
            if (this.get("opposite")) {
                if (inside) {
                    pointerOrientation = "up";
                    y = global.y;
                    h = num;
                }
                else {
                    pointerOrientation = "down";
                    y = global.y - num;
                    h = num;
                }
            }
            else {
                if (inside) {
                    pointerOrientation = "down";
                    y = global.y - num;
                    h = num;
                }
                else {
                    pointerOrientation = "up";
                    y = global.y;
                    h = num;
                }
            }
            const bounds = { left: x, right: x + w, top: y, bottom: y + h };
            const oldBounds = tooltip.get("bounds");
            if (!sameBounds(bounds, oldBounds)) {
                tooltip.set("bounds", bounds);
                tooltip.set("pointerOrientation", pointerOrientation);
            }
        }
    }
    Object.defineProperty(AxisRendererX, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisRendererX"
    });
    Object.defineProperty(AxisRendererX, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: AxisRenderer.classNames.concat([AxisRendererX.className])
    });

    /**
     * Used to render vertical axis.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
     * @important
     */
    class AxisRendererY extends AxisRenderer {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_downY", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "thumb", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Rectangle.new(this._root, { height: p100, isMeasured: false, themeTags: ["axis", "y", "thumb"] })
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["renderer", "y"]);
            if (this._settings.opposite) {
                this._settings.themeTags.push("opposite");
            }
            super._afterNew();
            this.setPrivateRaw("letter", "Y");
            const gridTemplate = this.grid.template;
            gridTemplate.set("width", p100);
            gridTemplate.set("height", 0);
            gridTemplate.set("draw", (display, graphics) => {
                display.moveTo(0, 0);
                display.lineTo(graphics.width(), 0);
            });
            this.set("draw", (display, renderer) => {
                display.moveTo(0, 0);
                display.lineTo(0, renderer.height());
            });
        }
        _getPan(point1, point2) {
            return (point1.y - point2.y) / this.height();
        }
        _changed() {
            super._changed();
            const axis = this.axis;
            axis.ghostLabel.setPrivate("visible", !this.get("inside"));
            axis.ghostLabel.set("y", -1000);
            const thumb = this.thumb;
            const opposite = "opposite";
            const inside = "inside";
            const chart = this.chart;
            if (this.isDirty(opposite) || this.isDirty(inside)) {
                const axisChildren = axis.children;
                if (this.get(inside)) {
                    axis.addTag(inside);
                }
                else {
                    axis.removeTag(inside);
                }
                if (chart) {
                    if (this.get(opposite)) {
                        const children = chart.rightAxesContainer.children;
                        if (children.indexOf(axis) == -1) {
                            children.moveValue(axis, 0);
                        }
                        axis.addTag(opposite);
                        axisChildren.moveValue(this, 0);
                    }
                    else {
                        const children = chart.leftAxesContainer.children;
                        if (children.indexOf(axis) == -1) {
                            children.moveValue(axis);
                        }
                        axis.removeTag(opposite);
                        axisChildren.moveValue(this);
                    }
                    axis.ghostLabel._applyThemes();
                    this.labels.each((label) => {
                        label._applyThemes();
                    });
                    this.root._markDirtyRedraw();
                }
                axis.markDirtySize();
            }
            const w = axis.labelsContainer.width();
            if (chart) {
                if (this.get(opposite)) {
                    thumb.set("centerX", 0);
                }
                else {
                    thumb.set("centerX", w);
                }
            }
            thumb.setPrivate("width", w);
        }
        /**
         * @ignore
         */
        processAxis() {
            super.processAxis();
            const axis = this.axis;
            if (axis.get("height") == null) {
                axis.set("height", p100);
            }
            const horizontalLayout = this._root.horizontalLayout;
            axis.set("layout", horizontalLayout);
            axis.labelsContainer.set("height", p100);
            axis.axisHeader.set("layout", horizontalLayout);
        }
        _updatePositions() {
            const axis = this.axis;
            const y = axis.y() - relativeToValue(axis.get("centerY", 0), axis.height());
            axis.gridContainer.set("y", y);
            axis.topGridContainer.set("y", y);
            axis.bulletsContainer.set("x", this.x());
            const chart = axis.chart;
            if (chart) {
                const plotContainer = chart.plotContainer;
                const axisHeader = axis.axisHeader;
                let height = axis.get("marginTop", 0);
                if (axisHeader.children.length > 0) {
                    height = axis.axisHeader.height();
                    axis.set("marginTop", height + 1);
                }
                else {
                    axisHeader.set("height", height);
                }
                axisHeader.setAll({ y: axis.y() - height, x: -1, width: plotContainer.width() + 2 });
            }
        }
        /**
         * @ignore
         */
        axisLength() {
            return this.axis.innerHeight();
        }
        /**
         * Converts axis relative position to actual coordinate in pixels.
         *
         * @param   position  Position
         * @return            Point
         */
        positionToPoint(position) {
            return { x: 0, y: this.positionToCoordinate(position) };
        }
        /**
         * @ignore
         */
        updateLabel(label, position, endPosition, count) {
            if (label) {
                if (!isNumber(position)) {
                    position = 0;
                }
                let location = 0.5;
                if (isNumber(count) && count > 1) {
                    location = label.get("multiLocation", location);
                }
                else {
                    location = label.get("location", location);
                }
                const opposite = this.get("opposite");
                const inside = label.get("inside", this.get("inside", false));
                if (opposite) {
                    label.set("x", 0);
                    if (inside) {
                        label.set("position", "absolute");
                    }
                    else {
                        label.set("position", "relative");
                    }
                }
                else {
                    if (inside) {
                        label.set("x", 0);
                        label.set("position", "absolute");
                    }
                    else {
                        label.set("x", undefined);
                        label.set("position", "relative");
                    }
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                label.set("y", this.positionToCoordinate(position));
                this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
            }
        }
        /**
         * @ignore
         */
        updateGrid(grid, position, endPosition) {
            if (grid) {
                if (!isNumber(position)) {
                    position = 0;
                }
                let location = grid.get("location", 0.5);
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                grid.set("y", this.positionToCoordinate(position));
                this.toggleVisibility(grid, position, 0, 1);
            }
        }
        /**
         * @ignore
         */
        updateTick(tick, position, endPosition, count) {
            if (tick) {
                if (!isNumber(position)) {
                    position = 0;
                }
                let location = 0.5;
                if (isNumber(count) && count > 1) {
                    location = tick.get("multiLocation", location);
                }
                else {
                    location = tick.get("location", location);
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                tick.set("y", this.positionToCoordinate(position));
                let length = tick.get("length", 0);
                const inside = tick.get("inside", this.get("inside", false));
                if (this.get("opposite")) {
                    tick.set("x", 0);
                    if (inside) {
                        length *= -1;
                    }
                }
                else {
                    if (!inside) {
                        length *= -1;
                    }
                }
                tick.set("draw", (display) => {
                    display.moveTo(0, 0);
                    display.lineTo(length, 0);
                });
                this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
            }
        }
        /**
         * @ignore
         */
        updateBullet(bullet, position, endPosition) {
            if (bullet) {
                const sprite = bullet.get("sprite");
                if (sprite) {
                    if (!isNumber(position)) {
                        position = 0;
                    }
                    let location = bullet.get("location", 0.5);
                    if (isNumber(endPosition) && endPosition != position) {
                        position = position + (endPosition - position) * location;
                    }
                    let bulletPosition = this.axis.roundAxisPosition(position, location);
                    let previousBullet = this.axis._bullets[bulletPosition];
                    let d = 1;
                    if (this.get("opposite")) {
                        d = -1;
                    }
                    if (bullet.get("stacked")) {
                        if (previousBullet) {
                            let previousSprite = previousBullet.get("sprite");
                            if (previousSprite) {
                                sprite.set("x", previousSprite.x() + previousSprite.width() * d);
                            }
                        }
                        else {
                            sprite.set("x", 0);
                        }
                    }
                    this.axis._bullets[bulletPosition] = bullet;
                    sprite.set("y", this.positionToCoordinate(position));
                    this.toggleVisibility(sprite, position, 0, 1);
                }
            }
        }
        /**
         * @ignore
         */
        updateFill(fill, position, endPosition) {
            if (fill) {
                if (!isNumber(position)) {
                    position = 0;
                }
                if (!isNumber(endPosition)) {
                    endPosition = 1;
                }
                let y0 = this.positionToCoordinate(position);
                let y1 = this.positionToCoordinate(endPosition);
                this.fillDrawMethod(fill, y0, y1);
            }
        }
        fillDrawMethod(fill, y0, y1) {
            fill.set("draw", (display) => {
                // using for holes, so can not be rectangle
                const w = this.axis.gridContainer.width();
                const h = this.height();
                if (y1 < y0) {
                    [y1, y0] = [y0, y1];
                }
                if (y0 > h || y1 < 0) {
                    return;
                }
                //y0 = Math.max(0, y0);
                //y1 = Math.min(h, y1);
                display.moveTo(0, y0);
                display.lineTo(w, y0);
                display.lineTo(w, y1);
                display.lineTo(0, y1);
                display.lineTo(0, y0);
            });
        }
        /**
         * Converts relative position (0-1) on axis to a pixel coordinate.
         *
         * @param position  Position (0-1)
         * @return Coordinate (px)
         */
        positionToCoordinate(position) {
            if (!this._inversed) {
                return (this._end - position) * this._axisLength;
            }
            else {
                return (position - this._start) * this._axisLength;
            }
        }
        /**
         * @ignore
         */
        positionTooltip(tooltip, position) {
            this._positionTooltip(tooltip, { x: 0, y: this.positionToCoordinate(position) });
        }
        /**
         * @ignore
         */
        updateTooltipBounds(tooltip) {
            const inside = this.get("inside");
            const num = 100000;
            let global = this._display.toGlobal({ x: 0, y: 0 });
            let y = global.y;
            let x = 0;
            let h = this.axisLength();
            let w = num;
            let pointerOrientation = "right";
            if (this.get("opposite")) {
                if (inside) {
                    pointerOrientation = "right";
                    x = global.x - num;
                    w = num;
                }
                else {
                    pointerOrientation = "left";
                    x = global.x;
                    w = num;
                }
            }
            else {
                if (inside) {
                    pointerOrientation = "left";
                    x = global.x;
                    w = num;
                }
                else {
                    pointerOrientation = "right";
                    x = global.x - num;
                    w = num;
                }
            }
            const bounds = { left: x, right: x + w, top: y, bottom: y + h };
            const oldBounds = tooltip.get("bounds");
            if (!sameBounds(bounds, oldBounds)) {
                tooltip.set("bounds", bounds);
                tooltip.set("pointerOrientation", pointerOrientation);
            }
        }
        /**
         * @ignore
         */
        _updateLC() {
            const axis = this.axis;
            const parent = axis.parent;
            if (parent) {
                const h = parent.innerHeight();
                this._lc = this.axisLength() / h;
                this._ls = axis.y() / h;
            }
        }
        /**
         * @ignore
         */
        toAxisPosition(position) {
            const start = this._start || 0;
            const end = this._end || 1;
            position -= this._ls;
            position = position * (end - start) / this._lc;
            if (this.get("inversed")) {
                position = start + position;
            }
            else {
                position = end - position;
            }
            return position;
        }
        /**
         * @ignore
         */
        toGlobalPosition(position) {
            const start = this._start || 0;
            const end = this._end || 1;
            if (this.get("inversed")) {
                position = position - start;
            }
            else {
                position = end - position;
            }
            position = position / (end - start) * this._lc;
            position += this._ls;
            return position;
        }
        /**
         * @ignore
         */
        fixPosition(position) {
            if (!this.get("inversed")) {
                return 1 - position;
            }
            return position;
        }
    }
    Object.defineProperty(AxisRendererY, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisRendererY"
    });
    Object.defineProperty(AxisRendererY, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: AxisRenderer.classNames.concat([AxisRendererY.className])
    });

    /**
     * A candle element used in a [[CandlestickSeries]].
     */
    class Candlestick extends RoundedRectangle {
        _beforeChanged() {
            super._beforeChanged();
            if (this.isDirty("lowX0") || this.isDirty("lowY0") || this.isDirty("lowX1") || this.isDirty("lowY1") || this.isDirty("highX0") || this.isDirty("highX1") || this.isDirty("highY0") || this.isDirty("highY1")) {
                this._clear = true;
            }
        }
        _draw() {
            super._draw();
            const display = this._display;
            display.moveTo(this.get("lowX0", 0), this.get("lowY0", 0));
            display.lineTo(this.get("lowX1", 0), this.get("lowY1", 0));
            display.moveTo(this.get("highX0", 0), this.get("highY0", 0));
            display.lineTo(this.get("highX1", 0), this.get("highY1", 0));
        }
    }
    Object.defineProperty(Candlestick, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "Candlestick"
    });
    Object.defineProperty(Candlestick, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: RoundedRectangle.classNames.concat([Candlestick.className])
    });

    class ColumnSeries extends BaseColumnSeries {
        constructor() {
            super(...arguments);
            /**
             * A [[TemplateList]] of all columns in series.
             *
             * `columns.template` can be used to set default settings for all columns,
             * or to change on existing ones.
             */
            Object.defineProperty(this, "columns", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {
                    position: "absolute",
                    themeTags: mergeTags(this.columns.template.get("themeTags", []), ["series", "column"])
                }, [this.columns.template]))
            });
        }
        /**
         * @ignore
         */
        makeColumn(dataItem, listTemplate) {
            const column = this.mainContainer.children.push(listTemplate.make());
            column._setDataItem(dataItem);
            listTemplate.push(column);
            return column;
        }
        _processAxisRange(axisRange) {
            super._processAxisRange(axisRange);
            axisRange.columns = new ListTemplate(Template.new({}), () => RoundedRectangle._new(this._root, {
                position: "absolute",
                themeTags: mergeTags(axisRange.columns.template.get("themeTags", []), ["series", "column"]),
            }, [this.columns.template, axisRange.columns.template]));
        }
    }
    Object.defineProperty(ColumnSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ColumnSeries"
    });
    Object.defineProperty(ColumnSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: BaseColumnSeries.classNames.concat([ColumnSeries.className])
    });

    /**
     * Candlestick series.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/candlestick-series/} for more info
     * @important
     */
    class CandlestickSeries extends ColumnSeries {
        constructor() {
            super(...arguments);
            /**
             * A list of candles in the series.
             *
             * `columns.template` can be used to configure candles.
             *
             * @default new ListTemplate<Candlestick>
             */
            Object.defineProperty(this, "columns", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({
                    themeTags: ["autocolor"]
                }), () => Candlestick._new(this._root, {
                    themeTags: mergeTags(this.columns.template.get("themeTags", []), ["candlestick", "series", "column"])
                }, [this.columns.template]))
            });
        }
        /**
         * @ignore
         */
        makeColumn(dataItem, listTemplate) {
            const column = this.mainContainer.children.push(listTemplate.make());
            column._setDataItem(dataItem);
            listTemplate.push(column);
            return column;
        }
        _updateGraphics(dataItem, previousDataItem) {
            super._updateGraphics(dataItem, previousDataItem);
            const xAxis = this.getRaw("xAxis");
            const yAxis = this.getRaw("yAxis");
            const baseAxis = this.getRaw("baseAxis");
            let vcy = this.get("vcy", 1);
            let vcx = this.get("vcx", 1);
            let lx0;
            let lx1;
            let ly0;
            let ly1;
            let hx0;
            let hx1;
            let hy0;
            let hy1;
            let locationX = this.get("locationX", dataItem.get("locationX", 0.5));
            let locationY = this.get("locationY", dataItem.get("locationY", 0.5));
            let openLocationX = this.get("openLocationX", dataItem.get("openLocationX", locationX));
            let openLocationY = this.get("openLocationY", dataItem.get("openLocationY", locationY));
            let orientation;
            if (yAxis === baseAxis) {
                let open = xAxis.getDataItemPositionX(dataItem, this._xOpenField, 1, vcx);
                let close = xAxis.getDataItemPositionX(dataItem, this._xField, 1, vcx);
                lx1 = xAxis.getDataItemPositionX(dataItem, this._xLowField, 1, vcx);
                hx1 = xAxis.getDataItemPositionX(dataItem, this._xHighField, 1, vcx);
                hx0 = Math.max(open, close);
                lx0 = Math.min(open, close);
                let startLocation = this._aLocationY0 + openLocationY - 0.5;
                let endLocation = this._aLocationY1 + locationY - 0.5;
                ly0 = yAxis.getDataItemPositionY(dataItem, this._yField, startLocation + (endLocation - startLocation) / 2, vcy);
                ly1 = ly0;
                hy0 = ly0;
                hy1 = ly0;
                orientation = "horizontal";
            }
            else {
                let open = yAxis.getDataItemPositionY(dataItem, this._yOpenField, 1, vcy);
                let close = yAxis.getDataItemPositionY(dataItem, this._yField, 1, vcy);
                ly1 = yAxis.getDataItemPositionY(dataItem, this._yLowField, 1, vcy);
                hy1 = yAxis.getDataItemPositionY(dataItem, this._yHighField, 1, vcy);
                hy0 = Math.max(open, close);
                ly0 = Math.min(open, close);
                let startLocation = this._aLocationX0 + openLocationX - 0.5;
                let endLocation = this._aLocationX1 + locationX - 0.5;
                lx0 = xAxis.getDataItemPositionX(dataItem, this._xField, startLocation + (endLocation - startLocation) / 2, vcx);
                lx1 = lx0;
                hx0 = lx0;
                hx1 = lx0;
                orientation = "vertical";
            }
            this._updateCandleGraphics(dataItem, lx0, lx1, ly0, ly1, hx0, hx1, hy0, hy1, orientation);
        }
        _updateCandleGraphics(dataItem, lx0, lx1, ly0, ly1, hx0, hx1, hy0, hy1, orientation) {
            let column = dataItem.get("graphics");
            if (column) {
                let pl0 = this.getPoint(lx0, ly0);
                let pl1 = this.getPoint(lx1, ly1);
                let ph0 = this.getPoint(hx0, hy0);
                let ph1 = this.getPoint(hx1, hy1);
                let x = column.x();
                let y = column.y();
                column.set("lowX0", pl0.x - x);
                column.set("lowY0", pl0.y - y);
                column.set("lowX1", pl1.x - x);
                column.set("lowY1", pl1.y - y);
                column.set("highX0", ph0.x - x);
                column.set("highY0", ph0.y - y);
                column.set("highX1", ph1.x - x);
                column.set("highY1", ph1.y - y);
                column.set("orientation", orientation);
                let rangeGraphics = dataItem.get("rangeGraphics");
                if (rangeGraphics) {
                    each$1(rangeGraphics, (column) => {
                        column.set("lowX0", pl0.x - x);
                        column.set("lowY0", pl0.y - y);
                        column.set("lowX1", pl1.x - x);
                        column.set("lowY1", pl1.y - y);
                        column.set("highX0", ph0.x - x);
                        column.set("highY0", ph0.y - y);
                        column.set("highX1", ph1.x - x);
                        column.set("highY1", ph1.y - y);
                        column.set("orientation", orientation);
                    });
                }
            }
        }
        _processAxisRange(axisRange) {
            super._processAxisRange(axisRange);
            axisRange.columns = new ListTemplate(Template.new({}), () => Candlestick._new(this._root, {
                themeTags: mergeTags(axisRange.columns.template.get("themeTags", []), ["candlestick", "series", "column"]),
            }, [this.columns.template, axisRange.columns.template]));
        }
    }
    Object.defineProperty(CandlestickSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CandlestickSeries"
    });
    Object.defineProperty(CandlestickSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ColumnSeries.classNames.concat([CandlestickSeries.className])
    });

    class OHLC extends Candlestick {
        _draw() {
            const display = this._display;
            display.moveTo(this.get("lowX1", 0), this.get("lowY1", 0));
            display.lineTo(this.get("highX1", 0), this.get("highY1", 0));
            let w = this.width();
            let h = this.height();
            if (this.get("orientation") == "vertical") {
                let lY = h;
                let hY = 0;
                display.moveTo(0, lY);
                display.lineTo(w / 2, lY);
                display.moveTo(w / 2, hY);
                display.lineTo(w, hY);
            }
            else {
                let lX = 0;
                let hX = w;
                display.moveTo(lX, 0);
                display.lineTo(lX, h / 2);
                display.moveTo(hX, h / 2);
                display.lineTo(hX, h);
            }
        }
    }
    Object.defineProperty(OHLC, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "OHLC"
    });
    Object.defineProperty(OHLC, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Candlestick.classNames.concat([OHLC.className])
    });

    /**
     * OHLC series.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/candlestick-series/} for more info
     * @important
     */
    class OHLCSeries extends CandlestickSeries {
        constructor() {
            super(...arguments);
            /**
             * A list of OHLC bars in the series.
             *
             * `columns.template` can be used to configure OHLC bars.
             *
             * @default new ListTemplate<OHLC>
             */
            Object.defineProperty(this, "columns", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({
                    themeTags: ["autocolor"]
                }), () => OHLC._new(this._root, {
                    themeTags: mergeTags(this.columns.template.get("themeTags", []), ["ohlc", "series", "column"])
                }, [this.columns.template]))
            });
        }
        /**
         * @ignore
         */
        makeColumn(dataItem, listTemplate) {
            const column = this.mainContainer.children.push(listTemplate.make());
            column._setDataItem(dataItem);
            listTemplate.push(column);
            return column;
        }
        _processAxisRange(axisRange) {
            super._processAxisRange(axisRange);
            axisRange.columns = new ListTemplate(Template.new({}), () => OHLC._new(this._root, {
                themeTags: mergeTags(axisRange.columns.template.get("themeTags", []), ["ohlc", "series", "column"]),
            }, [this.columns.template, axisRange.columns.template]));
        }
    }
    Object.defineProperty(OHLCSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "OHLCSeries"
    });
    Object.defineProperty(OHLCSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: CandlestickSeries.classNames.concat([OHLCSeries.className])
    });

    /**
     * Used to plot line and/or area series.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/line-series/} for more info
     * @important
     */
    class LineSeries extends XYSeries {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_endIndex", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_strokeGenerator", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: line$1()
            });
            Object.defineProperty(this, "_fillGenerator", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: area()
            });
            Object.defineProperty(this, "_legendStroke", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_legendFill", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * A [[TemplateList]] of all line segments in series.
             *
             * `strokes.template` can be used to set default settings for all line
             * segments, or to change on existing ones.
             *
             * @default new ListTemplate<Graphics>
             */
            Object.defineProperty(this, "strokes", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Graphics._new(this._root, {
                    themeTags: mergeTags(this.strokes.template.get("themeTags", []), ["line", "series", "stroke"])
                }, [this.strokes.template]))
            });
            /**
             * A [[TemplateList]] of all segment fills in series.
             *
             * `fills.template` can be used to set default settings for all segment
             * fills, or to change on existing ones.
             *
             * @default new ListTemplate<Graphics>
             */
            Object.defineProperty(this, "fills", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Graphics._new(this._root, {
                    themeTags: mergeTags(this.strokes.template.get("themeTags", []), ["line", "series", "fill"])
                }, [this.fills.template]))
            });
            // custom set from data
            Object.defineProperty(this, "_fillTemplate", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_strokeTemplate", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_previousPoint", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: [0, 0, 0, 0]
            });
            Object.defineProperty(this, "_dindex", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_sindex", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
        }
        _afterNew() {
            this._fillGenerator.y0(function (p) {
                return p[3];
            });
            this._fillGenerator.x0(function (p) {
                return p[2];
            });
            this._fillGenerator.y1(function (p) {
                return p[1];
            });
            this._fillGenerator.x1(function (p) {
                return p[0];
            });
            super._afterNew();
        }
        /**
         * @ignore
         */
        makeStroke(strokes) {
            const stroke = this.mainContainer.children.push(strokes.make());
            strokes.push(stroke);
            return stroke;
        }
        /**
         * @ignore
         */
        makeFill(fills) {
            const fill = this.mainContainer.children.push(fills.make());
            fills.push(fill);
            return fill;
        }
        _updateChildren() {
            this._strokeTemplate = undefined;
            this._fillTemplate = undefined;
            let xAxis = this.get("xAxis");
            let yAxis = this.get("yAxis");
            if (this.isDirty("stroke")) {
                const stroke = this.get("stroke");
                this.strokes.template.set("stroke", stroke);
                const legendStroke = this._legendStroke;
                if (legendStroke) {
                    legendStroke.states.lookup("default").set("stroke", stroke);
                }
            }
            if (this.isDirty("fill")) {
                const fill = this.get("fill");
                this.fills.template.set("fill", fill);
                const legendFill = this._legendFill;
                if (legendFill) {
                    legendFill.states.lookup("default").set("fill", fill);
                }
            }
            if (this.isDirty("fillPattern")) {
                const fillPattern = this.get("fillPattern");
                this.fills.template.set("fillPattern", fillPattern);
                const legendFill = this._legendFill;
                if (legendFill) {
                    legendFill.states.lookup("default").set("fillPattern", fillPattern);
                }
            }
            if (this.isDirty("curveFactory")) {
                const curveFactory = this.get("curveFactory");
                if (curveFactory) {
                    this._strokeGenerator.curve(curveFactory);
                    this._fillGenerator.curve(curveFactory);
                }
            }
            if (xAxis.inited && yAxis.inited) {
                if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty || this.isDirty("connect") || this.isDirty("curveFactory")) {
                    this.fills.each((fill) => {
                        fill.setPrivate("visible", false);
                    });
                    this.strokes.each((fill) => {
                        fill.setPrivate("visible", false);
                    });
                    this.axisRanges.each((axisRange) => {
                        let fills = axisRange.fills;
                        if (fills) {
                            fills.each((fill) => {
                                fill.setPrivate("visible", false);
                            });
                        }
                        let strokes = axisRange.strokes;
                        if (strokes) {
                            strokes.each((stroke) => {
                                stroke.setPrivate("visible", false);
                            });
                        }
                    });
                    let startIndex = this.startIndex();
                    let strokeTemplateField = this.strokes.template.get("templateField");
                    let fillTemplateField = this.fills.template.get("templateField");
                    let strokeTemplateFound = true;
                    let fillTemplateFound = true;
                    if (strokeTemplateField) {
                        strokeTemplateFound = false;
                    }
                    if (fillTemplateField) {
                        fillTemplateFound = false;
                    }
                    for (let i = startIndex - 1; i >= 0; i--) {
                        let dataItem = this.dataItems[i];
                        let hasValues = true;
                        let dataContext = dataItem.dataContext;
                        if (strokeTemplateField) {
                            if (dataContext[strokeTemplateField]) {
                                strokeTemplateFound = true;
                            }
                        }
                        if (fillTemplateField) {
                            if (dataContext[fillTemplateField]) {
                                fillTemplateFound = true;
                            }
                        }
                        each$1(this._valueFields, (field) => {
                            if (!isNumber(dataItem.get(field))) {
                                hasValues = false;
                            }
                        });
                        if (hasValues && strokeTemplateFound && fillTemplateFound) {
                            startIndex = i;
                            break;
                        }
                    }
                    let len = this.dataItems.length;
                    let endIndex = this.endIndex();
                    if (endIndex < len) {
                        endIndex++;
                        for (let i = endIndex; i < len; i++) {
                            let dataItem = this.dataItems[i];
                            let hasValues = true;
                            each$1(this._valueFields, (field) => {
                                if (!isNumber(dataItem.get(field))) {
                                    hasValues = false;
                                }
                            });
                            if (hasValues) {
                                endIndex = i + 1;
                                break;
                            }
                        }
                    }
                    if (startIndex > 0) {
                        startIndex--;
                    }
                    this._endIndex = endIndex;
                    this._clearGraphics();
                    this._sindex = 0;
                    this._dindex = startIndex;
                    if (this.dataItems.length == 1) {
                        this._startSegment(0);
                    }
                    else {
                        // this is done to avoid recursion with a lot of segments 
                        while (this._dindex < endIndex - 1) {
                            this._startSegment(this._dindex);
                            this._sindex++;
                        }
                    }
                }
            }
            else {
                this._skipped = true;
            }
            super._updateChildren();
        }
        _clearGraphics() {
            this.strokes.clear();
            this.fills.clear();
            this.axisRanges.each((axisRange) => {
                axisRange.fills.clear();
                axisRange.strokes.clear();
            });
        }
        _startSegment(dataItemIndex) {
            let endIndex = this._endIndex;
            let currentEndIndex = endIndex;
            const autoGapCount = this.get("autoGapCount");
            const connect = this.get("connect");
            const fill = this.makeFill(this.fills);
            const fillTemplate = this._fillTemplate;
            const originalTemplate = this.fills.template;
            if (fillTemplate && fillTemplate != originalTemplate) {
                fill.template = fillTemplate;
            }
            fill.setPrivate("visible", true);
            const stroke = this.makeStroke(this.strokes);
            const strokeTemplate = this._strokeTemplate;
            if (strokeTemplate && strokeTemplate != this.strokes.template) {
                stroke.template = strokeTemplate;
            }
            stroke.setPrivate("visible", true);
            let xAxis = this.get("xAxis");
            let yAxis = this.get("yAxis");
            let baseAxis = this.get("baseAxis");
            let vcx = this.get("vcx", 1);
            let vcy = this.get("vcy", 1);
            let xField = this._xField;
            let yField = this._yField;
            let xOpenField = this._xOpenField;
            let yOpenField = this._yOpenField;
            const xOpenFieldValue = this.get("openValueXField");
            const yOpenFieldValue = this.get("openValueYField");
            if (!xOpenFieldValue) {
                xOpenField = this._xField;
            }
            if (!yOpenFieldValue) {
                yOpenField = this._yField;
            }
            const stacked = this.get("stacked");
            const basePosX = xAxis.basePosition();
            const basePosY = yAxis.basePosition();
            let baseField;
            if (baseAxis === yAxis) {
                baseField = this._yField;
            }
            else {
                baseField = this._xField;
            }
            const segments = [];
            let points = [];
            segments.push(points);
            const strokeTemplateField = this.strokes.template.get("templateField");
            const fillTemplateField = this.fills.template.get("templateField");
            let locationX = this.get("locationX", 0.5);
            let locationY = this.get("locationY", 0.5);
            let openLocationX = this.get("openLocationX", locationX);
            let openLocationY = this.get("openLocationY", locationY);
            const minDistance = this.get("minDistance", 0);
            let i;
            let fillVisible = this.fills.template.get("visible");
            if (this.axisRanges.length > 0) {
                fillVisible = true;
            }
            let getOpen = false;
            if (stacked || xOpenFieldValue || yOpenFieldValue) {
                getOpen = true;
            }
            const o = {
                points, segments, stacked, getOpen, basePosX, basePosY, fillVisible, xField, yField, xOpenField, yOpenField, vcx, vcy, baseAxis, xAxis, yAxis, locationX, locationY, openLocationX, openLocationY, minDistance
            };
            let rangeStrokeTemplate = this._strokeTemplate;
            let rangeFillTemplate = this._fillTemplate;
            for (i = dataItemIndex; i < currentEndIndex; i++) {
                this._dindex = i;
                const dataItem = this._dataItems[i];
                let valueX = dataItem.get(xField);
                let valueY = dataItem.get(yField);
                if (valueX == null || valueY == null) {
                    if (!connect) {
                        points = [];
                        segments.push(points);
                        o.points = points;
                    }
                }
                else {
                    this._getPoints(dataItem, o);
                }
                if (strokeTemplateField) {
                    let strokeTemplate = dataItem.dataContext[strokeTemplateField];
                    if (strokeTemplate) {
                        if (!(strokeTemplate instanceof Template)) {
                            strokeTemplate = Template.new(strokeTemplate);
                        }
                        this._strokeTemplate = strokeTemplate;
                        if (i > dataItemIndex) {
                            currentEndIndex = i;
                            break;
                        }
                        else {
                            rangeStrokeTemplate = strokeTemplate;
                            stroke.template = strokeTemplate;
                        }
                    }
                }
                if (fillTemplateField) {
                    let fillTemplate = dataItem.dataContext[fillTemplateField];
                    if (fillTemplate) {
                        if (!(fillTemplate instanceof Template)) {
                            fillTemplate = Template.new(fillTemplate);
                        }
                        this._fillTemplate = fillTemplate;
                        if (i > dataItemIndex) {
                            currentEndIndex = i;
                            break;
                        }
                        else {
                            rangeFillTemplate = fillTemplate;
                            fill.template = fillTemplate;
                        }
                    }
                }
                if (!connect) {
                    let nextItem = this.dataItems[i + 1];
                    if (nextItem) {
                        if (baseAxis.shouldGap(dataItem, nextItem, autoGapCount, baseField)) {
                            points = [];
                            segments.push(points);
                            o.points = points;
                        }
                    }
                }
            }
            fill.setRaw("userData", [dataItemIndex, i]);
            stroke.setRaw("userData", [dataItemIndex, i]);
            if (i === endIndex) {
                this._endLine(points, segments[0][0]);
            }
            if (stroke) {
                this._drawStroke(stroke, segments);
            }
            if (fill) {
                this._drawFill(fill, segments);
            }
            this.axisRanges.each((axisRange) => {
                const container = axisRange.container;
                const fills = axisRange.fills;
                const fill = this.makeFill(fills);
                if (container) {
                    container.children.push(fill);
                }
                fill.setPrivate("visible", true);
                this._drawFill(fill, segments);
                const strokes = axisRange.strokes;
                const stroke = this.makeStroke(strokes);
                if (container) {
                    container.children.push(stroke);
                }
                if (rangeStrokeTemplate && rangeStrokeTemplate != this.strokes.template) {
                    stroke.template = rangeStrokeTemplate;
                }
                if (rangeFillTemplate && rangeFillTemplate != this.fills.template) {
                    fill.template = rangeFillTemplate;
                }
                stroke.setPrivate("visible", true);
                this._drawStroke(stroke, segments);
                fill.setRaw("userData", [dataItemIndex, i]);
                stroke.setRaw("userData", [dataItemIndex, i]);
            });
        }
        _getPoints(dataItem, o) {
            let points = o.points;
            let itemLocationX = dataItem.get("locationX", o.locationX);
            let itemLocationY = dataItem.get("locationY", o.locationY);
            let xPos = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX, o.vcx);
            let yPos = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY, o.vcy);
            if (this._shouldInclude(xPos)) {
                const iPoint = this.getPoint(xPos, yPos);
                const point = [iPoint.x, iPoint.y];
                iPoint.x += this._x;
                iPoint.y += this._y;
                dataItem.set("point", iPoint);
                if (o.fillVisible) {
                    let xPos0 = xPos;
                    let yPos0 = yPos;
                    if (o.baseAxis === o.xAxis) {
                        yPos0 = o.basePosY;
                    }
                    else if (o.baseAxis === o.yAxis) {
                        xPos0 = o.basePosX;
                    }
                    if (o.getOpen) {
                        let valueX = dataItem.get(o.xOpenField);
                        let valueY = dataItem.get(o.yOpenField);
                        if (valueX != null && valueY != null) {
                            let itemLocationX = dataItem.get("openLocationX", o.openLocationX);
                            let itemLocationY = dataItem.get("openLocationY", o.openLocationY);
                            if (o.stacked) {
                                let stackToItemX = dataItem.get("stackToItemX");
                                let stackToItemY = dataItem.get("stackToItemY");
                                if (stackToItemX) {
                                    xPos0 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX, stackToItemX.component.get("vcx"));
                                    if (isNaN$1(xPos0)) {
                                        xPos0 = o.basePosX;
                                    }
                                }
                                else {
                                    if (o.yAxis === o.baseAxis) {
                                        xPos0 = o.basePosX;
                                    }
                                    else {
                                        xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);
                                    }
                                }
                                if (stackToItemY) {
                                    yPos0 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY, stackToItemY.component.get("vcy"));
                                    if (isNaN$1(yPos0)) {
                                        yPos0 = o.basePosY;
                                    }
                                }
                                else {
                                    if (o.xAxis === o.baseAxis) {
                                        yPos0 = o.basePosY;
                                    }
                                    else {
                                        yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);
                                    }
                                }
                            }
                            else {
                                xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);
                                yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);
                            }
                        }
                    }
                    let closeIPoint = this.getPoint(xPos0, yPos0);
                    point[2] = closeIPoint.x;
                    point[3] = closeIPoint.y;
                }
                if (o.minDistance > 0) {
                    const p0 = point[0];
                    const p1 = point[1];
                    const p2 = point[2];
                    const p3 = point[3];
                    const prev = this._previousPoint;
                    const pp0 = prev[0];
                    const pp1 = prev[1];
                    const pp2 = prev[2];
                    const pp3 = prev[3];
                    if (Math.hypot(p0 - pp0, p1 - pp1) > o.minDistance || (p2 && p3 && Math.hypot(p2 - pp2, p3 - pp3) > o.minDistance)) {
                        points.push(point);
                        this._previousPoint = point;
                    }
                }
                else {
                    points.push(point);
                }
            }
        }
        _endLine(_points, _firstPoint) {
        }
        _drawStroke(graphics, segments) {
            if (graphics.get("visible") && !graphics.get("forceHidden")) {
                graphics.set("draw", (display) => {
                    each$1(segments, (segment) => {
                        this._strokeGenerator.context(display);
                        this._strokeGenerator(segment);
                    });
                });
            }
        }
        _drawFill(graphics, segments) {
            if (graphics.get("visible") && !graphics.get("forceHidden")) {
                graphics.set("draw", (display) => {
                    each$1(segments, (segment) => {
                        this._fillGenerator.context(display);
                        this._fillGenerator(segment);
                    });
                });
            }
        }
        _processAxisRange(axisRange) {
            super._processAxisRange(axisRange);
            axisRange.fills = new ListTemplate(Template.new({}), () => Graphics._new(this._root, {
                themeTags: mergeTags(axisRange.fills.template.get("themeTags", []), ["line", "series", "fill"]),
            }, [this.fills.template, axisRange.fills.template]));
            axisRange.strokes = new ListTemplate(Template.new({}), () => Graphics._new(this._root, {
                themeTags: mergeTags(axisRange.strokes.template.get("themeTags", []), ["line", "series", "stroke"]),
            }, [this.strokes.template, axisRange.strokes.template]));
        }
        /**
         * @ignore
         */
        createLegendMarker(_dataItem) {
            const legendDataItem = this.get("legendDataItem");
            if (legendDataItem) {
                const marker = legendDataItem.get("marker");
                const markerRectangle = legendDataItem.get("markerRectangle");
                if (markerRectangle) {
                    markerRectangle.setPrivate("visible", false);
                }
                marker.set("background", Rectangle.new(marker._root, { fillOpacity: 0, fill: color(0x000000) }));
                const legendStroke = marker.children.push(Graphics._new(marker._root, {
                    themeTags: ["line", "series", "legend", "marker", "stroke"], interactive: false
                }, [this.strokes.template]));
                this._legendStroke = legendStroke;
                const legendFill = marker.children.push(Graphics._new(marker._root, {
                    themeTags: ["line", "series", "legend", "marker", "fill"]
                }, [this.fills.template]));
                this._legendFill = legendFill;
                const disabledColor = this._root.interfaceColors.get("disabled");
                legendStroke.states.create("disabled", { fill: disabledColor, stroke: disabledColor });
                legendFill.states.create("disabled", { fill: disabledColor, stroke: disabledColor });
                if (this.bullets.length > 0) {
                    const bulletFunction = this.bullets.getIndex(0);
                    if (bulletFunction) {
                        const bullet = bulletFunction(marker._root, this, new DataItem(this, { legend: true }, {}));
                        if (bullet) {
                            const sprite = bullet.get("sprite");
                            if (sprite instanceof Graphics) {
                                sprite.states.create("disabled", { fill: disabledColor, stroke: disabledColor });
                            }
                            if (sprite) {
                                sprite.set("tooltipText", undefined);
                                sprite.set("tooltipHTML", undefined);
                                marker.children.push(sprite);
                                sprite.setAll({ x: marker.width() / 2, y: marker.height() / 2 });
                                marker.events.on("boundschanged", () => {
                                    sprite.setAll({ x: marker.width() / 2, y: marker.height() / 2 });
                                });
                            }
                        }
                    }
                }
            }
        }
    }
    Object.defineProperty(LineSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "LineSeries"
    });
    Object.defineProperty(LineSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: XYSeries.classNames.concat([LineSeries.className])
    });

    /**
     * @ignore
     */
    class MonotoneYTension {
        constructor(context, tension) {
            Object.defineProperty(this, "_line", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_point", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_context", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_x0", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_x1", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_y0", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_y1", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_t0", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_tension", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            this._context = context;
            this._tension = tension;
        }
        areaStart() {
            this._line = 0;
        }
        areaEnd() {
            this._line = NaN;
        }
        lineStart() {
            this._x0 = this._x1 =
                this._y0 = this._y1 =
                    this._t0 = NaN;
            this._point = 0;
        }
        lineEnd() {
            switch (this._point) {
                case 2:
                    this._context.lineTo(this._x1, this._y1);
                    break;
                case 3:
                    point$1(this, this._t0, slope2$1(this, this._t0));
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        }
        point(x, y) {
            [x, y] = [y, x];
            let t1 = NaN;
            x = +x, y = +y;
            if (x === this._x1 && y === this._y1)
                return; // Ignore coincident points.
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(y, x) : this._context.moveTo(y, x);
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3;
                    point$1(this, slope2$1(this, t1 = slope3$1(this, x, y)), t1);
                    break;
                default:
                    point$1(this, this._t0, t1 = slope3$1(this, x, y));
                    break;
            }
            this._x0 = this._x1, this._x1 = x;
            this._y0 = this._y1, this._y1 = y;
            this._t0 = t1;
        }
    }
    /**
     * @ignore
     */
    function curveMonotoneYTension(tension) {
        function monotoneYTension(context) {
            return new MonotoneYTension(context, tension);
        }
        monotoneYTension.tension = function (tension) {
            return curveMonotoneYTension(+tension);
        };
        return monotoneYTension;
    }
    /**
     * @ignore
     */
    function sign$1(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * @ignore
     */
    function slope3$1(that, x2, y2) {
        let h0 = (that._x1 - that._x0);
        let h1 = (x2 - that._x1);
        let s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0);
        let s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0);
        let p = (s0 * h1 + s1 * h0) / (h0 + h1);
        return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }
    /**
     * @ignore
     */
    function slope2$1(that, t) {
        let h = that._x1 - that._x0;
        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }
    /**
     * @ignore
     */
    function point$1(that, t0, t1) {
        let x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 1.5 * (1 - that._tension);
        that._context.bezierCurveTo(y0 + dx * t0, x0 + dx, y1 - dx * t1, x1 - dx, y1, x1);
    }

    /**
     * Smoothed line series suitable for vertical plots.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/smoothed-series/} for more info
     */
    class SmoothedYLineSeries extends LineSeries {
        _afterNew() {
            this._setDefault("curveFactory", curveMonotoneYTension(this.get("tension", 0.5)));
            super._afterNew();
        }
        _updateChildren() {
            if (this.isDirty("tension")) {
                this.set("curveFactory", curveMonotoneYTension(this.get("tension", 0.5)));
                this._valuesDirty = true;
            }
            super._updateChildren();
        }
    }
    Object.defineProperty(SmoothedYLineSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SmoothedYLineSeries"
    });
    Object.defineProperty(SmoothedYLineSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: LineSeries.classNames.concat([SmoothedYLineSeries.className])
    });

    /**
     * @ignore
     */
    class MonotoneXTension {
        constructor(context, tension) {
            Object.defineProperty(this, "_line", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_point", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_context", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "_x0", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_x1", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_y0", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_y1", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_t0", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_tension", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            this._context = context;
            this._tension = tension;
        }
        areaStart() {
            this._line = 0;
        }
        areaEnd() {
            this._line = NaN;
        }
        lineStart() {
            this._x0 = this._x1 =
                this._y0 = this._y1 =
                    this._t0 = NaN;
            this._point = 0;
        }
        lineEnd() {
            switch (this._point) {
                case 2:
                    this._context.lineTo(this._x1, this._y1);
                    break;
                case 3:
                    point(this, this._t0, slope2(this, this._t0));
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        }
        point(x, y) {
            let t1 = NaN;
            x = +x, y = +y;
            if (x === this._x1 && y === this._y1)
                return; // Ignore coincident points.
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3;
                    point(this, slope2(this, t1 = slope3(this, x, y)), t1);
                    break;
                default:
                    point(this, this._t0, t1 = slope3(this, x, y));
                    break;
            }
            this._x0 = this._x1, this._x1 = x;
            this._y0 = this._y1, this._y1 = y;
            this._t0 = t1;
        }
    }
    /**
     * @ignore
     */
    function curveMonotoneXTension(tension) {
        function monotoneXTension(context) {
            return new MonotoneXTension(context, tension);
        }
        return monotoneXTension;
    }
    /**
     * @ignore
     */
    function sign(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * @ignore
     */
    function slope3(that, x2, y2) {
        let h0 = (that._x1 - that._x0);
        let h1 = (x2 - that._x1);
        let s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0);
        let s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0);
        let p = (s0 * h1 + s1 * h0) / (h0 + h1);
        return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }
    /**
     * @ignore
     */
    function slope2(that, t) {
        let h = that._x1 - that._x0;
        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }
    /**
     * @ignore
     */
    function point(that, t0, t1) {
        let x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 1.5 * (1 - that._tension);
        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    /**
     * Smoothed line series suitable for horizontal plots.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/smoothed-series/} for more info
     */
    class SmoothedXLineSeries extends LineSeries {
        _afterNew() {
            this._setDefault("curveFactory", curveMonotoneXTension(this.get("tension", 0.5)));
            super._afterNew();
        }
        _updateChildren() {
            if (this.isDirty("tension")) {
                this.set("curveFactory", curveMonotoneXTension(this.get("tension", 0.5)));
                this._valuesDirty = true;
            }
            super._updateChildren();
        }
    }
    Object.defineProperty(SmoothedXLineSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SmoothedXLineSeries"
    });
    Object.defineProperty(SmoothedXLineSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: LineSeries.classNames.concat([SmoothedXLineSeries.className])
    });

    /**
     * Smoothed line series suitable for XY (scatter) charts
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/smoothed-series/} for more info
     */
    class SmoothedXYLineSeries extends LineSeries {
        _afterNew() {
            this._setDefault("curveFactory", curveCardinal.tension(this.get("tension", 0.5)));
            super._afterNew();
        }
        _updateChildren() {
            if (this.isDirty("tension")) {
                this.set("curveFactory", curveCardinal.tension(this.get("tension", 0.5)));
                this._valuesDirty = true;
            }
            super._updateChildren();
        }
    }
    Object.defineProperty(SmoothedXYLineSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SmoothedXYLineSeries"
    });
    Object.defineProperty(SmoothedXYLineSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: LineSeries.classNames.concat([SmoothedXYLineSeries.className])
    });

    class StepLineSeries extends LineSeries {
        _afterNew() {
            this._setDefault("curveFactory", stepAfter);
            super._afterNew();
        }
        _getPoints(dataItem, o) {
            let points = o.points;
            let width = this.get("stepWidth", p100).value / 2;
            let itemLocationX0 = dataItem.get("locationX", o.locationX);
            let itemLocationY0 = dataItem.get("locationY", o.locationY);
            let itemLocationX1 = itemLocationX0;
            let itemLocationY1 = itemLocationY0;
            if (o.baseAxis === o.xAxis) {
                itemLocationX0 -= width;
                itemLocationX1 += width;
            }
            else if (o.baseAxis === o.yAxis) {
                itemLocationY0 -= width;
                itemLocationY1 += width;
            }
            let xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX0, o.vcx);
            let yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY0, o.vcy);
            let xPos1 = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX1, o.vcx);
            let yPos1 = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY1, o.vcy);
            if (this._shouldInclude(xPos0)) {
                const iPoint0 = this.getPoint(xPos0, yPos0);
                const point0 = [iPoint0.x, iPoint0.y];
                const iPoint1 = this.getPoint(xPos1, yPos1);
                const point1 = [iPoint1.x, iPoint1.y];
                if (o.fillVisible) {
                    let xOpenPos0 = xPos0;
                    let yOpenPos0 = yPos0;
                    let xOpenPos1 = xPos1;
                    let yOpenPos1 = yPos1;
                    if (o.baseAxis === o.xAxis) {
                        yOpenPos0 = o.basePosY;
                        yOpenPos1 = o.basePosY;
                    }
                    else if (o.baseAxis === o.yAxis) {
                        xOpenPos0 = o.basePosX;
                        xOpenPos1 = o.basePosX;
                    }
                    if (o.getOpen) {
                        let valueX = dataItem.get(o.xOpenField);
                        let valueY = dataItem.get(o.yOpenField);
                        if (valueX != null && valueY != null) {
                            itemLocationX0 = dataItem.get("openLocationX", o.openLocationX);
                            itemLocationY0 = dataItem.get("openLocationY", o.openLocationY);
                            itemLocationX1 = itemLocationX0;
                            itemLocationY1 = itemLocationY0;
                            if (o.baseAxis === o.xAxis) {
                                itemLocationX0 -= width;
                                itemLocationX1 += width;
                            }
                            else if (o.baseAxis === o.yAxis) {
                                itemLocationY0 -= width;
                                itemLocationY1 += width;
                            }
                            if (o.stacked) {
                                let stackToItemX = dataItem.get("stackToItemX");
                                let stackToItemY = dataItem.get("stackToItemY");
                                if (stackToItemX) {
                                    xOpenPos0 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX0, stackToItemX.component.get("vcx"));
                                    xOpenPos1 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX1, stackToItemX.component.get("vcx"));
                                }
                                else {
                                    if (o.yAxis === o.baseAxis) {
                                        xOpenPos0 = o.basePosX;
                                        xOpenPos1 = o.basePosX;
                                    }
                                    else if (o.baseAxis === o.yAxis) {
                                        xOpenPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX0, o.vcx);
                                        xOpenPos1 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX1, o.vcx);
                                    }
                                }
                                if (stackToItemY) {
                                    yOpenPos0 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY0, stackToItemY.component.get("vcy"));
                                    yOpenPos1 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY1, stackToItemY.component.get("vcy"));
                                }
                                else {
                                    if (o.xAxis === o.baseAxis) {
                                        yOpenPos0 = o.basePosY;
                                        yOpenPos1 = o.basePosY;
                                    }
                                    else if (o.baseAxis === o.yAxis) {
                                        yOpenPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY0, o.vcy);
                                        yOpenPos1 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY1, o.vcy);
                                    }
                                }
                            }
                            else {
                                xOpenPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX0, o.vcx);
                                yOpenPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY0, o.vcy);
                                xOpenPos1 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX1, o.vcx);
                                yOpenPos1 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY1, o.vcy);
                            }
                        }
                    }
                    let closeIPoint0 = this.getPoint(xOpenPos0, yOpenPos0);
                    let closeIPoint1 = this.getPoint(xOpenPos1, yOpenPos1);
                    point0[2] = closeIPoint0.x;
                    point0[3] = closeIPoint0.y;
                    point1[2] = closeIPoint1.x;
                    point1[3] = closeIPoint1.y;
                }
                points.push(point0);
                points.push(point1);
                dataItem.set("point", { x: point0[0] + (point1[0] - point0[0]) / 2, y: point0[1] + (point1[1] - point0[1]) / 2 });
            }
            if (this.get("noRisers")) {
                o.points = [];
                o.segments.push(points);
            }
        }
    }
    Object.defineProperty(StepLineSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "StepLineSeries"
    });
    Object.defineProperty(StepLineSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: LineSeries.classNames.concat([StepLineSeries.className])
    });

    var am5xy = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Axis: Axis,
        AxisBullet: AxisBullet,
        AxisLabel: AxisLabel,
        AxisLabelRadial: AxisLabelRadial,
        AxisRenderer: AxisRenderer,
        AxisRendererX: AxisRendererX,
        AxisRendererY: AxisRendererY,
        AxisTick: AxisTick,
        BaseColumnSeries: BaseColumnSeries,
        Candlestick: Candlestick,
        CandlestickSeries: CandlestickSeries,
        CategoryAxis: CategoryAxis,
        CategoryDateAxis: CategoryDateAxis,
        ColumnSeries: ColumnSeries,
        DateAxis: DateAxis,
        DefaultTheme: XYChartDefaultTheme,
        DurationAxis: DurationAxis,
        GaplessDateAxis: GaplessDateAxis,
        Grid: Grid,
        LineSeries: LineSeries,
        OHLC: OHLC,
        OHLCSeries: OHLCSeries,
        SmoothedXLineSeries: SmoothedXLineSeries,
        SmoothedXYLineSeries: SmoothedXYLineSeries,
        SmoothedYLineSeries: SmoothedYLineSeries,
        StepLineSeries: StepLineSeries,
        ValueAxis: ValueAxis,
        XYChart: XYChart,
        XYChartScrollbar: XYChartScrollbar,
        XYCursor: XYCursor,
        XYSeries: XYSeries
    });

    /**
     * Renderer for circular axes.
     */
    class AxisRendererCircular extends AxisRenderer {
        constructor() {
            super(...arguments);
            /**
             * A list of labels in the axis.
             *
             * `labels.template` can be used to configure labels.
             *
             * @default new ListTemplate<AxisLabelRadial>
             */
            Object.defineProperty(this, "labels", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => AxisLabelRadial._new(this._root, {
                    themeTags: mergeTags(this.labels.template.get("themeTags", []), this.get("themeTags", []))
                }, [this.labels.template]))
            });
            /**
             * A list of fills in the axis.
             *
             * `axisFills.template` can be used to configure axis fills.
             *
             * @default new ListTemplate<Slice>
             */
            Object.defineProperty(this, "axisFills", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Slice._new(this._root, {
                    themeTags: mergeTags(this.axisFills.template.get("themeTags", ["fill"]), this.get("themeTags", []))
                }, [this.axisFills.template]))
            });
            Object.defineProperty(this, "_fillGenerator", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: arc()
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["renderer", "circular"]);
            super._afterNew();
            this.setPrivateRaw("letter", "X");
            this.setRaw("position", "absolute");
        }
        _changed() {
            super._changed();
            if (this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("endAngle")) {
                this.updateLayout();
            }
        }
        /**
         * @ignore
         */
        processAxis() {
            super.processAxis();
            const axis = this.axis;
            axis.labelsContainer.set("isMeasured", false);
        }
        /**
         * @ignore
         */
        updateLayout() {
            const chart = this.chart;
            if (chart) {
                const radius = chart.getPrivate("radius", 0);
                let r = relativeToValue(this.get("radius", p100), radius);
                if (r < 0) {
                    r = radius + r;
                }
                this.setPrivate("radius", r);
                let ir = relativeToValue(this.get("innerRadius", chart.getPrivate("innerRadius", 0)), radius) * chart.getPrivate("irModifyer", 1);
                if (ir < 0) {
                    ir = r + ir;
                }
                this.setPrivate("innerRadius", ir);
                let startAngle = this.get("startAngle", chart.get("startAngle", -90));
                let endAngle = this.get("endAngle", chart.get("endAngle", 270));
                this.setPrivate("startAngle", startAngle);
                this.setPrivate("endAngle", endAngle);
                this.set("draw", (display) => {
                    const p0 = this.positionToPoint(0);
                    display.moveTo(p0.x, p0.y);
                    if (startAngle > endAngle) {
                        [startAngle, endAngle] = [endAngle, startAngle];
                    }
                    display.arc(0, 0, r, startAngle * RADIANS, endAngle * RADIANS);
                });
                this.axis.markDirtySize();
            }
        }
        /**
         * @ignore
         */
        updateGrid(grid, position, endPosition) {
            if (grid) {
                if (position == null) {
                    position = 0;
                }
                let location = grid.get("location", 0.5);
                if (endPosition != null && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                let radius = this.getPrivate("radius", 0);
                let innerRadius = this.getPrivate("innerRadius", 0);
                let angle = this.positionToAngle(position);
                this.toggleVisibility(grid, position, 0, 1);
                if (radius != null) {
                    grid.set("draw", (display) => {
                        display.moveTo(innerRadius * cos(angle), innerRadius * sin(angle));
                        display.lineTo(radius * cos(angle), radius * sin(angle));
                    });
                }
            }
        }
        /**
         * Converts relative position to angle.
         *
         * @param   position  Position
         * @return            Angle
         */
        positionToAngle(position) {
            const axis = this.axis;
            const startAngle = this.getPrivate("startAngle", 0);
            const endAngle = this.getPrivate("endAngle", 360);
            const start = axis.get("start", 0);
            const end = axis.get("end", 1);
            let arc = (endAngle - startAngle) / (end - start);
            let angle;
            if (this.get("inversed")) {
                angle = startAngle + (end - position) * arc;
            }
            else {
                angle = startAngle + (position - start) * arc;
            }
            return angle;
        }
        // do not delete
        _handleOpposite() { }
        /**
         * Converts relative position to an X/Y coordinate.
         *
         * @param   position  Position
         * @return            Point
         */
        positionToPoint(position) {
            const radius = this.getPrivate("radius", 0);
            const angle = this.positionToAngle(position);
            return { x: radius * cos(angle), y: radius * sin(angle) };
        }
        /**
         * @ignore
         */
        updateLabel(label, position, endPosition, count) {
            if (label) {
                if (position == null) {
                    position = 0;
                }
                let location = 0.5;
                if (count != null && count > 1) {
                    location = label.get("multiLocation", location);
                }
                else {
                    location = label.get("location", location);
                }
                if (endPosition != null && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                const radius = this.getPrivate("radius", 0);
                const innerRadius = this.getPrivate("innerRadius", 0);
                const angle = this.positionToAngle(position);
                label.setPrivate("radius", radius);
                label.setPrivate("innerRadius", innerRadius);
                label.set("labelAngle", angle);
                this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
            }
        }
        /**
         * @ignore
         */
        fillDrawMethod(fill, startAngle, endAngle) {
            fill.set("draw", (display) => {
                if (startAngle == null) {
                    startAngle = this.getPrivate("startAngle", 0);
                }
                if (endAngle == null) {
                    endAngle = this.getPrivate("endAngle", 0);
                }
                const y0 = this.getPrivate("innerRadius", 0);
                const y1 = this.getPrivate("radius", 0);
                this._fillGenerator.context(display);
                this._fillGenerator({ innerRadius: y0, outerRadius: y1, startAngle: (startAngle + 90) * RADIANS, endAngle: (endAngle + 90) * RADIANS });
            });
        }
        /**
         * @ignore
         */
        updateTick(tick, position, endPosition, count) {
            if (tick) {
                if (position == null) {
                    position = 0;
                }
                let location = 0.5;
                if (count != null && count > 1) {
                    location = tick.get("multiLocation", location);
                }
                else {
                    location = tick.get("location", location);
                }
                if (endPosition != null && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                let length = tick.get("length", 0);
                const inside = tick.get("inside");
                if (inside) {
                    length *= -1;
                }
                let radius = this.getPrivate("radius", 0);
                let angle = this.positionToAngle(position);
                this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
                if (radius != null) {
                    tick.set("draw", (display) => {
                        display.moveTo(radius * cos(angle), radius * sin(angle));
                        radius += length;
                        display.lineTo(radius * cos(angle), radius * sin(angle));
                    });
                }
            }
        }
        /**
         * @ignore
         */
        updateBullet(bullet, position, endPosition) {
            if (bullet) {
                const sprite = bullet.get("sprite");
                if (sprite) {
                    if (position == null) {
                        position = 0;
                    }
                    let location = bullet.get("location", 0.5);
                    if (endPosition != null && endPosition != position) {
                        position = position + (endPosition - position) * location;
                    }
                    let radius = this.getPrivate("radius", 0);
                    let angle = this.positionToAngle(position);
                    this.toggleVisibility(sprite, position, 0, 1);
                    sprite.setAll({ rotation: angle, x: radius * cos(angle), y: radius * sin(angle) });
                }
            }
        }
        /**
         * @ignore
         */
        updateFill(fill, position, endPosition) {
            if (fill) {
                if (position == null) {
                    position = 0;
                }
                if (endPosition == null) {
                    endPosition = 1;
                }
                let startAngle = this.fitAngle(this.positionToAngle(position));
                let endAngle = this.fitAngle(this.positionToAngle(endPosition));
                fill.setAll({ startAngle: startAngle, arc: endAngle - startAngle });
                fill._setSoft("innerRadius", this.getPrivate("innerRadius"));
                fill._setSoft("radius", this.getPrivate("radius"));
            }
        }
        /**
         * @ignore
         */
        fitAngle(angle) {
            const startAngle = this.getPrivate("startAngle", 0);
            const endAngle = this.getPrivate("endAngle", 0);
            const minAngle = Math.min(startAngle, endAngle);
            const maxAngle = Math.max(startAngle, endAngle);
            if (angle < minAngle) {
                angle = minAngle;
            }
            if (angle > maxAngle) {
                angle = maxAngle;
            }
            return angle;
        }
        /**
         * Returns axis length in pixels.
         *
         * @return Length
         */
        axisLength() {
            return Math.abs(this.getPrivate("radius", 0) * Math.PI * 2 * (this.getPrivate("endAngle", 360) - this.getPrivate("startAngle", 0)) / 360);
        }
        /**
         * @ignore
         */
        positionTooltip(tooltip, position) {
            let radius = this.getPrivate("radius", 0);
            const angle = this.positionToAngle(position);
            //return tooltip.set("pointTo", this.axis._display.toGlobal({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) }));
            this._positionTooltip(tooltip, { x: radius * cos(angle), y: radius * sin(angle) });
        }
        /**
         * @ignore
         */
        updateTooltipBounds(_tooltip) {
        }
    }
    Object.defineProperty(AxisRendererCircular, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisRendererCircular"
    });
    Object.defineProperty(AxisRendererCircular, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: AxisRenderer.classNames.concat([AxisRendererCircular.className])
    });

    /**
     * Renderer for radial axes.
     */
    class AxisRendererRadial extends AxisRenderer {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_fillGenerator", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: arc()
            });
            /**
             * A [[TemplateList]] with all the labels attached to the axis.
             *
             * `labels.template` can be used to configure appearance of the labels.
             *
             * @default new ListTemplate<AxisLabelRadial>
             */
            Object.defineProperty(this, "labels", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => AxisLabelRadial._new(this._root, {
                    themeTags: mergeTags(this.labels.template.get("themeTags", []), this.get("themeTags", []))
                }, [this.labels.template]))
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["renderer", "radial"]);
            super._afterNew();
            this.setPrivate("letter", "Y");
            this.setRaw("position", "absolute");
        }
        _changed() {
            super._changed();
            if (this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("endAngle")) {
                this.updateLayout();
            }
        }
        /**
         * @ignore
         */
        processAxis() {
            super.processAxis();
        }
        /**
         * @ignore
         */
        updateLayout() {
            const chart = this.chart;
            if (chart) {
                const radius = chart.getPrivate("radius", 0);
                let r = relativeToValue(this.get("radius", p100), radius);
                let ir = relativeToValue(this.get("innerRadius", chart.getPrivate("innerRadius", 0)), radius) * chart.getPrivate("irModifyer", 1);
                if (ir < 0) {
                    ir = r + ir;
                }
                this.setPrivate("radius", r);
                this.setPrivate("innerRadius", ir);
                let startAngle = this.get("startAngle", chart.get("startAngle", -90));
                let endAngle = this.get("endAngle", chart.get("endAngle", 270));
                this.setPrivate("startAngle", startAngle);
                this.setPrivate("endAngle", endAngle);
                const axisAngle = this.get("axisAngle", 0);
                this.set("draw", (display) => {
                    display.moveTo(ir * cos(axisAngle), ir * sin(axisAngle));
                    display.lineTo(r * cos(axisAngle), r * sin(axisAngle));
                });
                this.axis.markDirtySize();
            }
        }
        /**
         * @ignore
         */
        updateGrid(grid, position, endPosition) {
            if (grid) {
                if (!isNumber(position)) {
                    position = 0;
                }
                let location = grid.get("location", 0.5);
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                let radius = this.positionToCoordinate(position) + this.getPrivate("innerRadius", 0);
                this.toggleVisibility(grid, position, 0, 1);
                if (isNumber(radius)) {
                    grid.set("draw", (display) => {
                        let startAngle = this.getPrivate("startAngle", 0) * RADIANS;
                        let endAngle = this.getPrivate("endAngle", 0) * RADIANS;
                        display.arc(0, 0, Math.max(0, radius), Math.min(startAngle, endAngle), Math.max(startAngle, endAngle));
                    });
                }
            }
        }
        // do not delete
        _handleOpposite() { }
        /**
         * Converts relative position to X/Y point.
         *
         * @param   position  Position
         * @return            Point
         */
        positionToPoint(position) {
            const innerRadius = this.getPrivate("innerRadius", 0);
            const radius = this.positionToCoordinate(position) + innerRadius;
            const axisAngle = this.get("axisAngle", 0);
            return { x: radius * cos(axisAngle), y: radius * sin(axisAngle) };
        }
        /**
         * @ignore
         */
        updateLabel(label, position, endPosition, count) {
            if (label) {
                if (!isNumber(position)) {
                    position = 0;
                }
                let location = 0.5;
                if (isNumber(count) && count > 1) {
                    location = label.get("multiLocation", location);
                }
                else {
                    location = label.get("location", location);
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                const point = this.positionToPoint(position);
                let radius = Math.hypot(point.x, point.y);
                label.setPrivate("radius", radius);
                label.setPrivate("innerRadius", radius);
                label.set("labelAngle", this.get("axisAngle"));
                this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
            }
        }
        fillDrawMethod(fill, y0, y1) {
            fill.set("draw", (display) => {
                y0 = Math.max(0, y0);
                y1 = Math.max(0, y1);
                this._fillGenerator.context(display);
                let startAngle = (this.getPrivate("startAngle", 0) + 90) * RADIANS;
                let endAngle = (this.getPrivate("endAngle", 0) + 90) * RADIANS;
                if (endAngle < startAngle) {
                    [startAngle, endAngle] = [endAngle, startAngle];
                }
                this._fillGenerator({ innerRadius: y0, outerRadius: y1, startAngle: startAngle, endAngle: endAngle });
            });
        }
        /**
         * @ignore
         */
        updateTick(tick, position, endPosition, count) {
            if (tick) {
                if (!isNumber(position)) {
                    position = 0;
                }
                let location = 0.5;
                if (isNumber(count) && count > 1) {
                    location = tick.get("multiLocation", location);
                }
                else {
                    location = tick.get("location", location);
                }
                if (isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                const point = this.positionToPoint(position);
                tick.set("x", point.x);
                tick.set("y", point.y);
                let length = tick.get("length", 0);
                const inside = tick.get("inside");
                if (inside) {
                    length *= -1;
                }
                const axisAngle = this.get("axisAngle", 0) + 90;
                tick.set("draw", (display) => {
                    display.moveTo(0, 0);
                    display.lineTo(length * cos(axisAngle), length * sin(axisAngle));
                });
                this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
            }
        }
        /**
         * @ignore
         */
        updateBullet(bullet, position, endPosition) {
            if (bullet) {
                const sprite = bullet.get("sprite");
                if (sprite) {
                    if (!isNumber(position)) {
                        position = 0;
                    }
                    let location = bullet.get("location", 0.5);
                    if (isNumber(endPosition) && endPosition != position) {
                        position = position + (endPosition - position) * location;
                    }
                    const point = this.positionToPoint(position);
                    sprite.setAll({ x: point.x, y: point.y });
                    this.toggleVisibility(sprite, position, 0, 1);
                }
            }
        }
        /**
         * @ignore
         */
        updateFill(fill, position, endPosition) {
            if (fill) {
                if (!isNumber(position)) {
                    position = 0;
                }
                if (!isNumber(endPosition)) {
                    endPosition = 1;
                }
                const innerRadius = this.getPrivate("innerRadius", 0);
                let y0 = this.positionToCoordinate(position) + innerRadius;
                let y1 = this.positionToCoordinate(endPosition) + innerRadius;
                this.fillDrawMethod(fill, y0, y1);
            }
        }
        /**
         * Returns axis length in pixels.
         *
         * @return Length
         */
        axisLength() {
            return this.getPrivate("radius", 0) - this.getPrivate("innerRadius", 0);
        }
        /**
         * @ignore
         */
        updateTooltipBounds(_tooltip) {
        }
        /**
         * Converts relative position to pixels.
         *
         * @param   position  Position
         * @return            Pixels
         */
        positionToCoordinate(position) {
            if (this._inversed) {
                position = Math.min(this._end, position);
                return (this._end - position) * this._axisLength;
            }
            else {
                position = Math.max(this._start, position);
                return (position - this._start) * this._axisLength;
            }
        }
        /**
         * @ignore
         */
        positionTooltip(tooltip, position) {
            let radius = this.getPrivate("innerRadius", 0) + this.positionToCoordinate(position);
            const angle = this.get("axisAngle", 0);
            //return tooltip.set("pointTo", this.axis._display.toGlobal({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) }));
            this._positionTooltip(tooltip, { x: radius * cos(angle), y: radius * sin(angle) });
        }
    }
    Object.defineProperty(AxisRendererRadial, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AxisRendererRadial"
    });
    Object.defineProperty(AxisRendererRadial, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: AxisRenderer.classNames.concat([AxisRendererRadial.className])
    });

    /**
     * A clock hand for use with [[RadarChart]].
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/radar-chart/gauge-charts/#Clock_hands} for more info
     * @important
     */
    class ClockHand extends Container {
        constructor() {
            super(...arguments);
            /**
             * A "hand" element.
             *
             * @default Graphics.new()
             */
            Object.defineProperty(this, "hand", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Graphics.new(this._root, { themeTags: ["hand"] }))
            });
            /**
             * A "pin" element (hand's base).
             *
             * @default Graphics.new()
             */
            Object.defineProperty(this, "pin", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.children.push(Graphics.new(this._root, { themeTags: ["pin"] }))
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["clock"]);
            super._afterNew();
            // to be redrawn when size changes
            this.set("width", percent(1));
            this.adapters.add("x", () => {
                return 0;
            });
            this.adapters.add("y", () => {
                return 0;
            });
            this.pin.set("draw", (display, graphics) => {
                const parent = graphics.parent;
                if (parent) {
                    const dataItem = parent.dataItem;
                    if (dataItem) {
                        const axis = dataItem.component;
                        if (axis) {
                            const chart = axis.chart;
                            if (chart) {
                                const cr = chart.getPrivate("radius", 0);
                                let r = relativeToValue(parent.get("pinRadius", 0), cr);
                                if (r < 0) {
                                    r = cr + r;
                                }
                                display.moveTo(r, 0);
                                display.arc(0, 0, r, 0, 360);
                            }
                        }
                    }
                }
            });
            this.hand.set("draw", (display, graphics) => {
                const parent = graphics.parent;
                if (parent) {
                    let bullet = parent.parent;
                    // to be redrawn when size changes
                    if (bullet) {
                        bullet.set("width", percent(1));
                    }
                    const dataItem = parent.dataItem;
                    if (dataItem) {
                        const axis = dataItem.component;
                        if (axis) {
                            const chart = axis.chart;
                            if (chart) {
                                const bw = parent.get("bottomWidth", 10) / 2;
                                const tw = parent.get("topWidth", 0) / 2;
                                const cr = chart.getPrivate("radius", 0);
                                let r = relativeToValue(parent.get("radius", 0), cr);
                                if (r < 0) {
                                    r = cr + r;
                                }
                                let ir = parent.get("innerRadius", 0);
                                if (ir instanceof Percent) {
                                    ir = relativeToValue(ir, cr);
                                }
                                else {
                                    if (ir < 0) {
                                        if (ir < 0) {
                                            ir = r + ir;
                                        }
                                    }
                                }
                                display.moveTo(ir, -bw);
                                display.lineTo(r, -tw);
                                display.lineTo(r, tw);
                                display.lineTo(ir, bw);
                                display.lineTo(ir, -bw);
                            }
                        }
                    }
                }
            });
        }
        _prepareChildren() {
            super._prepareChildren();
            this.hand._markDirtyKey("fill");
            this.pin._markDirtyKey("fill");
        }
    }
    Object.defineProperty(ClockHand, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ClockHand"
    });
    Object.defineProperty(ClockHand, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Container.classNames.concat([ClockHand.className])
    });

    /**
     * @ignore
     */
    class RadarDefaultTheme extends Theme {
        setupDefaultRules() {
            super.setupDefaultRules();
            const r = this.rule.bind(this);
            const ic = this._root.interfaceColors;
            /**
             * ========================================================================
             * charts/radar
             * ========================================================================
             */
            r("RadarChart").setAll({
                radius: percent(80),
                innerRadius: 0,
                startAngle: -90,
                endAngle: 270
            });
            r("RadarColumnSeries").setAll({
                clustered: true
            });
            r("Slice", ["radar", "column", "series"]).setAll({
                width: percent(80),
                height: percent(80)
            });
            r("RadarLineSeries").setAll({
                connectEnds: true
            });
            r("SmoothedRadarLineSeries").setAll({
                tension: 0.5
            });
            r("AxisRendererRadial").setAll({
                minGridDistance: 40,
                axisAngle: -90,
                inversed: false,
                cellStartLocation: 0,
                cellEndLocation: 1
            });
            r("AxisRendererCircular").setAll({
                minGridDistance: 100,
                inversed: false,
                cellStartLocation: 0,
                cellEndLocation: 1
            });
            r("RadialLabel", ["circular"]).setAll({
                textType: "circular",
                paddingTop: 1,
                paddingRight: 0,
                paddingBottom: 1,
                paddingLeft: 0,
                centerX: 0,
                centerY: 0,
                radius: 8
            });
            r("AxisLabelRadial", ["category"]).setAll({
                text: "{category}",
                populateText: true
            });
            r("RadialLabel", ["radial"]).setAll({
                textType: "regular",
                centerX: 0,
                textAlign: "right"
            });
            r("RadarChart", ["gauge"]).setAll({
                startAngle: 180,
                endAngle: 360,
                innerRadius: percent(90)
            });
            r("ClockHand").setAll({
                topWidth: 1,
                bottomWidth: 10,
                radius: percent(90),
                pinRadius: 10
            });
            {
                const rule = r("Graphics", ["clock", "hand"]);
                rule.setAll({
                    fillOpacity: 1
                });
                setColor(rule, "fill", ic, "alternativeBackground");
            }
            {
                const rule = r("Graphics", ["clock", "pin"]);
                rule.setAll({
                    fillOpacity: 1
                });
                setColor(rule, "fill", ic, "alternativeBackground");
            }
        }
    }

    /**
     * Radar chart.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/radar-chart/} for more info
     * @important
     */
    class RadarChart extends XYChart {
        constructor() {
            super(...arguments);
            /**
             * [[Container]] where radar-related elements go.
             *
             * @default Container.new()
             */
            Object.defineProperty(this, "radarContainer", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.plotContainer.children.push(Container.new(this._root, { x: p50, y: p50 }))
            });
            Object.defineProperty(this, "_arcGenerator", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: arc()
            });
            Object.defineProperty(this, "_maxRadius", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 1
            });
        }
        _afterNew() {
            this._defaultThemes.push(RadarDefaultTheme.new(this._root));
            super._afterNew();
            const radarContainer = this.radarContainer;
            const gridContainer = this.gridContainer;
            const topGridContainer = this.topGridContainer;
            const seriesContainer = this.seriesContainer;
            const bulletsContainer = this.bulletsContainer;
            radarContainer.children.pushAll([gridContainer, seriesContainer, topGridContainer, bulletsContainer]);
            seriesContainer.set("mask", Graphics.new(this._root, {}));
            gridContainer.set("mask", Graphics.new(this._root, {}));
            this._disposers.push(this.plotContainer.events.on("boundschanged", () => {
                this._updateRadius();
            }));
        }
        _maskGrid() {
        }
        _prepareChildren() {
            super._prepareChildren();
            if (this._sizeDirty || this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("endAngle")) {
                const chartContainer = this.chartContainer;
                const w = chartContainer.innerWidth();
                const h = chartContainer.innerHeight();
                const startAngle = this.get("startAngle", 0);
                const endAngle = this.get("endAngle", 0);
                const innerRadius = this.get("innerRadius");
                let bounds = getArcBounds(0, 0, startAngle, endAngle, 1);
                const wr = w / (bounds.right - bounds.left);
                const hr = h / (bounds.bottom - bounds.top);
                let innerBounds = { left: 0, right: 0, top: 0, bottom: 0 };
                if (innerRadius instanceof Percent) {
                    let value = innerRadius.value;
                    let mr = Math.min(wr, hr);
                    value = Math.max(mr * value, mr - Math.min(h, w)) / mr;
                    innerBounds = getArcBounds(0, 0, startAngle, endAngle, value);
                    this.setPrivateRaw("irModifyer", value / innerRadius.value);
                }
                bounds = mergeBounds([bounds, innerBounds]);
                this._maxRadius = Math.max(0, Math.min(wr, hr));
                const radius = relativeToValue(this.get("radius", 0), this._maxRadius);
                this.radarContainer.setAll({
                    dy: -radius * (bounds.bottom + bounds.top) / 2, dx: -radius * (bounds.right + bounds.left) / 2
                });
                this._updateRadius();
            }
        }
        _addCursor(cursor) {
            this.radarContainer.children.push(cursor);
        }
        // do not delete
        _updateRadius() {
            const radius = relativeToValue(this.get("radius", percent(80)), this._maxRadius);
            this.setPrivateRaw("radius", radius);
            let innerRadius = relativeToValue(this.get("innerRadius", 0), radius);
            if (innerRadius < 0) {
                innerRadius = radius + innerRadius;
            }
            this.setPrivateRaw("innerRadius", innerRadius);
            this.xAxes.each((axis) => {
                const renderer = axis.get("renderer");
                renderer.updateLayout();
            });
            this.yAxes.each((axis) => {
                const renderer = axis.get("renderer");
                renderer.updateLayout();
            });
            this._updateMask(this.seriesContainer, innerRadius, radius);
            this._updateMask(this.gridContainer, innerRadius, radius);
            this.series.each((series) => {
                if (series.get("maskBullets")) {
                    this._updateMask(series.bulletsContainer, innerRadius, radius);
                }
                else {
                    series.bulletsContainer.remove("mask");
                }
            });
            const cursor = this.get("cursor");
            if (cursor) {
                cursor.updateLayout();
            }
        }
        /**
         * @ignore
         */
        _updateMask(container, innerRadius, radius) {
            const mask = container.get("mask");
            if (mask) {
                mask.set("draw", (display) => {
                    this._arcGenerator.context(display);
                    this._arcGenerator({ innerRadius: innerRadius, outerRadius: radius + .5, startAngle: (this.get("startAngle", 0) + 90) * RADIANS, endAngle: (this.get("endAngle", 0) + 90) * RADIANS });
                });
            }
        }
        /**
         * @ignore
         */
        processAxis(axis) {
            this.radarContainer.children.push(axis);
        }
        /**
         * @ignore
         */
        inPlot(point, radius, innerRadius) {
            const r = Math.hypot(point.x, point.y);
            const angle = normalizeAngle(Math.atan2(point.y, point.x) * DEGREES);
            let startAngle = normalizeAngle(this.get("startAngle", 0));
            let endAngle = normalizeAngle(this.get("endAngle", 0));
            let inArc = false;
            if (startAngle < endAngle) {
                if (startAngle < angle && angle < endAngle) {
                    inArc = true;
                }
            }
            if (startAngle > endAngle) {
                if (angle > startAngle) {
                    inArc = true;
                }
                if (angle < endAngle) {
                    inArc = true;
                }
            }
            if (startAngle == endAngle) {
                inArc = true;
            }
            if (!inArc) {
                return false;
            }
            if (radius == null) {
                radius = this.getPrivate("radius", 0);
            }
            if (innerRadius == null) {
                innerRadius = this.getPrivate("innerRadius", 0);
            }
            if (innerRadius > radius) {
                [innerRadius, radius] = [radius, innerRadius];
            }
            if (r <= radius + .5 && r >= innerRadius - .5) {
                return true;
            }
            return false;
        }
        _tooltipToLocal(point) {
            return this.radarContainer._display.toLocal(point);
        }
        _handlePinch() {
        }
    }
    Object.defineProperty(RadarChart, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RadarChart"
    });
    Object.defineProperty(RadarChart, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: XYChart.classNames.concat([RadarChart.className])
    });

    /**
     * A column series for use in a [[RadarChart]].
     *
     * @important
     */
    class RadarColumnSeries extends BaseColumnSeries {
        constructor() {
            super(...arguments);
            /**
             * A [[TemplateList]] of all columns in series.
             *
             * `columns.template` can be used to set default settings for all columns,
             * or to change on existing ones.
             *
             * @default new ListTemplate<Slice>
             */
            Object.defineProperty(this, "columns", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: new ListTemplate(Template.new({}), () => Slice._new(this._root, {
                    position: "absolute",
                    themeTags: mergeTags(this.columns.template.get("themeTags", []), ["radar", "series", "column"])
                }, [this.columns.template]))
            });
        }
        /**
         * @ignore
         */
        makeColumn(dataItem, listTemplate) {
            const column = this.mainContainer.children.push(listTemplate.make());
            column._setDataItem(dataItem);
            listTemplate.push(column);
            return column;
        }
        _afterNew() {
            super._afterNew();
            this.set("maskContent", false);
            this.bulletsContainer.set("maskContent", false);
            this.bulletsContainer.set("mask", Graphics.new(this._root, {}));
        }
        /**
         * @ignore
         */
        getPoint(positionX, positionY) {
            const yAxis = this.get("yAxis");
            const xAxis = this.get("xAxis");
            const rendererY = xAxis.get("renderer");
            const radius = yAxis.get("renderer").positionToCoordinate(positionY) + rendererY.getPrivate("innerRadius", 0);
            const rendererX = xAxis.get("renderer");
            const angle = rendererX.positionToAngle(positionX);
            return { x: radius * cos(angle), y: radius * sin(angle) };
        }
        _updateSeriesGraphics(dataItem, graphics, l, r, t, b) {
            graphics.setPrivate("visible", true);
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const rendererX = xAxis.get("renderer");
            const rendererY = yAxis.get("renderer");
            const axisInnerRadius = rendererY.getPrivate("innerRadius", 0);
            const startAngle = rendererX.fitAngle(rendererX.positionToAngle(l));
            const endAngle = rendererX.fitAngle(rendererX.positionToAngle(r));
            let innerRadius = rendererY.positionToCoordinate(b) + axisInnerRadius;
            let radius = rendererY.positionToCoordinate(t) + axisInnerRadius;
            const slice = graphics;
            dataItem.setRaw("startAngle", startAngle);
            dataItem.setRaw("endAngle", endAngle);
            dataItem.setRaw("innerRadius", innerRadius);
            dataItem.setRaw("radius", radius);
            let axisStartAngle = 0;
            let axisEndAngle = 360;
            if (yAxis == this.get("baseAxis")) {
                axisStartAngle = rendererY.getPrivate("startAngle", 0);
                axisEndAngle = rendererY.getPrivate("endAngle", 360);
            }
            else {
                axisStartAngle = rendererX.getPrivate("startAngle", 0);
                axisEndAngle = rendererX.getPrivate("endAngle", 360);
            }
            if (axisStartAngle > axisEndAngle) {
                [axisStartAngle, axisEndAngle] = [axisEndAngle, axisStartAngle];
            }
            if ((endAngle <= axisStartAngle) || (startAngle >= axisEndAngle) || (radius <= axisInnerRadius && innerRadius <= axisInnerRadius)) {
                slice.setPrivate("visible", false);
            }
            slice.setAll({ innerRadius, radius, startAngle, arc: endAngle - startAngle });
        }
        _shouldInclude(position) {
            const xAxis = this.get("xAxis");
            if (position < xAxis.get("start") || position > xAxis.get("end")) {
                return false;
            }
            return true;
        }
        _shouldShowBullet(positionX, _positionY) {
            const xAxis = this.get("xAxis");
            if (positionX < xAxis.get("start") || positionX > xAxis.get("end")) {
                return false;
            }
            return this._showBullets;
        }
        _positionBullet(bullet) {
            let sprite = bullet.get("sprite");
            if (sprite) {
                const dataItem = sprite.dataItem;
                const locationX = bullet.get("locationX", dataItem.get("locationX", 0.5));
                const locationY = bullet.get("locationY", dataItem.get("locationY", 0.5));
                const series = dataItem.component;
                const xAxis = series.get("xAxis");
                const yAxis = series.get("yAxis");
                const positionX = xAxis.getDataItemPositionX(dataItem, series._xField, locationX, series.get("vcx", 1));
                const positionY = yAxis.getDataItemPositionY(dataItem, series._yField, locationY, series.get("vcy", 1));
                const startAngle = dataItem.get("startAngle", 0);
                const endAngle = dataItem.get("endAngle", 0);
                const radius = dataItem.get("radius", 0);
                const innerRadius = dataItem.get("innerRadius", 0);
                if (series._shouldShowBullet(positionX, positionY)) {
                    sprite.setPrivate("visible", true);
                    const angle = startAngle + (endAngle - startAngle) * locationX;
                    const r = innerRadius + (radius - innerRadius) * locationY;
                    sprite.set("x", cos(angle) * r);
                    sprite.set("y", sin(angle) * r);
                }
                else {
                    sprite.setPrivate("visible", false);
                }
            }
        }
        _handleMaskBullets() {
        }
        _processAxisRange(axisRange) {
            super._processAxisRange(axisRange);
            axisRange.columns = new ListTemplate(Template.new({}), () => Slice._new(this._root, {
                position: "absolute",
                themeTags: mergeTags(axisRange.columns.template.get("themeTags", []), ["radar", "series", "column"]),
            }, [this.columns.template, axisRange.columns.template]));
        }
    }
    Object.defineProperty(RadarColumnSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RadarColumnSeries"
    });
    Object.defineProperty(RadarColumnSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: BaseColumnSeries.classNames.concat([RadarColumnSeries.className])
    });

    /**
     * Creates a cursor for a [[RadarChart]].
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/radar-chart/#Cursor} for more info
     */
    class RadarCursor extends XYCursor {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_fillGenerator", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: arc()
            });
        }
        _afterNew() {
            this._settings.themeTags = mergeTags(this._settings.themeTags, ["radar", "cursor"]);
            super._afterNew();
        }
        _handleXLine() {
        }
        _handleYLine() {
        }
        _getPosition(point) {
            const radius = Math.hypot(point.x, point.y);
            let angle = normalizeAngle(Math.atan2(point.y, point.x) * DEGREES);
            const innerRadius = this.getPrivate("innerRadius");
            let startAngle = normalizeAngle(this.getPrivate("startAngle"));
            let endAngle = normalizeAngle(this.getPrivate("endAngle"));
            if (endAngle < startAngle || endAngle == startAngle) {
                if (angle < startAngle) {
                    angle += 360;
                }
                endAngle = endAngle + 360;
            }
            let xPos = (angle - startAngle) / (endAngle - startAngle);
            if (xPos < 0) {
                xPos = 1 + xPos;
            }
            if (xPos < 0.003) {
                xPos = 0;
            }
            if (xPos > 0.997) {
                xPos = 1;
            }
            return { x: xPos, y: (radius - innerRadius) / (this.getPrivate("radius") - innerRadius) };
        }
        _getPoint(positionX, positionY) {
            const innerRadius = this.getPrivate("innerRadius");
            const startAngle = this.getPrivate("startAngle");
            const endAngle = this.getPrivate("endAngle");
            const radius = this.getPrivate("radius");
            const angle = startAngle + positionX * (endAngle - startAngle);
            const r = innerRadius + (radius - innerRadius) * positionY;
            return { x: r * cos(angle), y: r * sin(angle) };
        }
        /**
         * @ignore
         */
        updateLayout() {
            const chart = this.chart;
            if (chart) {
                const radius = chart.getPrivate("radius", 0);
                this.setPrivate("radius", relativeToValue(this.get("radius", p100), radius));
                let innerRadius = relativeToValue(this.get("innerRadius", chart.getPrivate("innerRadius", 0)), radius);
                if (innerRadius < 0) {
                    innerRadius = radius + innerRadius;
                }
                this.setPrivate("innerRadius", innerRadius);
                let startAngle = this.get("startAngle", chart.get("startAngle", -90));
                let endAngle = this.get("endAngle", chart.get("endAngle", 270));
                this.setPrivate("startAngle", startAngle);
                this.setPrivate("endAngle", endAngle);
            }
        }
        _updateLines(x, y) {
            if (!this._tooltipX) {
                this._drawXLine(x, y);
            }
            if (!this._tooltipY) {
                this._drawYLine(x, y);
            }
        }
        _drawXLine(x, y) {
            const innerRadius = this.getPrivate("innerRadius");
            const radius = this.getPrivate("radius");
            const angle = Math.atan2(y, x);
            this.lineX.set("draw", (display) => {
                display.moveTo(innerRadius * Math.cos(angle), innerRadius * Math.sin(angle));
                display.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
            });
        }
        _drawYLine(x, y) {
            const positionRadius = Math.hypot(x, y);
            this.lineY.set("draw", (display) => {
                display.arc(0, 0, positionRadius, this.getPrivate("startAngle", 0) * RADIANS, this.getPrivate("endAngle", 0) * RADIANS);
            });
        }
        _updateXLine(tooltip) {
            let point = tooltip.get("pointTo");
            if (point) {
                point = this._display.toLocal(point);
                this._drawXLine(point.x, point.y);
            }
        }
        _updateYLine(tooltip) {
            let point = tooltip.get("pointTo");
            if (point) {
                point = this._display.toLocal(point);
                this._drawYLine(point.x, point.y);
            }
        }
        _inPlot(point) {
            const chart = this.chart;
            if (chart) {
                return chart.inPlot(point, this.getPrivate("radius"), this.getPrivate("innerRadius"));
            }
            return false;
        }
        _updateSelection(point) {
            this.selection.set("draw", (display) => {
                const behavior = this.get("behavior");
                const downPoint = this._downPoint;
                const cursorStartAngle = this.getPrivate("startAngle");
                const cursorEndAngle = this.getPrivate("endAngle");
                let cursorRadius = this.getPrivate("radius");
                let cursorInnerRadius = this.getPrivate("innerRadius");
                if (cursorRadius < cursorInnerRadius) {
                    [cursorRadius, cursorInnerRadius] = [cursorInnerRadius, cursorRadius];
                }
                let startAngle = cursorStartAngle;
                let endAngle = cursorEndAngle;
                let radius = cursorRadius;
                let innerRadius = cursorInnerRadius;
                if (downPoint) {
                    if (behavior == "zoomXY" || behavior == "selectXY") {
                        startAngle = Math.atan2(downPoint.y, downPoint.x) * DEGREES;
                        endAngle = Math.atan2(point.y, point.x) * DEGREES;
                        innerRadius = Math.hypot(downPoint.x, downPoint.y);
                        radius = Math.hypot(point.x, point.y);
                    }
                    else if (behavior == "zoomX" || behavior == "selectX") {
                        startAngle = Math.atan2(downPoint.y, downPoint.x) * DEGREES;
                        endAngle = Math.atan2(point.y, point.x) * DEGREES;
                    }
                    else if (behavior == "zoomY" || behavior == "selectY") {
                        innerRadius = Math.hypot(downPoint.x, downPoint.y);
                        radius = Math.hypot(point.x, point.y);
                    }
                }
                innerRadius = fitToRange(innerRadius, cursorInnerRadius, cursorRadius);
                radius = fitToRange(radius, cursorInnerRadius, cursorRadius);
                startAngle = fitAngleToRange(startAngle, cursorStartAngle, cursorEndAngle);
                endAngle = fitAngleToRange(endAngle, cursorStartAngle, cursorEndAngle);
                if (startAngle == endAngle) {
                    endAngle = startAngle + 360;
                }
                startAngle *= RADIANS;
                endAngle *= RADIANS;
                this._fillGenerator.context(display);
                this._fillGenerator({ innerRadius: innerRadius, outerRadius: radius, startAngle: startAngle + Math.PI / 2, endAngle: endAngle + Math.PI / 2 });
            });
        }
    }
    Object.defineProperty(RadarCursor, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RadarCursor"
    });
    Object.defineProperty(RadarCursor, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: XYCursor.classNames.concat([RadarCursor.className])
    });

    /**
     * Draws a line series for use in a [[RadarChart]].
     *
     * @important
     */
    class RadarLineSeries extends LineSeries {
        _afterNew() {
            super._afterNew();
            this.set("maskContent", false);
            this.bulletsContainer.set("maskContent", false);
            this.bulletsContainer.set("mask", Graphics.new(this._root, {}));
        }
        _handleMaskBullets() {
        }
        getPoint(positionX, positionY) {
            const yAxis = this.get("yAxis");
            const xAxis = this.get("xAxis");
            const rendererY = yAxis.get("renderer");
            const radius = rendererY.positionToCoordinate(positionY) + rendererY.getPrivate("innerRadius", 0);
            const rendererX = xAxis.get("renderer");
            const angle = rendererX.positionToAngle(positionX);
            return { x: radius * cos(angle), y: radius * sin(angle) };
        }
        _endLine(points, firstPoint) {
            if (this.get("connectEnds") && firstPoint) {
                points.push(firstPoint);
            }
        }
        _shouldInclude(position) {
            const xAxis = this.get("xAxis");
            if (position < xAxis.get("start") || position > xAxis.get("end")) {
                return false;
            }
            return true;
        }
        _shouldShowBullet(positionX, _positionY) {
            const xAxis = this.get("xAxis");
            if (positionX < xAxis.get("start") || positionX > xAxis.get("end")) {
                return false;
            }
            return this._showBullets;
        }
        _positionBullet(bullet) {
            let sprite = bullet.get("sprite");
            if (sprite) {
                let dataItem = sprite.dataItem;
                let locationX = bullet.get("locationX", dataItem.get("locationX", 0.5));
                let locationY = bullet.get("locationY", dataItem.get("locationY", 0.5));
                let xAxis = this.get("xAxis");
                let yAxis = this.get("yAxis");
                //let baseAxis = this.get("baseAxis");
                //if(xAxis == baseAxis){
                //locationY = 1;
                //}
                //else if(yAxis == baseAxis){
                //locationX = 1;
                //}
                const positionX = xAxis.getDataItemPositionX(dataItem, this._xField, locationX, this.get("vcx", 1));
                const positionY = yAxis.getDataItemPositionY(dataItem, this._yField, locationY, this.get("vcy", 1));
                let point = this.getPoint(positionX, positionY);
                if (this._shouldShowBullet(positionX, positionY)) {
                    sprite.setPrivate("visible", true);
                    sprite.set("x", point.x);
                    sprite.set("y", point.y);
                }
                else {
                    sprite.setPrivate("visible", false);
                }
            }
        }
    }
    Object.defineProperty(RadarLineSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RadarLineSeries"
    });
    Object.defineProperty(RadarLineSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: LineSeries.classNames.concat([RadarLineSeries.className])
    });

    /**
     * Draws a smoothed line series for use in a [[RadarChart]].
     *
     * @important
     */
    class SmoothedRadarLineSeries extends RadarLineSeries {
        _afterNew() {
            this._setDefault("curveFactory", curveCardinalClosed.tension(this.get("tension", 0)));
            super._afterNew();
        }
        _prepareChildren() {
            super._prepareChildren();
            if (this.isDirty("connectEnds")) {
                const connectEnds = this.get("connectEnds");
                if (connectEnds) {
                    this.setRaw("curveFactory", curveCardinalClosed.tension(this.get("tension", 0)));
                }
                else {
                    this.setRaw("curveFactory", curveCardinal.tension(this.get("tension", 0)));
                }
            }
            if (this.isDirty("tension")) {
                let cf = this.get("curveFactory");
                if (cf) {
                    cf.tension(this.get("tension", 0));
                }
            }
        }
        _endLine(_points, _firstPoint) {
        }
    }
    Object.defineProperty(SmoothedRadarLineSeries, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SmoothedRadarLineSeries"
    });
    Object.defineProperty(SmoothedRadarLineSeries, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: RadarLineSeries.classNames.concat([SmoothedRadarLineSeries.className])
    });

    var am5radar = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AxisRendererCircular: AxisRendererCircular,
        AxisRendererRadial: AxisRendererRadial,
        ClockHand: ClockHand,
        DefaultTheme: RadarDefaultTheme,
        RadarChart: RadarChart,
        RadarColumnSeries: RadarColumnSeries,
        RadarCursor: RadarCursor,
        RadarLineSeries: RadarLineSeries,
        SmoothedRadarLineSeries: SmoothedRadarLineSeries
    });

    /**
     * @ignore
     */
    class AnimatedTheme extends Theme {
        setupDefaultRules() {
            super.setupDefaultRules();
            this.rule("Component").setAll({
                interpolationDuration: 600
            });
            this.rule("Hierarchy").set("animationDuration", 600);
            this.rule("Scrollbar").set("animationDuration", 600);
            this.rule("Tooltip").set("animationDuration", 300);
            this.rule("MapChart").set("animationDuration", 1000);
            this.rule("MapChart").set("wheelDuration", 300);
            this.rule("Entity").setAll({
                stateAnimationDuration: 600
            });
            this.rule("Sprite").states.create("default", { stateAnimationDuration: 600 });
            this.rule("Tooltip", ["axis"]).setAll({
                animationDuration: 200
            });
            this.rule("WordCloud").set("animationDuration", 500);
            this.rule("Polygon").set("animationDuration", 600);
            this.rule("ArcDiagram").set("animationDuration", 600);
        }
    }

    /* src/components/Gauge.svelte generated by Svelte v3.59.2 */
    const file$1 = "src/components/Gauge.svelte";

    function create_fragment$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "width", "100%");
    			set_style(div, "height", "200px");
    			add_location(div, file$1, 133, 0, 3716);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[2](div);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[2](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Gauge', slots, []);
    	let { demLead } = $$props;
    	demLead *= 100;

    	const colors = {
    		dem: { main: "#00f", secondary: "#bbf" },
    		rep: { main: "#d00", secondary: "#fbb" }
    	};

    	let lead_color = '#aaa';

    	if (demLead > 2) {
    		lead_color = colors.dem.main;
    	} else if (demLead < -2) {
    		lead_color = colors.rep.main;
    	}

    	let lead_bg_color = '#ddd';

    	if (demLead > 2) {
    		lead_bg_color = colors.dem.secondary;
    	} else if (demLead < -2) {
    		lead_bg_color = colors.rep.secondary;
    	}

    	let chartdiv;

    	onMount(() => {
    		// Create root element
    		let root = Root.new(chartdiv);

    		// Set themes
    		root.setThemes([AnimatedTheme.new(root)]);

    		// Create chart
    		let chart = root.container.children.push(RadarChart.new(root, {
    			panX: false,
    			panY: false,
    			startAngle: 160,
    			endAngle: 380,
    			innerRadius: -20
    		}));

    		let gradientFill = LinearGradient.new(root, {
    			rotation: 0,
    			stops: [
    				{ color: color('#f77'), offset: 0 },
    				{ color: color('#eee'), offset: 0.5000 },
    				{ color: color('#eee'), offset: 0.7617 },
    				{ color: color('#77f'), offset: 1 }
    			]
    		});

    		// Create axis and its renderer
    		let axisRenderer = AxisRendererCircular.new(root, {
    			strokeWidth: 30,
    			strokeOpacity: 1,
    			strokeGradient: gradientFill
    		});

    		let xAxis = chart.xAxes.push(ValueAxis.new(root, {
    			maxDeviation: 0,
    			min: -15,
    			max: 15,
    			strictMinMax: true,
    			renderer: axisRenderer
    		}));

    		// Add clock hand
    		let axisDataItem = xAxis.makeDataItem({});

    		let clockHand = ClockHand.new(root, {
    			pinRadius: percent(45),
    			radius: percent(60),
    			bottomWidth: 60,
    			pinFill: color(lead_bg_color)
    		});

    		clockHand.pin.adapters.add("fill", () => color(lead_bg_color));
    		clockHand.hand.adapters.add("fill", () => color(lead_bg_color));
    		let bullet = axisDataItem.set("bullet", AxisBullet.new(root, { sprite: clockHand }));
    		xAxis.createAxisRange(axisDataItem);

    		let label = chart.radarContainer.children.push(Label.new(root, {
    			fill: color(lead_color),
    			centerX: percent(50),
    			textAlign: "center",
    			centerY: percent(50),
    			fontSize: "1.5rem"
    		})); /* fontFamily: "Courier", */

    		// Set the initial value based on the prop
    		axisDataItem.set("value", demLead);

    		bullet.get("sprite").on("rotation", function () {
    			let value = axisDataItem.get("value");
    			label.set("text", Math.abs(value).toFixed(1).toString().replace(".", ","));
    		});

    		chart.appear(1000, 100);

    		return () => {
    			root.dispose();
    		};
    	});

    	$$self.$$.on_mount.push(function () {
    		if (demLead === undefined && !('demLead' in $$props || $$self.$$.bound[$$self.$$.props['demLead']])) {
    			console.warn("<Gauge> was created without expected prop 'demLead'");
    		}
    	});

    	const writable_props = ['demLead'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Gauge> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			chartdiv = $$value;
    			$$invalidate(0, chartdiv);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('demLead' in $$props) $$invalidate(1, demLead = $$props.demLead);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		am5,
    		am5xy,
    		am5radar,
    		am5themes_Animated: AnimatedTheme,
    		demLead,
    		colors,
    		lead_color,
    		lead_bg_color,
    		chartdiv
    	});

    	$$self.$inject_state = $$props => {
    		if ('demLead' in $$props) $$invalidate(1, demLead = $$props.demLead);
    		if ('lead_color' in $$props) lead_color = $$props.lead_color;
    		if ('lead_bg_color' in $$props) lead_bg_color = $$props.lead_bg_color;
    		if ('chartdiv' in $$props) $$invalidate(0, chartdiv = $$props.chartdiv);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [chartdiv, demLead, div_binding];
    }

    class Gauge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, { demLead: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Gauge",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get demLead() {
    		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set demLead(value) {
    		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.59.2 */

    const { Object: Object_1, console: console_1 } = globals;
    const file = "src/App.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    // (435:12) {#if demLead !== null && leadHTML !== null}
    function create_if_block_1(ctx) {
    	let p0;
    	let t0;
    	let span0;
    	let t1_value = Math.abs((/*demLead*/ ctx[0] * 100).toFixed(0)) + "";
    	let t1;
    	let t2;
    	let span0_class_value;
    	let t3;
    	let t4_value = (/*demLead*/ ctx[0] > 0 ? 'demokrata' : 'republikánus') + "";
    	let t4;
    	let t5;
    	let span1;
    	let t6;
    	let gauge;
    	let t7;
    	let p1;
    	let current;

    	gauge = new Gauge({
    			props: { demLead: /*demLead*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			t0 = text$1("Nagyjából ");
    			span0 = element("span");
    			t1 = text$1(t1_value);
    			t2 = text$1("%");
    			t3 = text$1("-os ");
    			t4 = text$1(t4_value);
    			t5 = text$1(" vezetésnél ");
    			span1 = element("span");
    			t6 = space();
    			create_component(gauge.$$.fragment);
    			t7 = space();
    			p1 = element("p");
    			p1.textContent = "A demokratáknak körülbelül 2%-kal kell vezetniük ahhoz, hogy az elektorok számában fej-fej mellett legyenek a republikánusokkal.";
    			attr_dev(span0, "class", span0_class_value = "compact " + (/*demLead*/ ctx[0] > 0 ? "dem" : "rep") + " svelte-1r7nmt2");
    			add_location(span0, file, 435, 46, 15798);
    			attr_dev(span1, "class", "container");
    			add_location(span1, file, 435, 205, 15957);
    			attr_dev(p0, "class", "has-data svelte-1r7nmt2");
    			add_location(p0, file, 435, 16, 15768);
    			attr_dev(p1, "class", "info svelte-1r7nmt2");
    			add_location(p1, file, 437, 16, 16061);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t0);
    			append_dev(p0, span0);
    			append_dev(span0, t1);
    			append_dev(span0, t2);
    			append_dev(p0, t3);
    			append_dev(p0, t4);
    			append_dev(p0, t5);
    			append_dev(p0, span1);
    			span1.innerHTML = /*leadHTML*/ ctx[1];
    			insert_dev(target, t6, anchor);
    			mount_component(gauge, target, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, p1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*demLead*/ 1) && t1_value !== (t1_value = Math.abs((/*demLead*/ ctx[0] * 100).toFixed(0)) + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*demLead*/ 1 && span0_class_value !== (span0_class_value = "compact " + (/*demLead*/ ctx[0] > 0 ? "dem" : "rep") + " svelte-1r7nmt2")) {
    				attr_dev(span0, "class", span0_class_value);
    			}

    			if ((!current || dirty & /*demLead*/ 1) && t4_value !== (t4_value = (/*demLead*/ ctx[0] > 0 ? 'demokrata' : 'republikánus') + "")) set_data_dev(t4, t4_value);
    			if (!current || dirty & /*leadHTML*/ 2) span1.innerHTML = /*leadHTML*/ ctx[1];			const gauge_changes = {};
    			if (dirty & /*demLead*/ 1) gauge_changes.demLead = /*demLead*/ ctx[0];
    			gauge.$set(gauge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(gauge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(gauge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t6);
    			destroy_component(gauge, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(p1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(435:12) {#if demLead !== null && leadHTML !== null}",
    		ctx
    	});

    	return block;
    }

    // (444:12) {#if aggregatorsCurrent.length !== 0}
    function create_if_block(ctx) {
    	let div;
    	let each_value = /*aggregatorsCurrent*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "aggregator-bubbles svelte-1r7nmt2");
    			add_location(div, file, 444, 16, 17290);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*aggregatorsCurrent*/ 4) {
    				each_value = /*aggregatorsCurrent*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(444:12) {#if aggregatorsCurrent.length !== 0}",
    		ctx
    	});

    	return block;
    }

    // (446:20) {#each aggregatorsCurrent as aggregator}
    function create_each_block(ctx) {
    	let div;
    	let t0_value = /*aggregator*/ ctx[20].name + "";
    	let t0;
    	let t1;
    	let span;
    	let t2;
    	let t3_value = /*aggregator*/ ctx[20].lead + "";
    	let t3;
    	let span_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span = element("span");
    			t2 = text$1("+");
    			t3 = text$1(t3_value);
    			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*aggregator*/ ctx[20].leading) + " svelte-1r7nmt2"));
    			add_location(span, file, 446, 66, 17450);
    			attr_dev(div, "class", "aggregator svelte-1r7nmt2");
    			add_location(div, file, 446, 24, 17408);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, span);
    			append_dev(span, t2);
    			append_dev(span, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*aggregatorsCurrent*/ 4 && t0_value !== (t0_value = /*aggregator*/ ctx[20].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*aggregatorsCurrent*/ 4 && t3_value !== (t3_value = /*aggregator*/ ctx[20].lead + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*aggregatorsCurrent*/ 4 && span_class_value !== (span_class_value = "" + (null_to_empty(/*aggregator*/ ctx[20].leading) + " svelte-1r7nmt2"))) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(446:20) {#each aggregatorsCurrent as aggregator}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let article2;
    	let header;
    	let h10;
    	let span0;
    	let t1;
    	let div0;
    	let t2;
    	let span1;
    	let t4;
    	let div1;
    	let article0;
    	let h2;
    	let t6;
    	let t7;
    	let section;
    	let h11;
    	let t9;
    	let p;
    	let t10;
    	let a0;
    	let t12;
    	let a1;
    	let t14;
    	let a2;
    	let t16;
    	let a3;
    	let t18;
    	let a4;
    	let t20;
    	let t21;
    	let t22;
    	let svg;
    	let t23;
    	let article1;
    	let current;
    	let if_block0 = /*demLead*/ ctx[0] !== null && /*leadHTML*/ ctx[1] !== null && create_if_block_1(ctx);
    	let if_block1 = /*aggregatorsCurrent*/ ctx[2].length !== 0 && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			article2 = element("article");
    			header = element("header");
    			h10 = element("h1");
    			span0 = element("span");
    			span0.textContent = "Vox Populi";
    			t1 = space();
    			div0 = element("div");
    			t2 = space();
    			span1 = element("span");
    			span1.textContent = "Egyesült Államok 2024";
    			t4 = space();
    			div1 = element("div");
    			article0 = element("article");
    			h2 = element("h2");
    			h2.textContent = "Várható győztes";
    			t6 = space();
    			if (if_block0) if_block0.c();
    			t7 = space();
    			section = element("section");
    			h11 = element("h1");
    			h11.textContent = "Trump vs Harris";
    			t9 = space();
    			p = element("p");
    			t10 = text$1("Az alábbi grafikon az amerikai poll aggregátorokat (");
    			a0 = element("a");
    			a0.textContent = "FiveThirtyEight";
    			t12 = text$1(", ");
    			a1 = element("a");
    			a1.textContent = "RealClear Polling";
    			t14 = text$1(", ");
    			a2 = element("a");
    			a2.textContent = "Silver Bulletin";
    			t16 = text$1(", ");
    			a3 = element("a");
    			a3.textContent = "New York Times";
    			t18 = text$1(", ");
    			a4 = element("a");
    			a4.textContent = "Economist";
    			t20 = text$1(") átlagolja. Lorem ipsum dolor sit amet consectetur adipisicing elit. Sit autem molestiae a sapiente quas! Esse deserunt inventore quidem ipsam labore ducimus debitis, corrupti blanditiis, quisquam, ipsum in consequuntur expedita reiciendis.");
    			t21 = space();
    			if (if_block1) if_block1.c();
    			t22 = space();
    			svg = svg_element("svg");
    			t23 = space();
    			article1 = element("article");
    			attr_dev(span0, "class", "svelte-1r7nmt2");
    			add_location(span0, file, 426, 12, 15435);
    			set_style(div0, "flex-grow", "1");
    			set_style(div0, "flex-shrink", "1");
    			add_location(div0, file, 427, 12, 15471);
    			attr_dev(span1, "class", "svelte-1r7nmt2");
    			add_location(span1, file, 428, 12, 15533);
    			attr_dev(h10, "class", "svelte-1r7nmt2");
    			add_location(h10, file, 425, 8, 15418);
    			attr_dev(header, "class", "svelte-1r7nmt2");
    			add_location(header, file, 424, 4, 15401);
    			attr_dev(h2, "class", "svelte-1r7nmt2");
    			add_location(h2, file, 433, 12, 15671);
    			attr_dev(article0, "id", "winner-gauge");
    			attr_dev(article0, "class", "svelte-1r7nmt2");
    			add_location(article0, file, 432, 8, 15631);
    			attr_dev(h11, "class", "svelte-1r7nmt2");
    			add_location(h11, file, 441, 12, 16293);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", "https://projects.fivethirtyeight.com/polls/president-general/2024/national/");
    			add_location(a0, file, 442, 67, 16385);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", "https://www.realclearpolling.com/polls/president/general/2024/trump-vs-harris");
    			add_location(a1, file, 442, 190, 16508);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "href", "https://www.natesilver.net/p/nate-silver-2024-president-election-polls-model");
    			add_location(a2, file, 442, 317, 16635);
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "href", "https://www.nytimes.com/interactive/2024/us/elections/polls-president.html");
    			add_location(a3, file, 442, 441, 16759);
    			attr_dev(a4, "href", "https://www.economist.com/interactive/us-2024-election/trump-harris-polls/");
    			add_location(a4, file, 442, 562, 16880);
    			attr_dev(p, "class", "svelte-1r7nmt2");
    			add_location(p, file, 442, 12, 16330);
    			attr_dev(svg, "class", "polls svelte-1r7nmt2");
    			add_location(svg, file, 450, 12, 17599);
    			attr_dev(section, "id", "poll-graph");
    			attr_dev(section, "class", "svelte-1r7nmt2");
    			add_location(section, file, 440, 8, 16255);
    			attr_dev(article1, "class", "svelte-1r7nmt2");
    			add_location(article1, file, 452, 8, 17652);
    			attr_dev(div1, "class", "uglygrid svelte-1r7nmt2");
    			add_location(div1, file, 431, 4, 15600);
    			attr_dev(article2, "class", "svelte-1r7nmt2");
    			add_location(article2, file, 423, 0, 15387);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, article2, anchor);
    			append_dev(article2, header);
    			append_dev(header, h10);
    			append_dev(h10, span0);
    			append_dev(h10, t1);
    			append_dev(h10, div0);
    			append_dev(h10, t2);
    			append_dev(h10, span1);
    			append_dev(article2, t4);
    			append_dev(article2, div1);
    			append_dev(div1, article0);
    			append_dev(article0, h2);
    			append_dev(article0, t6);
    			if (if_block0) if_block0.m(article0, null);
    			append_dev(div1, t7);
    			append_dev(div1, section);
    			append_dev(section, h11);
    			append_dev(section, t9);
    			append_dev(section, p);
    			append_dev(p, t10);
    			append_dev(p, a0);
    			append_dev(p, t12);
    			append_dev(p, a1);
    			append_dev(p, t14);
    			append_dev(p, a2);
    			append_dev(p, t16);
    			append_dev(p, a3);
    			append_dev(p, t18);
    			append_dev(p, a4);
    			append_dev(p, t20);
    			append_dev(section, t21);
    			if (if_block1) if_block1.m(section, null);
    			append_dev(section, t22);
    			append_dev(section, svg);
    			append_dev(div1, t23);
    			append_dev(div1, article1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*demLead*/ ctx[0] !== null && /*leadHTML*/ ctx[1] !== null) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*demLead, leadHTML*/ 3) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(article0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*aggregatorsCurrent*/ ctx[2].length !== 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					if_block1.m(section, t22);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(article2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isDataStale() {
    	const oneHour = 1000 * 60 * 60;
    	const now = new Date();
    	const lastUpdated = new Date(sessionStorage.getItem("pollsDataUpdated"));
    	const diff = now - lastUpdated;
    	return sessionStorage.getItem("pollsData") == null || sessionStorage.getItem("pollsDataUpdated") == null || diff >= oneHour;
    }

    function initializeFocusTexts(chartGroup, colors) {
    	const focusTexts = {};

    	Object.keys(colors).forEach(candidate => {
    		focusTexts[candidate] = chartGroup.append("text").attr("class", candidate).attr("text-anchor", "left").attr("alignment-baseline", "middle").style("stroke", '#fff').style("stroke-width", 2).attr("paint-order", "stroke");
    	});

    	return focusTexts;
    }

    function fixLabelPositions(focusTexts, x, y, width, height) {
    	const y_positions = Object.values(focusTexts).map(text => parseFloat(text.attr("y")));
    	const difference = Math.abs(y_positions[0] - y_positions[1]);
    	const average_y = (y_positions[0] + y_positions[1]) / 2;

    	if (difference < 30) {
    		const topCandidate = y_positions[0] > y_positions[1] ? "Trump" : "Harris";
    		const bottomCandidate = y_positions[0] > y_positions[1] ? "Harris" : "Trump";
    		focusTexts[topCandidate].attr("y", average_y + 15);
    		focusTexts[bottomCandidate].attr("y", average_y - 15);
    	}
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let { repo = "hidegmisi/us2024_aggregator_scraper" } = $$props;
    	let demLead = null;
    	let leadHTML = null;
    	let aggregatorsCurrent = [];
    	const colors = { Trump: "red", Harris: "blue" };

    	async function fetchPollData(repo) {
    		const response = await fetch(`https://api.github.com/repos/${repo}/contents/polls.csv`);
    		const json = await response.json();
    		const csvData = atob(json.content);
    		return csvParse(csvData);
    	}

    	async function getPollData(repo) {
    		if (isDataStale()) {
    			const pollData = await fetchPollData(repo);
    			const now = new Date();
    			sessionStorage.setItem("pollsData", JSON.stringify(pollData));
    			sessionStorage.setItem("pollsDataUpdated", now);
    			return pollData;
    		} else {
    			return JSON.parse(sessionStorage.getItem("pollsData"));
    		}
    	}

    	function prepareData(data) {
    		const pollsters = ["fivethirtyeight", "natesilver", "nyt", "realclearpolling"];

    		data.forEach(d => {
    			pollsters.forEach(p => {
    				d[p] = d[p] || null;
    			});
    		});

    		return data.map(d => ({
    			candidate: d.candidate,
    			date: timeParse("%Y-%m-%d")(d.date),
    			value: mean(pollsters.map(p => d[p]))
    		}));
    	}

    	function setDemLeadAndWinningHTML(data) {
    		const currentTrump = data[data.length - 1].value;
    		const currentHarris = data[data.length - 2].value;
    		$$invalidate(0, demLead = currentHarris - currentTrump);

    		if (demLead >= 0.04) {
    			$$invalidate(1, leadHTML = "valószínűleg a <span class='dem'>demokraták</span> fognak nyerni választáson.");
    		} else if (demLead < 0) {
    			$$invalidate(1, leadHTML = "valószínűleg a <span class='rep'>republikánusok</span> fognak nyerni választáson.");
    		} else {
    			$$invalidate(1, leadHTML = "<span class='contest'>szoros</span> eredmény várható a választáson.");
    		}
    	}

    	function setAggregatorsCurrent(data) {
    		const currentTrump = data[data.length - 1];
    		const currentHarris = data[data.length - 2];

    		const aggregators = {
    			fivethirtyeight: '538',
    			realclearpolling: 'RCP',
    			natesilver: 'Silver Bulletin',
    			nyt: 'NYT'
    		};

    		$$invalidate(2, aggregatorsCurrent = Object.keys(aggregators).map((name, displayName) => {
    			const trump = currentTrump[name];
    			const harris = currentHarris[name];
    			const lead = (harris - trump) * 100;

    			return {
    				name: aggregators[name],
    				lead: Math.abs(lead.toFixed(2)),
    				leading: lead > 0 ? "dem" : "rep"
    			};
    		}));
    	}

    	async function fetchData() {
    		try {
    			const data = await getPollData(repo);
    			const parsedData = prepareData(data);
    			setDemLeadAndWinningHTML(parsedData);
    			setAggregatorsCurrent(data);
    			drawChart(parsedData, data);
    		} catch(error) {
    			console.error("Error fetching data:", error);
    		}
    	}

    	function calculateAveragesByCandidate(rawData) {
    		return rollups(rawData, v => mean(v, d => mean([d.fivethirtyeight, d.realclearpolling, d.nyt, d.natesilver])), d => d.candidate, d => timeParse("%Y-%m-%d")(d.date)).map(([candidate, dates]) => ({
    			candidate,
    			values: dates.map(([date, avg]) => ({ date, avg }))
    		}));
    	}

    	function drawChart(parsedData, rawData) {
    		const { margin, width, height, x, y, chartGroup } = setupChart(rawData);
    		const averagesByCandidate = calculateAveragesByCandidate(rawData);
    		drawLines(chartGroup, averagesByCandidate, x, y);
    		drawDots(chartGroup, rawData, x, y);
    		drawGridlines(chartGroup, x, y, width, height);
    		setupInteractivity(chartGroup, averagesByCandidate, x, y, width, height);
    	}

    	function setupChart(rawData) {
    		const margin = { top: 20, right: 0, bottom: 30, left: 0 };
    		const svg = select("svg");
    		const width = parseInt(svg.style("width")) - margin.left - margin.right;
    		const height = width * (4 / 7);
    		const x = time().domain(extent$1(rawData, d => timeParse("%Y-%m-%d")(d.date))).range([0, width - 150]);
    		const y = linear$1().domain([0.35, 0.51]).range([height, 0]);
    		const chartGroup = svg.attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`).attr("preserveAspectRatio", "xMidYMid meet").append("g").attr("transform", `translate(${margin.left},${margin.top})`);
    		return { margin, width, height, x, y, chartGroup };
    	}

    	function drawLines(chartGroup, averagesByCandidate, x, y) {
    		averagesByCandidate.forEach(({ candidate, values }) => {
    			const line = line$1().x(d => x(d.date)).y(d => y(d.avg)).curve(monotoneX);
    			chartGroup.append("path").datum(values).attr("class", candidate).attr("fill", "none").attr("stroke", colors[candidate]).attr("stroke-width", 10).style("opacity", 0.45).attr("d", line);
    		});
    	}

    	function drawDots(chartGroup, rawData, x, y) {
    		const circleGroup = chartGroup.append("g");

    		rawData.forEach(d => {
    			const yValues = [d.fivethirtyeight, d.realclearpolling, d.nyt, d.natesilver].filter(v => v !== null);

    			yValues.forEach(value => {
    				circleGroup.append("circle").attr("cx", x(timeParse("%Y-%m-%d")(d.date))).attr("cy", y(value)).attr("r", 3).attr("fill", colors[d.candidate]).attr("opacity", 0.3);
    			});
    		});
    	}

    	function drawGridlines(chartGroup, x, y, width, height) {
    		chartGroup.append("g").attr("class", "grid x-grid").attr("transform", `translate(0,${height})`).call(axisBottom(x).ticks(timeSunday.every(1)).tickSizeInner(-10).tickPadding(10).tickFormat(d => new Date(d).toLocaleDateString("hu-HU", { month: "short", day: "numeric" }))).call(g => g.select(".domain").remove()).selectAll("line").style("stroke", "#eee").style("stroke-opacity", 1);
    		chartGroup.selectAll(".x-grid").selectAll("text");

    		chartGroup.append("g").attr("class", "grid y-grid").call(axisLeft(y).tickValues([0.35, 0.40, 0.45, 0.50]).tickSize(-width).tickFormat(d => `${d * 100}`)).call(g => g.select(".domain").remove())./* .call((g) => g.selectAll(".tick:last-child text").remove()) */
    		selectAll("line").style("stroke", "#ddd").style("stroke-opacity", 1);

    		chartGroup.selectAll(".y-grid").selectAll("text").attr("dx", "1.5em").attr("dy", "-0.5em");
    		chartGroup.selectAll(".tick").selectAll("text").style("font-size", "14px").style("color", "#666");
    	} //.style("font-family", "courier");

    	function setupInteractivity(chartGroup, averagesByCandidate, x, y, width, height) {
    		const focusDate = chartGroup.append("g").attr("y1", 0).attr("y2", height).attr("x1", width - 151).attr("x2", width - 151);
    		const verticalLine = focusDate.append("line").attr("stroke", "black").attr("stroke-width", 2).attr("y1", 0).attr("y2", height).attr("x1", width - 151).attr("x2", width - 151);
    		const dateLabel = focusDate.append("text").attr("text-anchor", "middle").style("fill", "#333").text(new Date().toLocaleDateString("hu-HU", { month: "long", day: "numeric" }));
    		chartGroup.append("rect").attr("class", "overlay-box").attr("x", width - 150).attr("y", 0).attr("width", 100).attr("height", height).attr("fill", "white").attr("opacity", 0.8);
    		dateLabel.attr("x", width - 150).attr("y", -6);
    		const focusTexts = initializeFocusTexts(chartGroup, colors);
    		updateLabels(focusTexts, averagesByCandidate, x, y);
    		const svg = select(chartGroup.node().parentNode);

    		svg.append("rect").attr("width", width - 150).attr("height", height).style("fill", "none").style("pointer-events", "all").on("mouseover", () => {
    			Object.values(focusTexts).forEach(text => text.style("opacity", 1));
    		}).on("mousemove", function (event) {
    			handleMouseMove(event, chartGroup, averagesByCandidate, x, y, width, height, verticalLine, dateLabel, focusTexts);
    		}).on("mouseout", () => {
    			verticalLine.attr("y1", 0).attr("y2", height).attr("x1", width - 151).attr("x2", width - 151);
    			dateLabel.text(new Date().toLocaleDateString("hu-HU", { month: "long", day: "numeric" })).attr("x", width - 151).attr("y", -6);
    			updateLabels(focusTexts, averagesByCandidate, x, y);
    			chartGroup.selectAll(".overlay-box").remove(); // Clear existing box
    			chartGroup.append("rect").attr("class", "overlay-box").attr("x", width - 150).attr("y", 0).attr("width", 100).attr("height", height).attr("fill", "white").attr("opacity", 0.8);
    			Object.values(focusTexts).forEach(text => text.raise());
    		});
    	}

    	function handleMouseMove(
    		event,
    	chartGroup,
    	averagesByCandidate,
    	x,
    	y,
    	width,
    	height,
    	verticalLine,
    	dateLabel,
    	focusTexts
    	) {
    		const mouse = pointer(event);
    		const mouseDate = x.invert(mouse[0]);
    		const roundedDate = new Date(mouseDate);
    		roundedDate.setHours(0, 0, 0, 0);

    		if (mouseDate.getHours() >= 12) {
    			roundedDate.setDate(roundedDate.getDate() + 1);
    		}

    		const lineDate = new Date(roundedDate.getTime() - 86400000); // Subtract 1 day from the date
    		verticalLine.attr("x1", x(lineDate) - 1).attr("x2", x(lineDate));
    		dateLabel.text(roundedDate.toLocaleDateString("hu-HU", { month: "long", day: "numeric" })).attr("x", x(lineDate));

    		// Add half-opaque white box to the right of the vertical line
    		chartGroup.selectAll(".overlay-box").remove(); // Clear existing box

    		chartGroup.append("rect").attr("class", "overlay-box").attr("x", x(lineDate)).attr("y", 0).attr("width", width - x(lineDate)).attr("height", height).attr("fill", "white").attr("opacity", 0.8);

    		// Put the labels at the end of the svg rendering order
    		Object.values(focusTexts).forEach(text => text.raise());

    		updateLabels(focusTexts, averagesByCandidate, x, y, lineDate);
    		fixLabelPositions(focusTexts);
    	}

    	function updateLabels(focusTexts, averagesByCandidate, x, y, lineDate = null) {
    		if (!lineDate) {
    			lineDate = max$4(averagesByCandidate[0].values, d => d.date);
    		}

    		// Find the closest data point for each candidate
    		averagesByCandidate.forEach(({ candidate, values }) => {
    			let closestValue = values[0];
    			let minDiff = Math.abs(lineDate - values[0].date);

    			values.forEach(v => {
    				const diff = Math.abs(lineDate - v.date);

    				if (diff < minDiff) {
    					closestValue = v;
    					minDiff = diff;
    				}
    			});

    			// Update focus text
    			if (closestValue) {
    				focusTexts[candidate].text(`${candidate}: `).attr("x", x(closestValue.date) + 12).attr("y", y(closestValue.avg)).style("font-size", "1.4rem").append("tspan").text(`${(closestValue.avg * 100).toFixed(1)}`).attr("style", `fill: ${colors[candidate]}; font-weight: 500; font-family: 'courier'; dominant-baseline: middle;`);
    			} else {
    				focusTexts[candidate].text(""); // Clear the label if no data
    			}
    		});
    	}

    	fetchData();
    	const writable_props = ['repo'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('repo' in $$props) $$invalidate(3, repo = $$props.repo);
    	};

    	$$self.$capture_state = () => ({
    		d3,
    		Gauge,
    		repo,
    		demLead,
    		leadHTML,
    		aggregatorsCurrent,
    		colors,
    		fetchPollData,
    		isDataStale,
    		getPollData,
    		prepareData,
    		setDemLeadAndWinningHTML,
    		setAggregatorsCurrent,
    		fetchData,
    		calculateAveragesByCandidate,
    		drawChart,
    		setupChart,
    		drawLines,
    		drawDots,
    		drawGridlines,
    		setupInteractivity,
    		initializeFocusTexts,
    		handleMouseMove,
    		updateLabels,
    		fixLabelPositions
    	});

    	$$self.$inject_state = $$props => {
    		if ('repo' in $$props) $$invalidate(3, repo = $$props.repo);
    		if ('demLead' in $$props) $$invalidate(0, demLead = $$props.demLead);
    		if ('leadHTML' in $$props) $$invalidate(1, leadHTML = $$props.leadHTML);
    		if ('aggregatorsCurrent' in $$props) $$invalidate(2, aggregatorsCurrent = $$props.aggregatorsCurrent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [demLead, leadHTML, aggregatorsCurrent, repo];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance, create_fragment, safe_not_equal, { repo: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get repo() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set repo(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const app = new App({
    	target: document.body,
    	props: {
    		repo: 'hidegmisi/us2024_aggregator_scraper'
    	},
    	customElement: true,
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
